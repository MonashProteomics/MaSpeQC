<head>
    <title>MaSpeQC</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://kit.fontawesome.com/f77ac44772.js" crossorigin="anonymous"></script> <!--Font Awesome icons-->
    <script src="./javascripts/control.js"></script>
    <script src="./javascripts/forceGraphProteomics.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v6.js"></script> <!--D3-->
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script> <!--d3 force boundary add on-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="./stylesheets/style.css"  />
    <script type="text/javascript">

        /* machine_data object structure (after load)*/

        /*components (Array #COMPONENTS){
            component_name
            component_mode
            component_id
            colour
            chromatograms (Array #RUNS) {
                exp_rt
                intensities (Array #READINGS)
                rts (Array #READINGS)
                mz
            }
            lcms_metrics{
                metric_name{
                    values (Array #RUNS) 
                    missing (Array #MISSING)
                } 
            }
            stats{
                metric_name{
                    mean
                    std
                    min
                    max
                    25_percent
                    50_percent
                    75_percent
                }
            }
        }
        lcms_metrics (Array #METRICS){
            display_order
            display_name
            metric_id
            yScale
            xScale
            lineWidth
            radius
            thresholds{
                threshold_trigger
                threshold_low
                threshold_high
            }
        }
        ms2_metrics (Array #METRICS){
            display_order
            display_name
            metric_id
            yScale
            xScale
            lineWidth
            radius
            thresholds{
                threshold_trigger
                threshold_low
                threshold_high
            }
            values(Array #RUNS)
            missing (Array #MISSING)
            stats{
                mean
                std
                min
                max
                25_percent
                50_percent
                75_percent
            }
        }
        machine_details{
            display_metric
            experiment
            machine_name
            machine_type
        }
        pressure_metrics (Array #METRICS){
            display_order
            display_name
            metric_description
            yScale
            xScale
            lineWidth
            radius
            values (Array #RUNS) // DEV: only 10 runs
            missing (Array #MISSING)
            stats{
                mean
                std
                min
                max
                25_percent
                50_percent
                75_percent
            }
        }
        run_data (Array #RUNS){
            run_id
            date_time
            pressure_profile_np{
                intensities
                rts
            }
            pressure_profile_lp{
                intensities
                rts
            }
            summary{
                metric_name{
                    component (Array 1)
                }
            }
        }
        */

        /* FUNCTIONS 
        *EVENT document.onmouseover - handles the tooltips display 
        *EVENT document.onmouseout - handles tooltip removal 
        *EVENT document.onclick - handles page reload or change 
        *create_navbar_dropdown - adds machines to charts dropdown
        *diff_days - returns number of days between a data and current day
        *getTime - creates the time without seconds 
        create_layout - creates the grid layout
        create_pressure_profile - creates the pressure profile interface
        create_header_display - creates the header display and controls
        create_chromatogram - creates the chromatogram display interface
        create_components_menu - creates the components menu and check boxes
        create_metric_menu - creates the metric menu and radio checks
        create_chart_area - creates the main chart display interface
        draw_pressure_profile - draws the pressure profile
            - updateChart - updates the chart for x-zoom
        draw_chromatogram - draws the chromatogram
            - updateChart - updates the chart for x-zoom
        draw_ms2_line - draws the line chart for ms2 metrics
            - updateZoom - updates the chart for xy-zoom
        draw_line_chart - draws the line chart for lcms metrics
            - updateZoom - updates the chart for xy-zoom
        draw_pressure_line - draws the line chart for pressure metrics
            - updateZoom - updates the chart for xy-zoom
        draw_box_plot - draws the box plots for lcms metrics 
            - moveBoxes - transitions box plots
        draw_heat_map - draws the heat maps for lcms metrics
        draw_parallel_graph - draws the lc-ms parallel chart
            update_parallel_graph
        draw_ms2_parallel_graph - draws the ms2 parallel chart
        draw_stream_graph - draws the lc-ms stream graph
            update_stream_graph
        draw_ms2_stream_graph - draws the ms2 stream graph
        draw_force_main - draws the force graph for proteomics
        setTimeScale - handles change to time
        setRunScale - handels change to runs
            updateChangeScale - 
            updateChangeScaleStream -
            updateChangeScalePressure - 
            updateChangeScaleMS2 - 
            updateChangeScaleStreamMS2 -
        displayRuns - handles change of runs filter
            lineChartFilterUpdate
            streamChartFilterUpdate
        componentDraw - handles change of component re-draw
        controlsDraw - handles change of control state redraw

        getThresholds - returns the low and high threshold markers for display metric (if any)
        getComponentIndexes - returns index of checkedcomponents
        autoflipcard - rotate the card when pressure metric selected
        updateMarker - moves vertical line marker on line charts
        updateHeatMarker - moves horizontal marker on heat maps
        EVENT flipcard - callback to rotate the pressure profile
        EVENT controlUpdate - updates chromatogram, pressurre profile and header display (LR)
        EVENT controlDouble - updates chromatogram, pressurre profile and header display (double arrow)
        EVENT reSize - redraws charts on page resize
        EVENT clickSelectAll - handles click of select all
        EVENT updateChartType - changes between charts (line,box,heat)
        EVENT radioUpdate - changes between metrics from radio controls
        */


        // get machine data from controller
        let machine_data = <%-JSON.stringify(ejs_machine_data)%>;
     
        // get all machine names from storage for nav bar
        var proteomics = JSON.parse(sessionStorage.getItem("proteomics-machines"));
        var metabolomics = JSON.parse(sessionStorage.getItem("metabolomics-machines"));
        
        // state variables
        let run_index = 0; 
        let comp_index = 0;
        let filter = 10;
        let display_metric = "Mass Error (ppm)";
        let chart_type = "force";
        let mainForce = false;
        let metric_type = "lcms";
        let pressure_type = "loading";
        let metric_menu_display = "lcms";
        let menu_state = {"lcms": false, "ms2": false, "loading": false, "nano": false};
        let menu_show = false;
        let checked_components = {};
        let chromModal = false;
        let pressureModal = false;
        let menuModal = false;
        let theme = "light";
        let boxExpand = -1;
        let streamExpand = false;
        let offsetType = d3.stackOffsetNone;//d3.stackOffsetNone; //d3.stackOffsetSilhouette; //  
        let scaleType = "runs";
        let controls = true;
        let chromExpand = false;

        // global variables

        /* SCALE CHANGE */
        let xScale_chart = null; // set this to "runs" or "time"
        let xScale_runs = null;
        let xScale_time = null;
        let x_axis = null; // set this to "runs" or "time"
        let x_axis_runs = null;
        let x_axis_time = null;
        let x_values_chart = null; // set this to "runs" or "time"
        let x_values_runs = null;
        let x_values_time = null;

        /* STREAM EXPAND */
        let yScale_stream_expand = null;
        let yScale_stream_total = null;
        let yScale_stream = null; // set this to "total" or "expand"
        let y_axis_stream; // set this to "total" or "expand"
        let y_axis_stream_total;
        let y_axis_stream_expand;

        /* STREAM EXPAND MS2*/
        let yScale_stream_expand_ms2 = null;
        let yScale_stream_total_ms2 = null;
        let yScale_stream_ms2 = null; // set this to "total" or "expand"
        let y_axis_stream_ms2; // set this to "total" or "expand"
        let y_axis_stream_total_ms2;
        let y_axis_stream_expand_ms2;

        /* pressure profile */
        let y_axis_pressure = null;

        let reDrawChart;
        let reDrawPressureChart;
        let reDrawMS2Chart;
        let chart_height;
        let header_height;
        let cell_height;
        let v_height_unit;
        let v_width_unit;
        let colourByKey;
        let stackKeys = [];
        let stackKeysMS2 = null;
        let yScales = {}; // parallel scales
        let yScales_ms2 = {}; // parallel scales
        let xScale_chrom = null;
        let xScale_pressure_load = null;
        let xScale_pressure_nano = null;
        let xScale_par = null;
        let xScale_par_ms2 = null;
        let yScale_pressure_load = null;
        let yScale_pressure_nano = null;
        let yScale_chart = null;
        let yScale_pressure = null;
        let yScale_ms2 = null;
        let yScale_box = null;
        let xScale_box = null;
        let box_area_height = null;
        let profileHeight;
        let tooltipElem; // tooltip for interface
        let zoom = false;
        let base_radius;
        let radius; // min for line charts (scales on zoom)
        let base_line_width;
        let box_width;
        let lineChartWidth;
        let ms2Height; // needed for ms2 line transitions
        let pressureHeight; // as above for pressure
        let currentRadius; // biggest circle
        let lineWidth; // min for line charts (scales on zoom)
        const machine_types = {"agilent": "Agilent",  "bruker": "Bruker", "thermo": "Thermo Fisher", 
                                "sciex": "Sciex", "shimadzu": "Shimadzu", "waters": "Waters", "other": "Other", "none" : "None"};
        let y_labels = {"Mass Error (ppm)": "Parts Per Million",
                        "Mass Error (mDa)": "Milli Dalton",
                        "Retention Time": "Minutes",
                        "Area (normalised)" : "Log Normalised (Median)",
                        "Height (normalised)": "Log Normalised (Median)",
                        "Full Width Half Maximum": "Seconds",
                        "Tailing": "Seconds",
                        "Asymmetry": "Seconds"} // check tailing and asymmetry
        let heat_ranges = {"Mass Error (ppm)": {low:-4, hi: 4},
                        "Mass Error (mDa)": {low:-2, hi: 2},
                        "Area (normalised)" : {low:-3, hi: 3},
                        "Height (normalised)": {low:-3, hi: 3},
                        "Tailing": {low:0, hi: 2},
                        "Asymmetry": {low:0, hi: 2}};

        let density_ranges = {
                        "Area (normalised)" : {low:-4, hi: 4},
                        "Height (normalised)": {low:-4, hi: 4},
                        "Tailing": {low:-1, hi: 4},
                        "Asymmetry": {low:-1, hi: 4},
                        "Full Width Half Maximum": {low:0, hi:30},
                        "Mass Error (mDa)": {low:-3, hi: 3}};

        // obj convert to display names from summary and db 
        // catches mismatch of names and converts to consistent display names
        // store 'sames' too 
        var metrics_obj_prot = {
                    "mass_error_ppm" : "Mass Error (ppm)",
                    "rt": "Retention Time",
                    "area_normalised": "Area (normalised)",
                    "af" : "Asymmetry",
                    "tf" : "Tailing",
                    "fwhm": "Full Width Half Maximum",
                    "MS/MS Spectra (Morpheus)" : "MS/MS Spectra",
                    "PSM" : "Target PSMs",
                    "Unique Peptides" : "Unique Target Peptides",
                    "Protein Groups" : "Target Protein Groups",
                    "MS/MS Spectra" : "MS/MS Spectra",
                    "Target PSMs" : "Target PSMs",
                    "Unique Target Peptides" : "Unique Target Peptides",
                    "Target Protein Groups" : "Target Protein Groups",
                    "Precursor Mass Error" : "Precursor Mass Error",
                    "Precursor Mass Error ppm" : "Precursor Mass Error",
                    "Area Normalised" : "Area (normalised)",
                    "Height Normalised" : "Height (normalised)",
                    "Mass Error ppm" :  "Mass Error (ppm)",
                    "Asymmetry Factor" : "Asymmetry",
                    "Tailing Factor" : "Tailing",
                    "Mass Error (ppm)" : "Mass Error (ppm)",
					"Retention Time" : "Retention Time",
					"Full Width Half Maximum" : "Full Width Half Maximum",
                    "Mass Error (mDa)" : "Mass Error (mDa)",
                    "Area (normalised)" : "Area (normalised)",
                    "Height (normalised)" : "Height (normalised)",
                    "Tailing" : "Tailing",
                    "Asymmetry": "Asymmetry"
                }
        
        // ms2 display names
        var ms2_display_names = ["MS/MS Spectra", "Target PSMs", "Unique Target Peptides", "Target Protein Groups", "Precursor Mass Error"];

        // convert dates, pressure profile and summary
        for(let i in machine_data.run_data){
            // dates
            machine_data.run_data[i].date_time = new Date(machine_data.run_data[i].date_time);

            // summaries
            try{
                var summary = JSON.parse(machine_data.run_data[i].summary[0].summary);
                machine_data.run_data[i].summary = summary;
                }
                catch(e){ // undefined, no summary data (should always be!!)
                    machine_data.run_data[i].summary = false;
                    //console.log(e);
            }

            // pressure
            if(machine_data.machine_details.machine_type == "thermo"){ // pressure profile thermo only
                // loading
                try{
                    var profile_lp = JSON.parse(machine_data.run_data[i].pressure_profile_lp[0][0].pressure_data);
                    machine_data.run_data[i].pressure_profile_lp = profile_lp;
                }
                catch(e){ // undefined, no pressure data
                    machine_data.run_data[i].pressure_profile_lp = {};
                }
                // nano
                try{
                    var profile_np = JSON.parse(machine_data.run_data[i].pressure_profile_np[0][0].pressure_data);
                    machine_data.run_data[i].pressure_profile_np = profile_np;
                }
                catch(e){ // undefined, no pressure data
                    machine_data.run_data[i].pressure_profile_np = {};
                }
            }
        }

        // convert chromatograms
        for(let i in machine_data.components){
            for(let j in machine_data.components[i].chromatograms){
                try{
                    var new_chrom_data = JSON.parse(machine_data.components[i].chromatograms[j][0].chrom_data);
                    machine_data.components[i].chromatograms[j] = new_chrom_data;
                }
                catch{ // no chrom data
                    machine_data.components[i].chromatograms[j] = {};
                }
            }
        } 

        // convert chrom x-values and create d3 data (REMOVE with trans updates)
        for(let i in machine_data.components){
            for(let j in machine_data.components[i].chromatograms){
                var cgram = machine_data.components[i].chromatograms[j];

                // no chrom data
                if(Object.keys(cgram).length == 0){
                    machine_data.components[i].chromatograms[j] = []; 
                    continue;
                }

                // get values to plot (and store max)
                var y_values = cgram.intensities;
                var x_values_deltas = cgram.rts;

                // transform x values from deltas
                var last = 0;
                //var x_values = [];
                var data = [];
                for(let x in x_values_deltas){
                    let current = x_values_deltas[x] / 1000 + last;
                    //let new_row = {"x": (total + x_values_deltas[x])/60, "y": y_values[x]};
                    let new_row = {"x": current, "y": y_values[x]};
                    data.push(new_row);
                    last = current;
                }

                // store
                machine_data.components[i].chromatograms[j] = data;
            }
        }



        // colours (12 components max .. set in config)
        // https://github.com/d3/d3-scale-chromatic

         // https://carto.com/carto-colors/
         var cartoPastel = ["#66C5CC","#F6CF71","#F89C74","#DCB0F2",
                        "#87C55F","#9EB9F3","#FE88B1","#C9DB74","#8BE0A4","#B497E7","#D3B484","#B3B3B3"];
        
        var cartoPrism = ["#5F4690","#1D6996","#38A6A5","#0F8554",
                        "#73AF48","#EDAD08","#E17C05","#CC503E","#94346E","#6F4070","#994E95","#666666"];
        
        var cartoBold = ["#7F3C8D","#11A579","#3969AC","#F2B701",
                        "#E73F74","#80BA5A","#E68310","#008695","#CF1C90","#f97b72","#4b4b8f","#A5AA99"];

        var cartoAntique = ["#855C75","#D9AF6B","#AF6458","#736F4C",
                            "#526A83","#625377","#68855C","#9C9C5E","#A06177","#8C785D","#467378","#7C7C7C"];

        var cartoSafe = ["#88CCEE","#CC6677","#DDCC77","#117733",
                        "#332288","#AA4499","#44AA99","#999933","#882255","#661100","#6699CC","#888888"];

        var cartoVivid = ["#E58606","#5D69B1","#52BCA3","#99C945",
                        "#CC61B0","#24796C","#DAA51B","#2F8AC4","#764E9F","#ED645A","#CC3A8E","#A5AA99"];
        
        var colours = d3.schemeCategory10; // 10 colours
        var extra_colours = d3.schemeAccent; // 8 colours

        // add 5 extra to palette (15 allowed)
        for(let i = extra_colours.length - 1; i> extra_colours.length - 6; i--){
            colours.push(extra_colours[i]);
        }

        //  add to object
        var p_index = 0;
        for(let i in machine_data.components){
            machine_data.components[i]["colour"] = cartoVivid[p_index];
            p_index +=1;
        }

        // add ms2 colours
        for(let i in machine_data.ms2_metrics){
            machine_data.ms2_metrics[i]["colour"] = cartoPastel[i];
        }

        /* Impute Missing Values - LCMS*/
        // mda, ppm +- 1000
        // RT, FWHM 0
        // Area Height -100
        // Tailing, Asymmetry 0,1 (CHECK: 1??)
        // REFACTOR?: set missings to null in processing and catch here
        var impute_names = ["Mass Error (ppm)", "Mass Error (mDa)", "Area (normalised)", "Height (normalised)"];
        for(let i in machine_data.components){
            var metric_data = machine_data.components[i].lcms_metrics;
            // loop metrics
            for(let metric in metric_data){
                var missing_indexes = []; // add marker on chart
                // values in array
                for(let value in metric_data[metric]){
                    if(impute_names.includes(metric)){
                        if(metric_data[metric][value] <= -100 || metric_data[metric][value] >= 100){ 
                            if(value > 0){
                                machine_data.components[i].lcms_metrics[metric][value] = machine_data.components[i].lcms_metrics[metric][value - 1];
                                missing_indexes.push(parseInt(value));
                            }
                            else{ // if first then just set to zero
                                machine_data.components[i].lcms_metrics[metric][value] = 0;
                                missing_indexes.push(parseInt(value));
                            }
                        }
                    }
                    else{
                        if(metric_data[metric][value] == 0 || metric_data[metric][value] == 1){
                            if(value > 0){
                                machine_data.components[i].lcms_metrics[metric][value] = machine_data.components[i].lcms_metrics[metric][value - 1];
                                missing_indexes.push(parseInt(value));
    
                            }
                            else{ // if first then just set to zero
                                machine_data.components[i].lcms_metrics[metric][value] = 0;
                                missing_indexes.push(parseInt(value));
                            }
                        }
                    }  
                }
                // add new values and missing to machine_data obj
                var values = machine_data.components[i].lcms_metrics[metric];
                machine_data.components[i].lcms_metrics[metric] = {"values": values, "missing": missing_indexes}   
            }
        }

        /* Impute Missing Values - Pressure*/
        /* Possible nulls but may change in processing */
        if(machine_data.machine_details.machine_type == "thermo"){
            for(let i in machine_data.pressure_metrics){
                var missing_indexes = [];
                for(let value in machine_data.pressure_metrics[i].values){
                    var new_value = machine_data.pressure_metrics[i].values[value];
                    if(new_value == null){
                        if(value==0){ // if first just put to zero
                            machine_data.pressure_metrics[i].values[value] = 0
                            missing_indexes.push(parseInt(value));
                        }
                        else{
                            machine_data.pressure_metrics[i].values[value] = machine_data.pressure_metrics[i].values[value-1];
                            missing_indexes.push(parseInt(value));
                        }
                    }
                }
                machine_data.pressure_metrics[i]["missing"] = missing_indexes;
            }
        }

        // CHECK: which values are missing
        if(machine_data.machine_details.machine_type == "thermo"){
        // catch mismatch of #RUNS to metric values (less MIPS in testing)
            for(let i in machine_data.pressure_metrics){
                var new_index = machine_data.pressure_metrics[i].values.length;
                while(machine_data.pressure_metrics[i].values.length != machine_data.run_data.length){
                    machine_data.pressure_metrics[i].values.push(machine_data.pressure_metrics[i].values[0]);
                    machine_data.pressure_metrics[i].missing.push(new_index);
                    new_index += 1;
                }
            }
        }

        /* Impute Missing Values - MS2*/
        // May need to handle missing values from Morpheus summary file (if they aren't caught as null)
        for(let i in machine_data.ms2_metrics){
            var missing_indexes = [];
            for(let value in machine_data.ms2_metrics[i].values){
                var new_value = machine_data.ms2_metrics[i].values[value];
                if(new_value == null || new_value == -1){ // -1 is ppm
                    if(value==0){ // if first just put to zero
                        machine_data.ms2_metrics[i].values[value] = 0
                        missing_indexes.push(parseInt(value));
                    }
                    else{
                        machine_data.ms2_metrics[i].values[value] = machine_data.ms2_metrics[i].values[value-1];
                        missing_indexes.push(parseInt(value));
                    }
                }
            }
            machine_data.ms2_metrics[i]["missing"] = missing_indexes;
        }

        // catch mismatch of #RUNS to metric values MS2 
        for(let i in machine_data.ms2_metrics){
                var new_index = machine_data.ms2_metrics[i].values.length;
                while(machine_data.ms2_metrics[i].values.length != machine_data.run_data.length){
                    machine_data.ms2_metrics[i].values.push(machine_data.ms2_metrics[i].values[0]);
                    machine_data.ms2_metrics[i].missing.push(new_index);
                    new_index += 1;
                }
        }

        // add yscale/xscale storage for zoom LCMS
        for(let i in machine_data.lcms_metrics){
            machine_data.lcms_metrics[i].yScale = null;
           // machine_data.lcms_metrics[i].xScale = null;
            machine_data.lcms_metrics[i].lineWidth = null;
            machine_data.lcms_metrics[i].radius = null;
        }

        // add yscale/xscale storage for zoom MS2
        for(let i in machine_data.ms2_metrics){
            machine_data.ms2_metrics[i].yScale = null;
            //machine_data.ms2_metrics[i].xScale = null;
            machine_data.ms2_metrics[i].lineWidth = null;
            machine_data.ms2_metrics[i].radius = null;
        }

        if(machine_data.machine_details.machine_type == "thermo"){
            // add yscale/xscale storage for zoom PRESSURE
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].lineWidth = null;
                machine_data.pressure_metrics[i].radius = null;
            }
        }

        // remove Morpheus from display names and convert to object format above
        for(let i in machine_data.ms2_metrics){
            var full_name = machine_data.ms2_metrics[i].display_name;
            machine_data.ms2_metrics[i].display_name = metrics_obj_prot[full_name.substring(0, full_name.length-11)];
        }

        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

            console.log(machine_data);
            
            // set layout variables
            var navHeight = document.getElementById("navcontainer").clientHeight;
            chart_height = parseInt((window.innerHeight-navHeight)*2/3)/16; // in rem at 16
            header_height = parseInt((window.innerHeight-navHeight)*1/3)/16;
            v_height_unit = window.innerHeight/100;
            v_width_unit = window.innerWidth/100;

            // set chart element sizes
            base_radius = 3*v_height_unit/5;
            radius = base_radius; // min for line charts 
            currentRadius = radius*2;
            base_line_width = base_radius/2;
            lineWidth = base_line_width; // min for line charts 
           
            // update home tooltip
            var home = document.getElementById("home");
            home.setAttribute("data-tooltip", "Click for Summary Page");

            // create a global tooltip for charts
            let tooltip = d3.select("body") 
                .append("div")
                .attr("class", "configTooltip")
                .attr("id", "tooltip")
                .style("visibility", "hidden");

            // create a draggable tooltip (chrom)
            d3.select("body") 
                .append("div")
                .attr("class", "dragTooltip")
                .attr("id", "chromTool")
                .style("visibility", "hidden");

            dragElement(document.getElementById("chromTool"));

            // create a draggable tooltip (pressure))
            d3.select("body") 
                .append("div")
                .attr("class", "dragTooltip")
                .attr("id", "pressureTool")
                .style("visibility", "hidden");

            dragElement(document.getElementById("pressureTool"));

            create_layout();
            create_header_display();
            create_navbar_dropdown();
            create_chromatogram();
            
            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                create_pressure_profile();
            }

            // create checked components look up (initial all)
            for(let i=0; i<machine_data.components.length; i++){
                checked_components[machine_data.components[i].component_name] = true;
            }

            // set stack keys for stream
            for(let i in machine_data.components){
                stackKeys.push(machine_data.components[i].component_name);
            }

            // create a draggable menu
            d3.select("body") 
                .append("div")
                .attr("id", "menu")
                .attr("class", "dragMenu")
                .style("width", "25vw")
                .style("visibility", "hidden");

            // make draggable
            dragElement(document.getElementById("menu"));
            document.getElementById("menu").style.display = "block";

            create_components_menu(true);
            create_chart_area();

            // set controls hide/show
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");

            if(controls){
                chart_top.style.display = "block";
                chart_bottom.style.display = "block";
            } else{
                chart_top.style.display = "none";
                chart_bottom.style.display = "none";
            }
            
            // convert to consistent display name
            display_metric = metrics_obj_prot[display_metric];

            // initial draw
            draw_force_main(true);

            // needs display metric
            create_metric_menu(true);

            // check theme radios
            if(theme == "dark"){
                document.getElementById("darkRadio").checked = true;
                document.getElementById("lightRadio").checked = false;

            }
            else{
                document.getElementById("darkRadio").checked = false;
                document.getElementById("lightRadio").checked = true;
            }
            
            // disable buttons based on display metric from summary
            if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                document.getElementById("box").disabled = true;
            }
            else if(display_metric == "Retention Time"){
                document.getElementById("heat").disabled = true;
            }
            else if(display_metric == "Full Width Half Maximum"){
                document.getElementById("heat").disabled = true;
            }
            else if(ms2_display_names.includes(display_metric)){
                document.getElementById("box").disabled = true;
                document.getElementById("heat").disabled = true;
            }

        }, false);
        
        function create_layout(){
            // get grid
            var grid = document.getElementById("grid");

            // create firt row
            var first_row = document.createElement("div");
            first_row.className = "row";
            //first_row.style.height = header_height + "rem";

            // chromatogram
            var new_col_1 = document.createElement("div");
            new_col_1.className = "col-sm-3 chart-cell";
            new_col_1.style.height = header_height + "rem"; 
            new_col_1.id = "cgram";
            first_row.append(new_col_1);

            // header display area
            var new_col_2 = document.createElement("div");
            new_col_2.className = "col-sm-6 chart-cell";
            new_col_2.style.height = header_height + "rem"; // may need to add to other cols
            new_col_2.id = "header";
            first_row.append(new_col_2);

            // pressure profile
            var new_col_3 = document.createElement("div");
            new_col_3.className = "col-sm-3 chart-cell";
            new_col_3.style.height = header_height + "rem";
            new_col_3.id = "pressure";
            first_row.append(new_col_3);

            // second row
            var second_row = document.createElement("div");
            second_row.className = "row";
            second_row.style.height = chart_height + "rem";

            // components
            var new2_col_1 = document.createElement("div");
            new2_col_1.className = "col-sm-2 chart-cell";
            new2_col_1.style.height = chart_height + "rem";
            new2_col_1.id = "components";
            second_row.append(new2_col_1);

            // chart area
            var new2_col_2 = document.createElement("div");
            new2_col_2.className = "col-sm-10 chart-cell";
            new2_col_2.style.height = chart_height + "rem";
            new2_col_2.id = "chart";
            second_row.append(new2_col_2);

            // menu
            //var new2_col_3 = document.createElement("div");
            //new2_col_3.className = "col-sm-3 chart-cell";
            //new2_col_3.style.height = chart_height + "rem";
            //new2_col_3.id = "menu";
            //second_row.append(new2_col_3);

            // add rows to grid
            grid.append(first_row);
            grid.append(second_row);
        }

        function create_pressure_profile(){

            // get container
            var profile_div = document.getElementById("pressure");

            /* flip card */
            // tile inner
            let new_inner = document.createElement("div");
            new_inner.className = "tile-inner";
            new_inner.setAttribute("data-state", "front");
            new_inner.style.left = "0%";
            new_inner.style.top = "2.5%"; 
            new_inner.style.width = "92.5%";
            new_inner.style.height = "95%";
            new_inner.style.fontSize = "2vh";
            //new_inner.style.backgroundColor = "white";
            //new_inner.style.border = "0.4em double var(--dark)";
            //new_inner.style.borderRadius = "0.3em";
            new_inner.id = "profile_inner";

            // tile front
            let new_front = document.createElement("div");
            new_front.style.paddingTop = 0; // remove padding from class
            //new_front.style.fontSize = "1rem";
            new_front.style.opacity = 0;
            new_front.style.borderTopLeftRadius = "0em";
            new_front.style.borderBottomLeftRadius = "0em";
            if(theme == "dark"){new_front.className = "profile-front darkTheme Theme";}
            else{new_front.className = "profile-front lightTheme Theme";}
            new_front.id = "profile_front";
            
            // tile back
            let new_back = document.createElement("div");
            new_back.style.borderTopLeftRadius = "0em";
            new_back.style.borderBottomLeftRadius = "0em";
            if(theme == "dark"){new_back.className = "profile-back darkTheme Theme";}
            else{new_back.className = "profile-back lightTheme Theme";}
            new_back.id = "profile_back";
             
            // header
            var profile_header = document.createElement("p");
            profile_header.innerHTML = "PRESSURE PROFILE";
            profile_header.style.backgroundColor = "var(--dark)";
            profile_header.style.color = "var(--white)";
            profile_header.className = "text-center";
            profile_header.style.fontSize = "1.8vh";
            profile_header.style.fontWeight = 700;
            //profile_header.style.height = "9%";
            profile_header.id = "profile_header";

            // flip icon
            let new_span = document.createElement("span");
            new_span.className = "fas fa-exchange-alt";
            new_span.style.color = "var(--white)";
            new_span.style.marginLeft = "2em";
            new_span.style.cursor = "pointer";
            new_span.setAttribute("data-rotate", "false");
           

            // clone then add event listeners (not copied on clone)
            let new_span_back = new_span.cloneNode(true);
            new_span.addEventListener("click", flipcard);
            new_span_back.addEventListener("click", flipcard);

            // add tooltips
            new_span.setAttribute("data-tooltip","Flip to View Nano Pump");
            new_span_back.setAttribute("data-tooltip","Flip to View Loading Pump");

            // clone header for back
            var profile_header_back = profile_header.cloneNode(true);

            // add icons
            profile_header.append(new_span);
            profile_header_back.append(new_span_back);

            // pump header
            var profile_pump_header = document.createElement("p");
            profile_pump_header.innerHTML = "Loading Pump";
            //profile_pump_header.style.backgroundColor = "lightgray";
            if(theme == "dark"){profile_pump_header.className = "text-center headerDarkTheme Theme";}
            else{profile_pump_header.className = "text-center headerLightTheme Theme";}
            //profile_pump_header.style.fontWeight = "bold";
            //profile_pump_header.className = "text-center";
            //profile_pump_header.style.fontSize = "0.6em";
            //profile_pump_header.style.height = "9%";
            profile_pump_header.id = "profile_pump_header";

            // clone for back
            var profile_pump_header_back = profile_pump_header.cloneNode(true);
            profile_pump_header_back.innerHTML = "Nano Pump";

            // append headers
            new_front.append(profile_header);
            new_front.append(profile_pump_header);
            new_back.append(profile_header_back);
            new_back.append(profile_pump_header_back);

            // plot area front
            var plot_area = document.createElement("div");
            plot_area.id = "plot_pressure";
            plot_area.style.width = "100%";
            plot_area.style.height = "82%";
            plot_area.style.opacity = 0;
			//plot_area.style.overflow = "hidden";

            // put on overlay if not thermo
            if(machine_data.machine_details.machine_type != "thermo"){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Pressure Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                new_display.id = "pressure_overlay";
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_pressure").transition(t).style("opacity", 0.5);
            }

            // plot area back
            var plot_area_back = document.createElement("div");
            plot_area_back.id = "plot_pressure_back";
            plot_area_back.style.width = "100%";
            plot_area_back.style.height = "82%";
            plot_area_back.style.opacity = 0;
			//plot_area_back.style.overflow = "hidden";

            // put on overlay if not thermo
            if(machine_data.machine_details.machine_type != "thermo"){
                plot_area_back.style.backgroundColor = "var(--dark)";
                plot_area_back.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Pressure Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                new_display.id = "pressure_overlay_back";
                plot_area_back.append(new_display);
            }

            new_front.append(plot_area);
            new_back.append(plot_area_back);
            new_inner.append(new_front);
            new_inner.append(new_back);
            profile_div.append(new_inner);

            // draw the profile for thermo machines
            if(machine_data.machine_details.machine_type == "thermo"){ 
                pressure_type = "nano";
                draw_pressure_profile(false);
                pressure_type = "loading";
                draw_pressure_profile(false);
            }

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#profile_front").transition(t).style("opacity", 1);

        }

        function create_chromatogram(){
            // get container
            var cgram_div = document.getElementById("cgram");

            // div for content
            var cgram_inner = document.createElement("div");
            cgram_inner.style.position = "absolute";
            cgram_inner.style.left = "2.5%";
            cgram_inner.style.top = "2.5%"; 
            cgram_inner.style.width = "97.5%";
            cgram_inner.style.height = "95%";
            //cgram_inner.style.backgroundColor = "var(--dark)";
            if(theme == "dark"){cgram_inner.className = "darkTheme Theme";}
            else{cgram_inner.className = "lightTheme Theme";}
            cgram_inner.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            cgram_inner.style.borderTopRightRadius = "0em";
            cgram_inner.style.borderBottomRightRadius = "0em";
            cgram_inner.style.fontSize = "2vh";
            cgram_inner.style.opacity = 0;
            //cgram_inner.style.overflow = "hidden";
            cgram_inner.id = "cgram_inner";

            // cgram header
            var cgram_header = document.createElement("p");
            cgram_header.innerHTML = "CHROMATOGRAM";
            cgram_header.style.backgroundColor = "var(--dark)";
            cgram_header.style.color = "var(--white)";
            cgram_header.className = "text-center";
            cgram_header.style.fontSize = "1.8vh";
            cgram_header.style.fontWeight = 700;
            //cgram_header.style.height = "9%";
            cgram_header.id = "cgram_header";

            // cgram metric header
            var cgram_metric_header = document.createElement("p");
            if(theme == "dark"){cgram_metric_header.className = "text-center headerDarkTheme Theme";}
            else{cgram_metric_header.className = "text-center headerLightTheme Theme";}
            cgram_metric_header.id = "cgram_metric_header";

            // plot area 
            var plot_area = document.createElement("div");
            plot_area.id = "plot_cgram";
            plot_area.style.width = "100%";
            plot_area.style.height = "82%";
            plot_area.style.opacity = 0;

            // append
            cgram_inner.append(cgram_header);
            cgram_inner.append(cgram_metric_header);
            cgram_inner.append(plot_area);
            cgram_div.append(cgram_inner);

            // draw
            draw_chromatogram(false);

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#cgram_inner").transition(t).style("opacity", 1);
        }

        function create_components_menu(transition){
            // get container
            var comp_menu_div = document.getElementById("components");

            // remove any elements
            while (comp_menu_div.firstChild) {
                comp_menu_div.removeChild(comp_menu_div.firstChild);
            }

            // div for content
            var comp_menu_inner = document.createElement("div");
            comp_menu_inner.style.position = "absolute";
            comp_menu_inner.style.left = "2.5%";
            comp_menu_inner.style.top = "2.5%"; 
            comp_menu_inner.style.width = "97.5%";
            //comp_menu_inner.style.height = "95%";
            comp_menu_inner.style.fontSize = "1.6vh";
            comp_menu_inner.style.opacity = 0;
            comp_menu_inner.id = "comp_menu_inner";

            var components = [];
            for(let i=0; i<machine_data.components.length; i++){
                var new_comp ={"component_name": machine_data.components[i].component_name,
                                    "colour": machine_data.components[i].colour,
                                    "c_index": i}
                components.push(new_comp);
            }

            // get thresholds (all)
            var thresh_metrics = {};
            if(metric_type == "lcms"){
                var thresh_metrics = machine_data.run_data[run_index].summary;
            }
            
            // get thresholds (display metric)
            var thresh_comp = {};
            for(let t in thresh_metrics){
                if(metrics_obj_prot[t] == metrics_obj_prot[display_metric]){
                    thresh_comp = thresh_metrics[t];
                }
            }
            
            /* menu  */
            var menu_div = document.createElement("div");
            menu_div.style.position = "absolute";
            menu_div.style.width = "97.5%";
            //menu_div.style.height = "100%";
            menu_div.style.borderTopRightRadius = "0em";
            menu_div.style.borderBottomRightRadius = "0em";
            menu_div.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            menu_div.style.top = 0;
            menu_div.style.right = 0;
            menu_div.id = "compMenu";
            //menu_div.className = "text-center lightTheme";
            //menu_div.style.backgroundColor = "whitesmoke";
            //menu_div.style.overflow = "auto";
            if(theme == "dark"){menu_div.className = "text-center darkTheme Theme";}
            else{menu_div.className = "text-center lightTheme Theme";}

            // title
            var new_pos_title = document.createElement("p");
            //new_pos_title.style.fontSize = "1vw";
            new_pos_title.style.color = "white";
            new_pos_title.style.backgroundColor = "var(--dark)";
            new_pos_title.className = "menuBorder2 text-center";
            new_pos_title.style.width = "95%";
            new_pos_title.style.fontWeight = 700;
            new_pos_title.innerHTML = "PEPTIDES";
            menu_div.append(new_pos_title);

            // append to DOM before SVG menu
            comp_menu_inner.append(menu_div);
            comp_menu_div.append(comp_menu_inner);

            createSVGMenu(menu_div.id, components, "positive", thresh_comp);

            // add select all
            var new_label = document.createElement("label");
            new_label.className = "container control text-center";
            new_label.id = "pos_sa";
            new_label.setAttribute("data-c-index", -1);
            new_label.innerHTML = "SELECT ALL";
            new_label.addEventListener("click", clickSelectAll);
            new_label.style.borderRadius = "1em";
            new_label.style.width = "60%";
            new_label.style.padding = "0.1em";
            new_label.style.marginLeft = "auto";
            new_label.style.marginRight = "auto";
            new_label.style.backgroundColor = "var(--dark)";
            new_label.style.color = "var(--white)";
            //new_label.style.borderTop = "0.2em solid var(--info)";
            //new_label.style.borderRight = "0.2em solid var(--info)";
            new_label.style.border = "0.2em solid var(--info)";
            menu_div.append(new_label);

            // update checked components
            d3.selectAll(".menuCircle")
            .style("fill", function(d, i){
                if(checked_components[d.component_name]){
                    return d.colour;//"url(#circleGradLight"+d.c_index+")";
                }
                else{
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                }
            });

           // transition on load
           var t = d3.transition().duration(1500);
            if(transition){
                d3.select("#comp_menu_inner").transition(t).style("opacity", 1);
            }
            else{
                d3.select("#comp_menu_inner").style("opacity", 1);
            }

            // transition new threshold icons
            d3.selectAll(".new_icon").transition(t).duration(500).style("opacity", 1);
        }

        function draw_chromatogram(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_cgram");
            var cgram_header = document.getElementById("cgram_header");
            var cgram_inner = document.getElementById("cgram_inner");
            var cgram_metric_header = document.getElementById("cgram_metric_header");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot
            var margin = {top: v_height_unit, right: 0, bottom: 4*v_height_unit, left: 4*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // set metric header
            cgram_metric_header.innerHTML = machine_data.components[comp_index].component_name;
            
            // get chromatogram data (comp, run)
            var cgram = machine_data.components[comp_index].chromatograms[run_index];
           
            // no cgram overlay
            if(cgram.length == 0){
                // remove any elements in plot area
                while (plot_area.firstChild) {
                    plot_area.removeChild(plot_area.firstChild);
                }
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Chromatogram Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_cgram").transition(t).style("opacity", 0.5);
                // update chrom tool
                if(chromModal){
                    d3.select("#chromTool").html(createToolHTML());
                    document.getElementById("chromClose").addEventListener("click", closeChromModal);
                    addWarningIcon();
                }
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
                plot_area.style.opacity = 1;
            }

            var maxY = d3.max(cgram, (d) => d.y);

            // y-scale
            var yScale = d3.scaleLinear()
            .domain([0, maxY + maxY/10])
            .range([height, 0]);

            // x scale
            var currentRT = machine_data.components[comp_index]["lcms_metrics"]["Retention Time"]["values"][run_index];
            xScale_chrom = d3.scaleLinear()
            .domain([currentRT - 1, currentRT + 1])
            .range([0, width]);
            

            // area under curve
            var area = d3.area().curve(d3.curveLinear)
                        .x(function(d) {return xScale_chrom(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);});

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // margins

            // append the svg object to the plot area
            var svg = d3.select("#plot_cgram")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFill = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'chromFill')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFill.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '50%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'skyblue')
            .style('stop-opacity', 1);

            // background
            svg.
            append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("id", "backChrom")
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // x-scale
           
            // y-scale
          
            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale_chrom).tickSize(v_height_unit/2).ticks(5).tickSizeOuter(0);

            // grid x 
            var xAxisGrid = d3.axisBottom().scale(xScale_chrom)
            .tickSize(-height).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);

            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale)
            .tickSize(v_height_unit/2).tickSizeOuter(0).tickFormat(function(d){
                return (d/1000000) + " M";
            });

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid y call
            svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("text-anchor", "middle")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("MINUTES");

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("INTENSITY");
            
            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip2") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // Add brushing
            var brush = d3.brushX()                   
                .extent([[0,0], [width,height]]) 
                .on("end", updateChart);
            
            // Create the line variable: both the line and the brush take place
            var line = svg.append('g')
            .attr("clip-path", "url(#clip2)");

            // Add the brushing
            line
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // plot the density distribution (area)
            line.append("path")
                .datum(cgram)
                .attr("fill", "url(#chromFill)") //url(#chromFill)
                .attr("fill-opacity", 1)
                .attr("stroke-width", lineWidth/4)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                }) 
                .attr("stroke-opacity", 0.7)
                .attr("class", "chromArea")
                .attr("cursor", "pointer")
                //.attr("filter", "url(#specular)")
                .attr("d", area)
                .on("mouseover", function(event){
                    
                    // return if modal mode
                    if(chromModal){return;}
                    
                    var tooltip = d3.select("#chromTool");

                    // display tooltip
                    tooltip.html(createToolHTML());
                    addWarningIcon();
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    if(chromModal){return;}
                    d3.select("#chromTool").style("visibility", "hidden");
                })
                .on("click", function(event, d){

                    var tooltip = d3.select("#chromTool");
                    // close if open
                    if(chromModal){
                        closeChromModal();
                        return;
                    }

                    // display tooltip
                    chromModal = true;
                    tooltip.html(createToolHTML());
                    document.getElementById("chromClose").addEventListener("click", closeChromModal);
                    addWarningIcon();
                    tooltip.style('left', (event.pageX) + 'px');
                    tooltip.style('top', (event.pageY) + 'px');
                    tooltip.style("visibility", "visible");
                });

            // y-axis calls
            svg.append("g")
                .call(y_axis)
                //.style('stroke-width', '0.4vh')
                .style('font-size', '1.2vh')
                .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + (height) + ")") 
            .call(x_axis)
            //.style('stroke-width', '0.4vh')
            .style('font-size', '1.2vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            function closeChromModal(){
                var tooltip = d3.select("#chromTool");
                tooltip.style("visibility", "hidden");
                chromModal = false;
            }

            function addWarningIcon(){
                
                // all metrics
                var metrics = machine_data.components[comp_index].lcms_metrics;
                
                // get thresholds (all)
                var thresh_metrics = machine_data.run_data[run_index].summary;
                
                // get thresholds (display metric)
                var thresh_comp = {};
                for(let t in thresh_metrics){
                    thresh_comp = thresh_metrics[t];
                }

                // convert for look-up
                thresh_metrics = Object.keys(thresh_metrics).map(key => metrics_obj_prot[key]);

                // add breach marker
                var preID = 0;
                for(let metric in metrics){
                    if(thresh_metrics.includes(metric)){
                        if(machine_data.components[comp_index].component_name in thresh_comp){
                            
                            var new_marker = document.createElement("span");
                            new_marker.style.padding = 0;
                            new_marker.className = "fas fa-exclamation-triangle text-danger new_icon";
                            document.getElementById("chromPre"+preID).append(new_marker);
                        }
                    }
                    preID += 1;
                }
            }

            function createToolHTML(){

                // get component details
                var comp_name = machine_data.components[comp_index].component_name;
                var comp_colour = machine_data.components[comp_index].colour;
                var metrics = machine_data.components[comp_index].lcms_metrics;

                if(!(checked_components[comp_name])){
                    var fill_colour = "var(--dark)";
                }
                else{
                    var fill_colour = comp_colour; //'url(#circleGradLight' + comp_index + ')';
                }

                // create tooltip content (circle)
                var tooltipHTML = "<svg width=" + 4*currentRadius + " height=" + 4*currentRadius + ">";
                tooltipHTML += "<circle r=" + currentRadius + " cx=" + 2*currentRadius + " cy=" + 2*currentRadius +
                                " filter = 'url(#specular)'" + " fill=" + fill_colour + " stroke=" + fill_colour +  " stroke-opacity='0.5' stroke-width=" + lineWidth/2 + "></svg>"
                
                // create tooltip content (metrics)
                var preID = 0;
                for(let metric in metrics){
                    var missing = metrics[metric].missing;
                    if(missing.includes(run_index)){
                        var value = "NO VALUE";
                    }
                    else{
                        var value = metrics[metric].values[run_index].toFixed(2);
                    }

                    var new_html = "<pre id=chromPre" + preID +  "><strong> " + metric + " " + "</strong><i>" + value + "</i></pre>";
                        tooltipHTML += new_html;

                    preID += 1;
                }

                // add close button
                if(chromModal){
                    var spanHTML = "<span id='chromClose' class='fas fa-window-close closeButton'></span>";
                    tooltipHTML += spanHTML;
                }
                return "<strong>" + comp_name + "</strong></br>" + tooltipHTML;
            }

            
            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateChart(event) {

                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    xScale_chrom.domain([xScale_chrom.invert(extent[0]), xScale_chrom.invert(extent[1])])
                    line.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                
                // Update axis and line position
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.chromArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area);
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                xScale_chrom.domain([d3.min(cgram, d=>d.x), d3.max(cgram, d=>d.x)]);
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.chromArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area);
            });
           
            // add transition
            if(transition){
                d3.select("#plot_cgram").style("opacity", 0).transition().duration(1000).style("opacity", 1);
            }

            // update chrom tool
            if(chromModal){
                d3.select("#chromTool").html(createToolHTML());
                document.getElementById("chromClose").addEventListener("click", closeChromModal);
                addWarningIcon();
            }
        }
        
        function update_pressure_profile_loading(){
            
            
            var profile = machine_data.run_data[run_index].pressure_profile_lp;
            //var back_profile = machine_data.run_data[run_index].pressure_profile_np;
            

            if(Object.keys(profile).length == 0){
                draw_pressure_profile(true);

                // draw back panel
                pressure_type = "nano";
                draw_pressure_profile(false);
                return;
            }

            // get values to plot..
            var y_values = profile.intensities;
            var x_values_deltas = profile.rts;

            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }
            
            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // area under curve
            if(pressure_type == "loading"){
                var area = d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_load(d.x);})
                        .y0(profileHeight)
                        .y1(function(d) { return yScale_pressure_load(d.y);});
            }
            else{
                var area = d3.area().curve(d3.curveMonotoneX)
                    .x(function(d) {return xScale_pressure_nano(d.x);})
                    .y0(profileHeight)
                    .y1(function(d) { return yScale_pressure_nano(d.y);});
            }

            // reset y scales and transition y -axis
            // transition needs fixing, logic due to draing back and front
            // y-scale (nano)
            if(pressure_type == "nano"){
                
                yScale_pressure_nano = d3.scaleLinear()
                .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                .range([profileHeight, 0]);

                //y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale_pressure_nano).tickSize(v_height_unit/2);
                //d3.select("#pressureY").transition().duration(1000).call(y_axis_pressure);
                
            }

            // y-scale (loading)
            if(pressure_type == "loading"){
                
                yScale_pressure_load = d3.scaleLinear()
                .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                .range([profileHeight, 0]);

                //y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale_pressure_load).tickSize(v_height_unit/2);
                //d3.select("#pressureY").transition().duration(1000).call(y_axis_pressure);
                
            }
            
            // redraw
            if(pressure_type == "loading"){
                d3.selectAll(".pressureLoad")
                .datum(data)
                .transition().duration(1000)
                .attr('d', area);
            }
            else{
                d3.selectAll(".pressureNano")
                .datum(data)
                .transition().duration(1000)
                .attr('d', area);
            }

            // draw back panel
            pressure_type = "nano";
            draw_pressure_profile(false);

        }

        function update_pressure_profile_nano(){
            
            
            var profile = machine_data.run_data[run_index].pressure_profile_np;
            //var back_profile = machine_data.run_data[run_index].pressure_profile_np;
            

            if(Object.keys(profile).length == 0){
                draw_pressure_profile(true);

                // draw back panel
                pressure_type = "loading";
                draw_pressure_profile(false);
                return;
            }

            // get values to plot..
            var y_values = profile.intensities;
            var x_values_deltas = profile.rts;

            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }
            
            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // area under curve
            if(pressure_type == "loading"){
                var area = d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_load(d.x);})
                        .y0(profileHeight)
                        .y1(function(d) { return yScale_pressure_load(d.y);});
            }
            else{
                var area = d3.area().curve(d3.curveMonotoneX)
                    .x(function(d) {return xScale_pressure_nano(d.x);})
                    .y0(profileHeight)
                    .y1(function(d) { return yScale_pressure_nano(d.y);});
            }

            // reset y scales and transition y -axis
            // transition needs fixing, logic due to draing back and front
            // y-scale (nano)
            if(pressure_type == "nano"){
                
                yScale_pressure_nano = d3.scaleLinear()
                .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                .range([profileHeight, 0]);

                //y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale_pressure_nano).tickSize(v_height_unit/2);
                //d3.select("#pressureY").transition().duration(1000).call(y_axis_pressure);
                
            }

            // y-scale (loading)
            if(pressure_type == "loading"){
                
                yScale_pressure_load = d3.scaleLinear()
                .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                .range([profileHeight, 0]);

                //y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale_pressure_load).tickSize(v_height_unit/2);
                //d3.select("#pressureY").transition().duration(1000).call(y_axis_pressure);
                
            }
            
            // redraw
            if(pressure_type == "loading"){
                d3.selectAll(".pressureLoad")
                .datum(data)
                .transition().duration(1000)
                .attr('d', area);
            }
            else{
                d3.selectAll(".pressureNano")
                .datum(data)
                .transition().duration(1000)
                .attr('d', area);
            }

            // draw back panel
            pressure_type = "loading";
            draw_pressure_profile(false);

        }
        
        function draw_pressure_profile(transition){
            
            // get width and height of plot area
            if(pressure_type == "loading"){
                var plot_area = document.getElementById("plot_pressure");
            }
            else{
                var plot_area = document.getElementById("plot_pressure_back");
            }
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;
            
        
            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // no profiles overlay
            if(pressure_type == "loading"){
                var profile = machine_data.run_data[run_index].pressure_profile_lp;
            }
            else{
                var profile = machine_data.run_data[run_index].pressure_profile_np;
            }

            if(Object.keys(profile).length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Pressure Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                new_display.id = "pressure_overlay";
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                if(pressure_type == "loading"){
                    d3.select("#plot_pressure").transition(t).style("opacity", 0.5);
                }
                else{
                    d3.select("#plot_pressure_back").transition(t).style("opacity", 0.5);
                }
                // update pressure tool
                if(pressureModal){
                    d3.select("#pressureTool").html(createToolHTMLPressure());
                    document.getElementById("pressureClose").addEventListener("click", closePressureModal);
                }
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
                if(pressure_type == "loading"){
                    d3.select("#plot_pressure").transition(t).style("opacity", 1);
                }
                else{
                    d3.select("#plot_pressure_back").transition(t).style("opacity", 1);
                }
            }

            // get values to plot
            var y_values = profile.intensities;
            var x_values_deltas = profile.rts;

            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }
            
            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // set the dimensions and margins of the plot
            var margin = {top: v_height_unit, right: v_height_unit, bottom: 4*v_height_unit, left: 3*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            profileHeight = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            if(pressure_type == "loading"){
                var svg = d3.select("#plot_pressure")
                .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

                // background
                svg.
                append("rect")
                    .attr("id", "backPressure")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("class", function(){
                        if(theme == "dark"){return "darkTheme";}
                        return "lightTheme";
                    })
                    .attr("x",0)
                    .attr("y",0);
            }
            else{
                var svg = d3.select("#plot_pressure_back")
                .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

                // background
                svg.
                append("rect")
                    .attr("id", "backPressureBack")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("class", function(){
                        if(theme == "dark"){return "darkTheme";}
                        return "lightTheme";
                    })
                    .attr("x",0)
                    .attr("y",0);
            }

            // gradient fill
            var gradFill = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'pressureFill')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFill.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '50%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'skyblue')
            .style('stop-opacity', 1);

            // x scale 
            // need 2 scales for both pressure profiles
            if(pressure_type == "loading"){
                if(xScale_pressure_load == null){
                    xScale_pressure_load = d3.scaleLinear()
                    .domain([0, d3.max(x_values)])
                    .range([0, width]);
                }
            }

            if(pressure_type == "nano"){
                if(xScale_pressure_nano == null){
                    xScale_pressure_nano = d3.scaleLinear()
                    .domain([0, d3.max(x_values)])
                    .range([0, width]);
                }
            }
           
            // y-scale (nano)
            if(pressure_type == "nano"){
                if(yScale_pressure_nano == null){
                    yScale_pressure_nano = d3.scaleLinear()
                    .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                    .range([height, 0]);
                }
                var yScale = yScale_pressure_nano;
            }

            // y-scale (loading)
            if(pressure_type == "loading"){
                if(yScale_pressure_load == null){
                    yScale_pressure_load = d3.scaleLinear()
                    .domain([0, d3.max(y_values) + d3.max(y_values)/10])
                    .range([height, 0]);
                }
                var yScale = yScale_pressure_load;
            }
          
            // x-axis function (load)
            if(pressure_type == "loading"){
                var x_axis = d3.axisBottom().ticks(5)
                .scale(xScale_pressure_load).tickSize(v_height_unit/2).tickSizeOuter(0);
            }

            // x-axis function (nano)
            if(pressure_type == "nano"){
                var x_axis = d3.axisBottom().ticks(5)
                .scale(xScale_pressure_nano).tickSize(v_height_unit/2).tickSizeOuter(0);
            }
                

            // grid x 
            // https://stackoverflow.com/questions/13669239/remove-end-ticks-from-d3-js-axis
            if(pressure_type == "loading"){
                var xAxisGrid = d3.axisBottom().scale(xScale_pressure_load)
                .tickSize(-height).tickFormat('').ticks(5).tickSizeOuter(0);
            }

            if(pressure_type == "nano"){
                var xAxisGrid = d3.axisBottom().scale(xScale_pressure_nano)
                .tickSize(-height).tickFormat('').ticks(5).tickSizeOuter(0);
            }

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);
             
            // y-axis
            //if(y_axis_pressure == null){
                y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale).tickSize(v_height_unit/2);
            //}
            //var y_axis = d3.axisLeft().ticks(5).scale(yScale).tickSize(v_height_unit/2);

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid y call
            svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

                
            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 3)
                .text("MINUTES");

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("y", 0 - margin.left - 1)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("BARS");
            

            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            if(pressure_type == "loading"){
                var clip = svg.append("defs").append("svg:clipPath")
                    .attr("id", "clipL") // don't use same id in other charts
                    .append("svg:rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("x",0)
                    .attr("y",0);
            }
            else{
                var clip = svg.append("defs").append("svg:clipPath")
                    .attr("id", "clipN") // don't use same id in other charts
                    .append("svg:rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("x",0)
                    .attr("y",0);
            }

            // Add brushing
            var brush = d3.brushX()                   
                .extent([[0,0], [width,height]]) 
                .on("end", updateChart);

            // Create the line variable: where both the line and the brush take place
            if(pressure_type == "loading"){
                var line = svg.append('g')
                .attr("clip-path", "url(#clipL)");
            }
            else{
                var line = svg.append('g')
                .attr("clip-path", "url(#clipN)");
            }
            
             // Add the brushing
             line
            .append("g")
                .attr("class", "brush")
                .call(brush);

            //draw the profile 
            if(pressure_type == "loading"){
                line.append("path")
                .datum(data)
                .attr("fill", "url(#pressureFill)")
                .attr("class", "pressureArea line pressureLoad") // used to redraw for zoom
                .attr("stroke-width", lineWidth/4)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                }) 
                .attr("stroke-opacity", 1)
                .style("cursor","pointer")
                .on("mouseover", function(event){
                    
                    // return if modal mode
                    if(pressureModal){return;}
                    
                    var tooltip = d3.select("#pressureTool");

                    // display tooltip
                    tooltip.html(createToolHTMLPressure());
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    if(pressureModal){return;}
                    d3.select("#pressureTool").style("visibility", "hidden");
                })
                .on("click", function(event, d){

                    var tooltip = d3.select("#pressureTool");
                    // close if open
                    if(pressureModal){
                        closePressureModal();
                        return;
                    }

                    // display tooltip
                    pressureModal = true;
                    tooltip.html(createToolHTMLPressure());
                    document.getElementById("pressureClose").addEventListener("click", closePressureModal);
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_load(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                    );
            }

            //draw the profile 
            if(pressure_type == "nano"){
                line.append("path")
                .datum(data)
                .attr("fill", "url(#pressureFill)")
                .attr("class", "pressureArea line pressureNano") // used to redraw for zoom
                .attr("stroke-width", lineWidth/4)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                }) 
                .attr("stroke-opacity", 1)
                .style("cursor","pointer")
                .on("mouseover", function(event){
                    
                    // return if modal mode
                    if(pressureModal){return;}
                    
                    var tooltip = d3.select("#pressureTool");

                    // display tooltip
                    tooltip.html(createToolHTMLPressure());
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    if(pressureModal){return;}
                    d3.select("#pressureTool").style("visibility", "hidden");
                })
                .on("click", function(event, d){

                    var tooltip = d3.select("#pressureTool");
                    // close if open
                    if(pressureModal){
                        closePressureModal();
                        return;
                    }

                    // display tooltip
                    pressureModal = true;
                    tooltip.html(createToolHTMLPressure());
                    document.getElementById("pressureClose").addEventListener("click", closePressureModal);
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_nano(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                    );
            }

            // y-axis calls
            svg.append("g")
                .call(y_axis_pressure)
                .style('font-size', '1.2vh')
                .attr('id', 'pressureY')
                .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            // x-axis call
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + (height-1) + ")")
            .call(x_axis)
            .style('font-size', '1.2vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

        function closePressureModal(){
            var tooltip = d3.select("#pressureTool");
            tooltip.style("visibility", "hidden");
            pressureModal = false;
        }

        function createToolHTMLPressure(){

            var metrics = machine_data.pressure_metrics;
            if(pressure_type == "loading"){
                var descr = "loading pump";
            }
            else if (pressure_type == "nano"){
                var descr = "nano pump";
            }

            // create tooltip content (metrics)
            var tooltipHTML = "";
            for(let metric in metrics){
                if(machine_data.pressure_metrics[metric].metric_description == descr){
                    var missing = metrics[metric].missing;
                    if(missing.includes(run_index)){
                        var value = "NO VALUE";
                    }
                    else{
                        var value = metrics[metric].values[run_index].toFixed(2);
                    }

                    var new_html = "<pre><strong> " + metrics[metric]["display_name"] + " " + "</strong><i>" + value + "</i></pre>";
                        tooltipHTML += new_html;
                }
            }

            // add close button
            if(pressureModal){
                var spanHTML = "<span id='pressureClose' class='fas fa-window-close closeButton'></span>";
                tooltipHTML += spanHTML;
            }
            return "<strong>" + pressure_type.toUpperCase() + " PUMP</strong></br>" + tooltipHTML;
        }

            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateChart(event) {

                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    if(pressure_type == "loading"){
                        xScale_pressure_load.domain([xScale_pressure_load.invert(extent[0]), xScale_pressure_load.invert(extent[1])]);
                    }
                    else{
                        xScale_pressure_nano.domain([xScale_pressure_nano.invert(extent[0]), xScale_pressure_nano.invert(extent[1])]);
                    }
                    line.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                
                // Update axis and line position
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                if(pressure_type == "loading"){
                    line
                    .select('.line')
                    .transition()
                    .duration(1000)
                    .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_load(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                        );
                }

                if(pressure_type == "nano"){
                    line
                    .select('.line')
                    .transition()
                    .duration(1000)
                    .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_nano(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                        );
                }
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                if(pressure_type == "loading"){
                    xScale_pressure_load.domain([d3.min(x_values), d3.max(x_values)]);
                }
                else{
                    xScale_pressure_nano.domain([d3.min(x_values), d3.max(x_values)]);
                }
                
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                if(pressure_type == "loading"){
                    line
                    .select('.line')
                    .transition()
                    .duration(1000)
                    .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_nano(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                            );
                }
                else{
                    line
                    .select('.line')
                    .transition()
                    .duration(1000)
                    .attr("d", d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale_pressure_load(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);})
                            );
                }
            });

            // update pressure tool
            if(pressureModal){
                d3.select("#pressureTool").html(createToolHTMLPressure());
                document.getElementById("pressureClose").addEventListener("click", closePressureModal);
            }
           
            // add transition
            if(transition == true){
                svg.style("opacity", 0).transition().duration(1000).style("opacity", 1);
            }
        }

        function create_header_display(){
            var header_container = document.getElementById("header");
            
            // div for content
            var header_inner = document.createElement("div");
            header_inner.style.position = "absolute";
            header_inner.style.left = "0%";
            header_inner.style.top = "2.5%"; 
            header_inner.style.width = "100%";
            header_inner.style.height = "95%";
            header_inner.style.opacity = 0;
            header_inner.style.borderRadius = "0em";
            header_inner.style.borderTop = "1.5vh solid white";
            header_inner.style.borderBottom = "1.5vh solid white";
            header_inner.style.backgroundColor = "var(--dark)";
            header_inner.style.color = "white";
            header_inner.className = "chartBorder";
            //header_inner.style.boxShadow = "1vh 1vh 0.5vh var(--gray)";
            header_inner.style.fontSize = "2.1vh";
            header_inner.id = "header_inner";
            //header_inner.style.overflow = "auto";

            // div for name and dropdown
            var instrument_div = document.createElement("div");
            instrument_div.className = "text-center";

            // machine name
            var new_machine_name = document.createElement("p");
            new_machine_name.style.fontSize = "1.5em";
            new_machine_name.style.fontWeight = "bold";
            new_machine_name.style.display = "inline-block";
            //new_machine_name.style.color = "var(--dark)";
            new_machine_name.innerHTML = machine_data.machine_details.machine_name;
            new_machine_name.className = "text-center";

            // instrument menu
            var menu_drop_div = document.createElement("div");
            menu_drop_div.setAttribute("aria-labelledby", "navbarDropdown");
            menu_drop_div.className = "dropdown-menu";
            menu_drop_div.id = "navbar-machines";
            
            var new_link = document.createElement("a");
            new_link.id = "navbarDropdown";
            new_link.className = "nav-link menu";
            new_link.style.display = "inline-block";
            new_link.style.marginLeft = "1em";
            new_link.setAttribute("data-toggle", "dropdown");
            new_link.setAttribute("href", "#");
            new_link.setAttribute("role", "button");
            new_link.setAttribute("aria-haspopup", "true");
            new_link.setAttribute("aria-expanded", "false");

            var new_icon_menu = document.createElement("span");
            new_icon_menu.className = "fas fa-angle-down";
            new_icon_menu.style.color = "whitesmoke";

            new_link.append(new_icon_menu);
            instrument_div.append(new_machine_name);
            instrument_div.append(new_link);
            instrument_div.append(menu_drop_div);

            // machine type
            var new_machine_type = document.createElement("p");
            new_machine_type.style.fontSize = "0.7em";
            new_machine_type.style.fontStyle = "italic";
            //new_machine_type.style.color = "var(--dark)";
            new_machine_type.innerHTML = machine_types[machine_data.machine_details.machine_type];
            new_machine_type.className = "text-center";

            // experiment
            let new_experiment = document.createElement("p");
            new_experiment.style.fontSize = "1em";
            new_experiment.innerHTML = machine_data.machine_details.experiment.toUpperCase();
            // add border to metab machines
            //new_experiment.style.backgroundColor = "lightgray";
            //new_experiment.style.color = "var(--dark)"
            new_experiment.style.width = "50%";
            //new_experiment.style.border = "0.3em double var(--dark)";
            new_experiment.style.marginRight = "auto";
            new_experiment.style.marginLeft = "auto";
            new_experiment.className = "text-center";
            
            // icon
            try{
                var summary_size = Object.keys(machine_data["run_data"][0].summary).length;}
            catch{
                var summary_size = 0;
            }
            let new_icon = document.createElement("span");
            //new_icon.style.margin = "0px";
            new_icon.style.padding = "0px";
            new_icon.style.fontSize = "1.5em";
            new_icon.id = "icon";
            new_icon.style.marginRight = "auto";
            new_icon.style.marginLeft = "auto";

            if(summary_size > 0){
                    new_icon.className = "fas fa-exclamation-triangle text-danger text-center";
                }
                else{
                    new_icon.className = "fas fa-check text-success text-center";
            }

            // icon div (for centering)
            var new_icon_div = document.createElement("div");
            new_icon_div.className = "text-center";
            new_icon_div.append(new_icon);
            
            // container for time duration and controls
            var new_container = document.createElement("div");
            new_container.style.width = "60%";
            new_container.style.marginRight = "auto";
            new_container.style.marginLeft = "auto";

            // left control
            var left_control = document.createElement("span");
            left_control.className = "fas fa-chevron-circle-left control";
            left_control.style.padding = "0px";
            left_control.style.float = "left";
            left_control.style.color = "white";
            left_control.id = "left-control";

            // button for left control
            var left_button = document.createElement("button");
            left_button.className = "btn";
            left_button.style.padding = "0px";
            left_button.style.fontSize = "1.5em";
            left_button.style.paddingLeft = "0.5em";
            left_button.style.float = "left";
            left_button.addEventListener("click", controlUpdate);
            left_button.append(left_control);

            // right control
            var right_control = document.createElement("span");
            right_control.className = "fas fa-chevron-circle-right";
            right_control.style.padding = "0px";
            right_control.style.float = "right";
            right_control.style.color = "white";
            right_control.id = "right-control";

            // button for right control
            var right_button = document.createElement("button");
            right_button.className = "btn";
            right_button.style.padding = "0px";
            right_button.style.fontSize = "1.5em";
            right_button.style.marginRight = "0.5em";
            right_button.style.float = "right";
            right_button.setAttribute("disabled", true); // add class outline class when enable
            right_button.addEventListener("click", controlUpdate);
            right_button.append(right_control);

            // add double arrow for latest
            var new_double = document.createElement("span");
            new_double.className = "fas fa-angle-double-right";
            new_double.style.padding = "0px";
            new_double.style.float = "right";
            new_double.style.display = "none";
            new_double.style.color = "white";
            new_double.id = "double";

            // button for double arrow
            var double_button = document.createElement("button");
            double_button.className = "btn";
            double_button.style.padding = "0px";
            double_button.style.fontSize = "1.5em";
            double_button.style.float = "right";
            double_button.addEventListener("click", controlDouble);
            double_button.append(new_double);

            // days since
            var new_date = machine_data.run_data[0].date_time;
            var days_since = diff_days(new_date);
            var new_duration = document.createElement("p");
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            new_duration.className = "text-center";
            new_duration.style.display = "inline_block";
            new_duration.style.fontWeight = "bold";
            new_duration.innerHTML = display_str;
            new_duration.id = "duration";

            // add to container
            //new_container.append(left_button);
            //new_container.append(double_button);
            //new_container.append(right_button);
            new_container.append(new_duration);

            // container for date and controls
            var new_container_date = document.createElement("div");
            new_container_date.style.width = "60%";
            new_container_date.style.marginRight = "auto";
            new_container_date.style.marginLeft = "auto";

            // date
            var new_date_tag = document.createElement("p");
            new_date_tag.innerHTML = new_date.toDateString();
            new_date_tag.className = "text-center";
            new_date_tag.style.width = "50%";
            new_date_tag.style.marginLeft = "auto";
            new_date_tag.style.marginRight = "auto";
            new_date_tag.style.borderTop = "0.3vh solid var(--white)";
            new_date_tag.style.borderBottom = "0.3vh solid var(--white)";
            new_date_tag.id = "date";

            new_container_date.append(left_button);
            new_container_date.append(double_button);
            new_container_date.append(right_button);
            new_container_date.append(new_date_tag);

            // time
            var new_time_tag = document.createElement("p");
            new_time_tag.style.fontSize = "1em";
            new_time_tag.className = "text-center";
            new_time_tag.innerHTML = get_time(new_date);
            new_time_tag.id = "time";

            // add to DOM
            //header_inner.append(new_machine_name);
            //header_inner.append(new_link);
            header_inner.append(instrument_div);
            header_inner.append(new_experiment);
            header_inner.append(new_machine_type);
            header_inner.append(new_icon_div);
            header_inner.append(new_container);
            header_inner.append(new_container_date);
            //header_inner.append(new_date_tag);
            header_inner.append(new_time_tag);
            //header_inner.append(new_menu);
            //header_inner.append(new_nav);
            //header_inner.append(new_bottom_nav);
            header_container.append(header_inner);

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#header_inner").transition(t).style("opacity", 1);
  
        }

        

        function controlUpdate(el){
            // get all elements
            var icon = document.getElementById("icon");
            var left_control = document.getElementById("left-control"); //the icons
            var right_control = document.getElementById("right-control");
            var duration = document.getElementById("duration");
            var date = document.getElementById("date");
            var time = document.getElementById("time");
            var left_button = left_control.parentElement;
            var right_button = right_control.parentElement;
            var display_container = right_button.parentElement;
            var double_control = document.getElementById("double");
            var double_button = double_control.parentElement;

            if(el != "chart"){
                // run_index
                if(el.currentTarget.firstChild.id == "left-control"){
                    run_index += 1;
                }
                else if(el.currentTarget.firstChild.id == "right-control"){
                    run_index -= 1;
                }
            }

            // update elements
            
            // days since
            var new_date = machine_data.run_data[run_index].date_time;
            var days_since = diff_days(new_date);
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            duration.innerHTML = display_str;

            
            // icon
            try{
                var summary_size = Object.keys(machine_data["run_data"][run_index].summary).length;
                if(summary_size > 0){
                        icon.className = "fas fa-exclamation-triangle text-danger text-center";
                    }
                    else{
                        icon.className = "fas fa-check text-success text-center";
                }
            }
            catch{
                console.log("No summary");
            }
            

            // date
            date.innerHTML = new_date.toDateString();

            // time
            time.innerHTML = get_time(new_date);

            // controls

            // end left
            if(run_index == (machine_data["run_data"].length - 1)){
                left_control.classList.remove("control");
                left_button.setAttribute("disabled", true);
            }
            
            // end right
            if(run_index == 0){
                right_control.classList.remove("control");
                right_button.setAttribute("disabled", true);
            }

            // in between
            if(run_index > 0 && run_index < (machine_data["run_data"].length-1)){
                left_button.removeAttribute("disabled");
                right_button.removeAttribute("disabled");
                if(!right_control.classList.contains("control")){
                    right_control.classList.add("control");
                }
                if(!left_control.classList.contains("control")){
                    left_control.classList.add("control");
                }
            }

            // double arrow
            if(run_index > 1){
                double_control.style.display = "inline";
                double_control.classList.add("control");
            }
            else{
                double_control.style.display = "none";  
                double_control.classList.remove("control");
            }

            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                // update pressure plots (both)

                if(pressure_type == "loading"){
                    update_pressure_profile_loading();

                    // redraw to reset
                    pressure_type = "loading";
                    setTimeout(function(){
                        draw_pressure_profile(false);
                    }, 1000)
                }else{
                    update_pressure_profile_nano();
                    
                    // redraw to reset
                    pressure_type = "nano";
                    setTimeout(function(){
                        draw_pressure_profile(false);
                    }, 1000)
                }
            }
            draw_chromatogram(true);
            
            // update for charts
            if(mainForce){
                // update sim and restart
                var graph = getGraph(forceWidth, forceHeight);
                simulation.force("link").links(graph.links);
                simulation.alpha(0.1).alphaDecay(0.05).restart();
                
                // update circle fill and value (for tween)
                d3.selectAll(".nodes")
                .transition().duration(500)
                .attr("fill", function(d){

                    if(d.nodeType == 2 || d.nodeType == 4){
                        //if(theme == "dark"){return "var(--dark)"}
                        //return "white" ;
                        return "url(#middleCircleFill)";
                    }

                    // update value (in the data)
                    var thisNode = graph.nodes.filter(j => j.metricName == d.metricName && j.name == d.name);
                    if(d.nodeType == 3){
                        d.actualValue = thisNode[0].actualValue;
                    }
                    if(d.nodeType == 1){ // ms2
                        d.value = thisNode[0].value;
                    }

                    // ms2
                    if(d.nodeType == 1){
                        var miss = machine_data.ms2_metrics[d.mIndex].missing;
                        if(miss.includes(run_index)){
                            return "var(--dark)";
                        }else{
                            return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                        } 
                    }

                    // lcms
                    var miss = machine_data.components[d.cIndex].lcms_metrics[d.metricName].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                

                // update warning icons
                d3.selectAll('.icons').transition().duration(500)
                .style("opacity", function(d,i){

                    // only comp nodes
                    if(d.nodeType == 2 || d.nodeType == 4){
                        return 0;
                    }

                    // get thresholds (all) 
                    var thresh_metrics = machine_data.run_data[run_index].summary;
                    
                    // get thresholds per metric
                    var thresh_comp = {};
                    for(let t in thresh_metrics){
                        if(metrics_obj_prot[t] == d.metricName){
                            thresh_comp = thresh_metrics[t];
                        }
                    }

                    // show
                    if(d.name in thresh_comp){
                        return 1
                    }
                    return 0;
                
                });

                // update averages
                d3.selectAll(".averages").filter(e => e.nodeType == 2)
                .transition().duration(800)
                .tween('updateAverages', function(d) {
                    
                    var self = this; // no this in d3 v4 in tween

                    // determine new total
                    var newTotal = 0;
                    var metricNodes = graph.nodes.filter(j => j.metricName == d.metricName && j.nodeType != 2);
                    var count = metricNodes.length; 
                    for(let node in metricNodes){
                        newTotal += metricNodes[node].value;
                    }
                    var newCurrent = (newTotal/count).toFixed(2);
                    

                    // Create an interpolator function
                    let i = d3.interpolate(parseFloat(d.current), parseFloat(newCurrent));

                    // update current
                    d.current = newCurrent;
                    
                    return function(t) {
                        let newAverage = i(t);
                    
                        d3.select(self)
                        .text(newAverage.toFixed(2));
                        
                    };
                });
                
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    moveBoxes(false);
                }
                else if(metric_type == "pressure"){
                    updatePressureCircles();
                }
            } // update for heat maps
            else if(chart_type == "heat"){
                updateHeatMarker();
                if(run_index >= filter){ // marker off screen
                    d3.select("#heatMarker").style("opacity", 0);
                }
                else{
                    d3.select("#heatMarker").style("opacity", 1);
                }
            } // update line chart marker
            else if(chart_type == "line"){
                updateMarker();
                console.log(metric_type);
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_line_chart(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_line(false);
                    }
                    else if(metric_type == "pressure"){
                        draw_pressure_line(false);
                    }
                }, 1000);
            }
            else if(chart_type == "stream"){
                updateMarker();
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_stream_graph(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_stream_graph(false);
                    }
                }, 1000);
            }
            else if(chart_type == "density"){
                draw_density_plots(true);
            }
            else if(chart_type == "parallel"){
                if(metric_type == "lcms"){
                    update_parallel_graph();
                }
                else if(metric_type == "ms2"){
                    update_ms2_parallel_graph();
                }
                
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_parallel_graph(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_parallel_graph(false);
                    }
                    
                }, 1000);
            }

            // update menus
            create_metric_menu(false);
            create_components_menu(false);
        }

        function changeScale(el){

            // only for line and stream
            let chart_types_check = ["line", "stream"];
            if(!(chart_types_check.includes(chart_type))){
                return;
            }

            // change buttons
            var buttons = document.getElementsByName("scale-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            el.target.style.backgroundColor = "white";
            el.target.style.borderColor = "var(--dark)";
            el.target.style.color = "var(--dark)";

            // update line charts
            if(el.target.id == "runsScale"){
                if(scaleType == "runs"){
                    return;
                }
                setRunScale();
                if(metric_type == "lcms"){
                    if(chart_type == "line"){
                        updateChangeScale();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStream();
                    }
                }
                else if(metric_type == "ms2"){
                    if(chart_type == "line"){
                        updateChangeScaleMS2();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStreamMS2();
                    }
                }
                else{
                    if(chart_type == "line"){
                        updateChangeScalePressure();
                    } 
                }
                scaleType = "runs";
            }
            else{
                if(scaleType == "time"){
                    return;
                }
                setTimeScale();
                if(metric_type == "lcms"){
                    if(chart_type == "line"){
                        updateChangeScale();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStream();
                    }
                }
                else if(metric_type == "ms2"){
                    if(chart_type == "line"){
                        updateChangeScaleMS2();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStreamMS2();
                    }
                }
                else{
                    if(chart_type == "line"){
                        updateChangeScalePressure();
                    }
                }
                scaleType = "time";
            }
        }

        function displayRuns(el){

            // only for line and stream
            let chart_types_check = ["line", "stream", "heat"];
            if(!(chart_types_check.includes(chart_type))){
                return;
            }
            
            // change filter
            var new_filter = el.target.innerHTML;
            if(new_filter == "All"){
                filter = machine_data.run_data.length;
            }
            else{
                filter = parseInt(el.target.innerHTML);
            }

            if(filter > machine_data.run_data.length){
                filter = machine_data.run_data.length;
            }

            // change buttons
            var buttons = document.getElementsByName("run-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            el.target.style.backgroundColor = "white";
            el.target.style.borderColor = "var(--dark)";
            el.target.style.color = "var(--dark)";

            // reset scales
            for(let i in machine_data.lcms_metrics){
                //machine_data.lcms_metrics[i].xScale = null;
                machine_data.lcms_metrics[i].yScale = null;
            }

            for(let i in machine_data.pressure_metrics){
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].yScale = null;
            }

            for(let i in machine_data.ms2_metrics){
                //machine_data.ms2_metrics[i].xScale = null;
                machine_data.ms2_metrics[i].yScale = null;
            }

            // redraw lc-ms
            if(metric_type == "lcms"){
                // redraw line charts
                //if(!zoom){
                    //yScale_chart = null;
               // }
                if(chart_type == "line"){
                    lineChartFilterUpdate();
                    setTimeout(function(){
                        draw_line_chart(false);
                    }, 1000);
                    
                }
                else if(chart_type == "heat"){
                    draw_heat_map(false);
                }
                else if(chart_type == "stream"){
                    streamChartFilterUpdate();
                    setTimeout(function(){
                        draw_stream_graph(false);
                    }, 1000);
                }
                
            }
            else if(metric_type == "ms2"){
                // redraw line charts
                //if(!zoom){
                    //yScale_chart = null;
                //}
                if(chart_type == "line"){
                    lineChartFilterUpdate();
                    setTimeout(function(){
                        draw_ms2_line(false);
                    }, 1000);
                }
                else if(chart_type == "stream"){
                    streamChartFilterUpdateMS2();
                    setTimeout(function(){
                        draw_ms2_stream_graph(false);
                    }, 1000);
                }
            }
            else{ // redraw pressure
                if(chart_type == "line"){
                    lineChartFilterUpdate();
                    setTimeout(function(){
                        draw_pressure_line(false);
                    }, 1000);
                }
            }
        }

        function updateHeatMarker(){
            var marker = d3.select("#heatMarker");

            marker
            .transition()
            .duration(500)
            .attr("y1", cell_height*run_index + cell_height/2)
            .attr("y2", cell_height*run_index + cell_height/2);
        }

        function updateMarker(){
            var marker = d3.select("#marker");

            // move marker
            marker
            .transition()
            .duration(1000)
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("x2", xScale_chart(x_values_chart[run_index]));

            // update points
            d3.selectAll(".point")
            .transition()
            .duration(1000)
            .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
            });
            
            // raise current run
            d3.selectAll("#g"+run_index).raise()
            .transition()
            .duration(1000);
            
        }

        function updatePressureCircles(){
            var circles = d3.selectAll("circle");
            var lines = d3.selectAll(".extender");

            // y values and missing indexes
            var data= [];
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var new_obj = machine_data.pressure_metrics[i].stats;
                    new_obj["missing"] = machine_data.pressure_metrics[i].missing;
                    new_obj["current"] = machine_data.pressure_metrics[i].values[run_index];
                    data.push(new_obj);
                    break;
                }
            };

            // move circles
            circles
                .data(data)
                .transition()
                .duration(1000)
                .attr("cx", d => xScale_box(display_metric))
                .attr("cy", function(d){
                    // cap so does not go off chart
                    if(yScale_box(d.current) > box_area_height){
                        return  box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    
                    return yScale_box(d.current)
                })
                .attr("fill", function(d,j){
                    var miss = d.missing;
                    if(miss.includes(run_index)){
                        return "black";
                    }
                    else if(yScale_box(d.current) > box_area_height){
                            return  "var(--info)";
                        }
                    else if(yScale_box(d.current)<0){
                        return "var(--info)";
                    }
                    else{
                        return "whitesmoke";
                    }
                });
            
            // move extenders
            lines
                .data(data)
                .transition()
                .duration(1000)
                .attr("y1", function(d){
                    var y1;
                    if(d.current >= d["75_percent"]){
                        y1 = yScale_box(d.current);
                    }
                    else if(d.current <= d["25_percent"]){
                        y1 = yScale_box(d["25_percent"]);
                    }
                    else{
                        y1 =  yScale_box(d.current);
                    }

                    // cap so does not go off chart
                    if(y1 < 0){
                        return 0;
                    }
                    return y1;
                })
                .attr("y2", function(d){
                    var y2;
                    if(d.current >= d["75_percent"]){
                        y2 = yScale_box(d["75_percent"]);
                    }
                    else if(d.current <= d["25_percent"]){
                        y2 = yScale_box(d.current);
                    }
                    else{
                        y2 = yScale_box(d.current);
                    }
                    // cap so does not go off chart
                    if(y2 > box_area_height){
                        return box_area_height;
                    }
                    return y2;
                });

        }

        function moveBoxes(sort){
            
            // get indexes of checked components
            var component_indexes = getComponentIndexes();

            var all_boxes = [];
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var new_obj = {};
                    new_obj["mean"] = machine_data.components[i].stats[display_metric].mean;
                    new_obj["std"] = machine_data.components[i].stats[display_metric].std;
                    new_obj["min"] = machine_data.components[i].stats[display_metric].min;
                    new_obj["25_percent"] = machine_data.components[i].stats[display_metric]["25_percent"];
                    new_obj["50_percent"] = machine_data.components[i].stats[display_metric]["50_percent"];
                    new_obj["75_percent"] = machine_data.components[i].stats[display_metric]["75_percent"];
                    new_obj["max"] = machine_data.components[i].stats[display_metric].max;
                    new_obj["name"] = machine_data.components[i].component_name;
                    new_obj["current"] = machine_data.components[i].lcms_metrics[display_metric].values[run_index];
                    new_obj["missing"] = machine_data.components[i].lcms_metrics[display_metric].missing;
                    new_obj["colour"] = machine_data.components[i].colour;
                    new_obj["index"] = parseInt(i);
                    all_boxes.push(new_obj);
                }
            }

            /*
            // sort by median
            all_boxes = all_boxes.sort(function(a, b) {
            return a["50_percent"] > b["50_percent"] ? -1 : 1;
            });
        
            // sort polarity (pos first)
            all_boxes = all_boxes.sort(function(a, b){
                return a["mode"] < b["mode"]? -1 : 1;}
                ) ;
            */

            if(sort){
                // sort by current
                all_boxes = all_boxes.sort(function(a, b) {
                return a["current"] > b["current"] ? -1 : 1;
                });

                // names for x scale
                var names = all_boxes.map(function(obj){
                    return obj.name;
                });

                // update xScale
                xScale_box.domain(names);
            }
          
            // move boxes
            d3.selectAll(".box")
            .transition()
            .duration(1000)
            .attr('x', function(d, i){
                return xScale_box(d.name) - box_width/2;
            })
            .attr("y", function(d){return(yScale_box(d["75_percent"]))})
            .attr("height", function(d){
                var check_height = yScale_box(d["25_percent"])-yScale_box(d["75_percent"]);
                if(check_height < 0){
                    return 0;
                }
                return check_height;
            })
            .attr("width", box_width);
            
            
            // move circles
            d3.selectAll(".point")
            .transition()
            .duration(1000)
            .attr("cx", function(d, i){
                return xScale_box(d.name);
            })
            .attr("cy", function(d){
                var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                return yScale_box(newY);
            })
            .attr("fill", function(d,j){
                var miss = all_boxes.filter(e => e.name == d.name)[0].missing;
                var circColor = all_boxes.filter(e => e.name == d.name)[0].colour;
                var c_index = all_boxes.filter(e => e.name == d.name)[0].index;

                if(miss.includes(run_index)){
                    return "var(--dark)";
                }
                else{
                    return circColor; //'url(#circleGradLight'+c_index+')'; 
                }
            });

            // move medians 
            d3.selectAll(".boxline")
            .transition()
            .duration(1000)
            .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
            .attr("y2", function(d){return(yScale_box(d["50_percent"]))});

            // move extenders
            d3.selectAll(".extender")
            .transition()
            .duration(1000)
            .attr("y1", function(d){
                var y1;
                var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                if(newY >= d["75_percent"]){
                    y1 = yScale_box(newY);
                }
                else if(newY <= d["25_percent"]){
                    y1 = yScale_box(d["25_percent"]);
                }
                else{
                    y1 =  yScale_box(newY);
                }
                
                // cap so does not go off chart
                /*
                if(y1 < 0){
                    return 0;
                }
                */
                return y1;
            })
            .attr("y2", function(d){
                var y2;
                var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                if(newY >= d["75_percent"]){
                    y2 = yScale_box(d["75_percent"]);
                }
                else if(d.current <= d["25_percent"]){
                    y2 = yScale_box(newY);
                }
                else{
                    y2 = yScale_box(newY);
                }
                /*
                // cap so does not go off chart
                if(y2 > box_area_height){
                    return box_area_height;
                }
                */
                return y2;
            })
            .attr("x1", function(d){return(xScale_box(d.name))})
            .attr("x2", function(d){return(xScale_box(d.name))})

            // update threshold markers
            var thresholds = getThresholds();
            if(Object.keys(thresholds).length > 0){
        
                d3.select("#thresh_high")
                .transition()
                .duration(1000)
                .attr("y1", yScale_box(thresholds.threshold_high))
                .attr("y2", yScale_box(thresholds.threshold_high));

                d3.select("#thresh_low")
                .transition()
                .duration(1000)
                .attr("y1", yScale_box(thresholds.threshold_low))
                .attr("y2", yScale_box(thresholds.threshold_low));

                d3.select(".topoverlay")
                .transition()
                .duration(1000)
                .attr("height", function(){
                    var check_height = yScale_box(thresholds.threshold_high);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",0);
                
                d3.select(".bottomoverlay")
                .transition()
                .duration(1000)
                .attr("height", function(){
                    var check_height = yScale_box.range()[0] - yScale_box(thresholds.threshold_low);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",yScale_box(thresholds.threshold_low));
                
            }    
    }

        function controlDouble(el){
            // get all elements
            var icon = document.getElementById("icon");
            var left_control = document.getElementById("left-control"); //the icons
            var right_control = document.getElementById("right-control");
            var duration = document.getElementById("duration");
            var date = document.getElementById("date");
            var time = document.getElementById("time");
            var left_button = left_control.parentElement;
            var right_button = right_control.parentElement;
            var display_container = right_button.parentElement;
            var double_control = document.getElementById("double");
            var double_button = double_control.parentElement;

            // set run_index
            run_index = 0;

            // update elements
            
            // days since
            var new_date = machine_data.run_data[run_index].date_time;
            var days_since = diff_days(new_date);
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            duration.innerHTML = display_str;

            // icon
			try{
				var summary_size = Object.keys(machine_data["run_data"][run_index].summary).length;}
			catch{
				var summary_size = 0;
			}

            if(summary_size > 0){
                    icon.className = "fas fa-exclamation-triangle text-danger text-center";
                }
                else{
                    icon.className = "fas fa-check text-success text-center";
            }

            // date
            date.innerHTML = new_date.toDateString();

            // time
            time.innerHTML = get_time(new_date);

            // controls
            right_control.classList.remove("control");
            right_button.setAttribute("disabled", true);
            double_control.style.display = "none";  
            double_control.classList.remove("control");
            left_button.removeAttribute("disabled");

            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                // update pressure plots (both)
                if(pressure_type == "loading"){
                    update_pressure_profile_loading();
                    
                    // redraw to reset
                    pressure_type = "loading";
                    setTimeout(function(){
                        draw_pressure_profile(false);
                    }, 1000)
                }else{
                    update_pressure_profile_nano();
                    
                    // redraw to reset
                    pressure_type = "nano";
                    setTimeout(function(){
                        draw_pressure_profile(false);
                    }, 1000)
                }
            }

            // update chromatogram
            draw_chromatogram(true);

            if(mainForce){
                // update sim and restart
                var graph = getGraph(forceWidth, forceHeight);
                simulation.force("link").links(graph.links);
                simulation.alpha(0.1).alphaDecay(0.05).restart();

                // update circle fill and value (for tween)
                d3.selectAll(".nodes")
                .transition().duration(500)
                .attr("fill", function(d){

                    if(d.nodeType == 2 || d.nodeType == 4){
                        //if(theme == "dark"){return "var(--dark)"}
                        //return "white" ;
                        return "url(#middleCircleFill)";
                    }

                    // update value (in the data)
                    var thisNode = graph.nodes.filter(j => j.metricName == d.metricName && j.name == d.name);
                    if(d.nodeType == 3){
                        d.actualValue = thisNode[0].actualValue;
                    }
                    if(d.nodeType == 1){ // ms2
                        d.value = thisNode[0].value;
                    }

                    // ms2
                    if(d.nodeType == 1){
                        var miss = machine_data.ms2_metrics[d.mIndex].missing;
                        if(miss.includes(run_index)){
                            return "var(--dark)";
                        }else{
                            return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                        } 
                    }

                    // lcms
                    var miss = machine_data.components[d.cIndex].lcms_metrics[d.metricName].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                

                // update warning icons
                d3.selectAll('.icons').transition().duration(500)
                .style("opacity", function(d,i){

                    // only comp nodes
                    if(d.nodeType == 2 || d.nodeType == 4){
                        return 0;
                    }

                    // get thresholds (all) 
                    var thresh_metrics = machine_data.run_data[run_index].summary;
                    
                    // get thresholds per metric
                    var thresh_comp = {};
                    for(let t in thresh_metrics){
                        if(metrics_obj_prot[t] == d.metricName){
                            thresh_comp = thresh_metrics[t];
                        }
                    }

                    // show
                    if(d.name in thresh_comp){
                        return 1
                    }
                    return 0;
                
                    });

                    // update averages
                    d3.selectAll(".averages").filter(e => e.nodeType == 2)
                    .transition().duration(800)
                    .tween('updateAverages', function(d) {
                        
                        var self = this; // no this in d3 v4 in tween

                        // determine new total
                        var newTotal = 0;
                        var metricNodes = graph.nodes.filter(j => j.metricName == d.metricName && j.nodeType != 2);
                        var count = metricNodes.length; 
                        for(let node in metricNodes){
                            newTotal += metricNodes[node].value;
                        }
                        var newCurrent = (newTotal/count).toFixed(2);
                        

                        // Create an interpolator function
                        let i = d3.interpolate(parseFloat(d.current), parseFloat(newCurrent));

                        // update current
                        d.current = newCurrent;
                        
                        return function(t) {
                            let newAverage = i(t);
                        
                            d3.select(self)
                            .text(newAverage.toFixed(2));
                            
                        };
                    });
                
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    moveBoxes();
                }
                else if(metric_type == "pressure"){
                    updatePressureCircles();
                }
            }
            else if(chart_type == "heat"){
                updateHeatMarker();
                if(run_index >= filter){ // marker off screen
                    d3.select("#heatMarker").style("opacity", 0);
                }
                else{
                    d3.select("#heatMarker").style("opacity", 1);
                }
            }
            else if(chart_type == "line"){
                updateMarker();
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_line_chart(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_line(false);
                    }
                    else if(metric_type == "pressure"){
                        draw_pressure_line(false);
                    }
                }, 1000);
            }
            else if(chart_type == "stream"){
                updateMarker();
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_stream_graph(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_stream_graph(false);
                    }
                }, 1000);
            }
            else if(chart_type == "density"){
                draw_density_plots(true);
            }
            else if(chart_type == "parallel"){
                if(metric_type == "lcms"){
                    update_parallel_graph();
                }
                else if(metric_type == "ms2"){
                    update_ms2_parallel_graph();
                }

                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_parallel_graph(false);
                    }
                    else if(metric_type == "ms2"){
                        draw_ms2_parallel_graph(false);
                    }
                    
                }, 1000);
            }

            // update menus
            create_metric_menu(false);
            create_components_menu(false);
        }

        // resize re-draw svg
        function reSize(){
            xScale_chrom = null;
            xScale_pressure_load = null;
            xScale_pressure_nano = null;
            xScale_chart = null; 
            xScale_runs = null;
            xScale_time = null;
            xScale_par = null;
            xScale_par_ms2 = null;
            

            v_height_unit = window.innerHeight/100;
            v_width_unit = window.innerWidth/100;

            // re-set chart element sizes
            base_radius = 3*v_height_unit/5;
            radius = base_radius; // min for line charts 
            currentRadius = radius*2;
            base_line_width = base_radius/2;
            lineWidth = base_line_width; // min for line charts 

            draw_chromatogram(false);
            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                // update pressure plots (both)
                if(pressure_type == "loading"){
                    draw_pressure_profile(false);
                    pressure_type = "nano";
                    draw_pressure_profile(false);
                    pressure_type = "loading";
                }else{
                    draw_pressure_profile(false);
                    pressure_type = "loading";
                    draw_pressure_profile(false);
                    pressure_type = "nano";
                }
            }

            // set metric scales to null pressure
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].radius = null;
                machine_data.pressure_metrics[i].lineWidth = null;
            }

             // set metric scales to null lcms
             for(let i in machine_data.lcms_metrics){
                machine_data.lcms_metrics[i].yScale = null;
                //machine_data.lcms_metrics[i].xScale = null;
                machine_data.lcms_metrics[i].radius = null;
                machine_data.lcms_metrics[i].lineWidth = null;
            }

            // set metric scales to null ms2
            for(let i in machine_data.ms2_metrics){
                machine_data.ms2_metrics[i].yScale = null;
                //machine_data.ms2_metrics[i].xScale = null;
                machine_data.ms2_metrics[i].radius = null;
                machine_data.ms2_metrics[i].lineWidth = null;
            }

            if(mainForce){
                draw_force_main(false);
            }
            else if(chart_type == "line"){
                if(metric_type == "lcms"){
                    draw_line_chart(false);
                }
                else if(metric_type == "pressure"){
                    draw_pressure_line(false);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_line(false);
                }   
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    draw_box_plot(false);
                }
            }
            else if(chart_type == "heat"){
                draw_heat_map(false);
            }
            else if(chart_type == "stream"){
                if(metric_type == "lcms"){
                    draw_stream_graph(false);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_stream_graph(false);
                }
            }
            else if(chart_type == "parallel"){
                if(metric_type == "lcms"){
                    draw_parallel_graph(false);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_parallel_graph(false);
                }
            }
        }

        // curved line function for parallel chart(from d3 gallery example)
        function path(d) {
                // get all metrics (hard code for order)
                var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                                "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                                "Full Width Half Maximum"];
                return d3.line().curve(d3.curveMonotoneX)(metrics.map(function(p) { return [xScale_par(p), yScales[p](d[p])]; }));
        }

        // curved line function for parallel chart(from d3 gallery example)
        function path_ms2(d) {
                // get all metrics (hard code for order)
            var metrics = ["MS/MS Spectra", "Target PSMs", "Unique Target Peptides",
                            "Target Protein Groups", "Precursor Mass Error"];
            return d3.line().curve(d3.curveMonotoneX)(metrics.map(function(p) { return [xScale_par_ms2(p), yScales_ms2[p](d[p])]; }));
        }

         function update_ms2_parallel_graph(){
            // get all metrics (hard code for order)
            var metrics = ["MS/MS Spectra", "Target PSMs", "Unique Target Peptides",
                            "Target Protein Groups", "Precursor Mass Error"];

            // get and re-draw path data
            var pathData = {};
            for(let j in machine_data.ms2_metrics){
                var new_value = machine_data.ms2_metrics[j].values[run_index];
                pathData[machine_data.ms2_metrics[j].display_name]= new_value;
            }

            d3.selectAll(".lines")
            .datum(pathData)
            .transition().duration(1000)
            .attr("d", path_ms2);

            // get and re-draw circles 
            var circleData = [];
            for(let i in machine_data.ms2_metrics){
                var new_circle = {};
                var new_value = machine_data.ms2_metrics[i].values[run_index];
                new_circle["x"]= machine_data.ms2_metrics[i].display_name;
                new_circle["y"] = new_value;
                new_circle["colour"] = machine_data.ms2_metrics[i].colour;
                circleData.push(new_circle);
            } 

            // swap data and transition
            d3.selectAll(".point")
            .data(circleData)
            .transition()
            .duration(1000)
            .attr("cx", d => xScale_par_ms2(d.x))
            .attr("cy", d => yScales_ms2[d.x](d.y))
            .attr("fill", function(d,i){
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name == d.x){
                        var miss = machine_data.ms2_metrics[i].missing;
                        break;
                    }
                }

                if(miss.includes(run_index)){
                    return "var(--dark)";
                }else{
                    return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                } 
            })
         }

        function update_parallel_graph(){
            
            // update paths

            // get indexes of checked components
            var component_indexes = getComponentIndexes();
            var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                                "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                                "Full Width Half Maximum"];

            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var pathData = {};
                    for(let j in metrics){
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        pathData[metrics[j]]= new_value;
                    }

                    pathData["cIndex"] = i;
                    pathData["colour"] = machine_data.components[i].colour;
                    pathData["name"] = machine_data.components[i].component_name;

                    d3.selectAll(".lines"+i)
                    .datum(pathData)
                    .transition().duration(1000)
                    .attr("d", path);
                }
            }

            // update circles
            for(let j in metrics){
                var circleData = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_circle = {};
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        new_circle["x"]= metrics[j];
                        new_circle["y"] = new_value;
                        new_circle["colour"] = machine_data.components[i].colour;
                        new_circle["name"] = machine_data.components[i].component_name;
                        new_circle["comp"] = i;
                        circleData.push(new_circle);
                    }
                    
                    // order
                    circleData = circleData.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});

                    // swap data and transition
                    d3.selectAll(".point"+j)
                    .data(circleData)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_par(d.x))
                    .attr("cy", d => yScales[d.x](d.y))
                    .attr("fill", function(d,i){
                        var miss = machine_data.components[d.comp].lcms_metrics[d.x].missing;
                        if(miss.includes(run_index)){
                            return "var(--dark)";
                        }else{
                            return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                        } 
                    })
                }
            }
        }



        function draw_parallel_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the graph
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, right: v_width_unit, 
                bottom: chart_bottom.offsetHeight + 2*v_height_unit, left: v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.opacity = 1;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clipPar") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clipPar)")
                .attr("id", "all_lines");

            // get all metrics (hard code for order)
            var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                            "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                            "Full Width Half Maximum"];

            // data structure for expand/contract
            var axesExpand = {"Retention Time":false, "Mass Error (ppm)":false, "Mass Error (mDa)":false,
                            "Area (normalised)":false, "Height (normalised)":false, "Tailing":false, "Asymmetry":false,
                            "Full Width Half Maximum":false};
           

            // get indexes of checked components
            var component_indexes = getComponentIndexes();

            // set scales function
            function setScales(){
                let Scales = {};
                for(let j in metrics){
                    var newScale = d3.scaleLinear()
                            .range([height-currentRadius, currentRadius]);
                            
                    if(metrics[j] == "Mass Error (ppm)"){
                        newScale.domain([-4, 4]);
                    }
                    else if(metrics[j] == "Mass Error (mDa)"){
                        newScale.domain([-3, 3]);
                    }
                    else if(metrics[j]== "Tailing"){
                        newScale.domain([0, 2]);
                    }
                    else if(metrics[j] == "Asymmetry"){
                        newScale.domain([0, 2]);
                    }
                    else if(metrics[j] == "Retention Time"){
                        newScale.domain([0, 50]); // get from processing??
                    }
                    else if(metrics[j] == "Full Width Half Maximum"){
                        newScale.domain([0, 30]);
                    }
                    else if(metrics[j] == "Area (normalised)"){
                        newScale.domain([-3, 3]);
                    }
                    else if(metrics[j] == "Height (normalised)"){
                        newScale.domain([-3, 3]);
                    }
                    Scales[metrics[j]] = newScale;
                }
                return Scales;
            }

            // get scale domain for reset
            function getDomain(metricName){
                if(metricName == "Mass Error (ppm)"){
                        return [-4, 4];
                }
                else if(metricName == "Mass Error (mDa)"){
                    return [-3, 3];
                }
                else if(metricName== "Tailing"){
                    return [0, 2];
                }
                else if(metricName == "Asymmetry"){
                    return [0, 2];
                }
                else if(metricName == "Retention Time"){
                    return [0, 50];
                }
                else if(metricName == "Full Width Half Maximum"){
                    return [0, 30];
                }
                else if(metricName == "Area (normalised)"){
                    return [-3, 3];
                }
                else if(metricName == "Height (normalised)"){
                    return [-3, 3];
                }
            }
            
            if(Object.keys(yScales).length == 0){
                yScales = setScales();
            }

            // update range if controls changed
            var newRange = height - currentRadius;
            for(let i in yScales){
                yScales[i].range([newRange, currentRadius]);
            }

            // find the best position for each Y axis
            if(xScale_par == null){
                xScale_par = d3.scalePoint()
                    .range([0, width])
                    .padding(1)
                    .domain(metrics);
            }

            var midDist = (xScale_par("Asymmetry") - xScale_par("Tailing"))/2;

            // draw the axes
            all_lines.selectAll("myAxis")
            .data(metrics).enter()
            .append("g")
            .attr("transform", function(d) { return "translate(" + xScale_par(d) + ")"; })
            .each(function(d) { d3.select(this).call(d3.axisLeft().tickSize(2*currentRadius).ticks(5).scale(yScales[d])); })
            .attr("class", "parAxes")
            .style("opacity", 0.7)
            .style('font-size', '1.8vh');

            // get and draw path data
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var pathData = {};
                    for(let j in metrics){
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        pathData[metrics[j]]= new_value;
                    }
                    
                    pathData["cIndex"] = i;
                    pathData["colour"] = machine_data.components[i].colour;
                    pathData["name"] = machine_data.components[i].component_name;
                    
                    // draw the line
                    all_lines.append("path")
                    .datum(pathData)
                    .style("fill", function(d){
                        return "none";
                    })
                    .attr("d", path)
                    .attr("class", "lines lines"+i)
                    .style("stroke", d => d.colour)
                    .style("stroke-width", lineWidth)
                    .style("stroke-opacity", 0.5)
                    .on("mouseover", function(event, d){
                        var yRT = machine_data.components[d.cIndex]["lcms_metrics"]["Retention Time"].values[run_index];

                        // add comp name
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", xScale_par("Retention Time") - 4.2*currentRadius)
                        .attr("y", yScales["Retention Time"](yRT) + currentRadius)
                        .attr("text-anchor", "end")
                        .style("font-size", "0.7vw")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .style("text-shadow", "0.1vh 0.1vh gray")
                        .text(d.name);

                        // highlight
                        d3.selectAll(".lines").style("opacity", function(e){
                            if(e.cIndex == d.cIndex){return 1;}
                            return 0.1;
                        });
                        d3.selectAll(".point").style("opacity", function(e){
                            if(e.comp == d.cIndex){return 1;}
                            return 0.1;
                        });
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".lines").style("opacity", 1);
                        d3.selectAll(".point").style("opacity", 1);
                        d3.selectAll(".hover-text").remove();
                    });

                }
            }

            // get and draw circles (metrics first loop for order)
            for(let j in metrics){
                var circleData = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_circle = {};
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        new_circle["x"]= metrics[j];
                        new_circle["y"] = new_value;
                        new_circle["colour"] = machine_data.components[i].colour;
                        new_circle["name"] = machine_data.components[i].component_name;
                        new_circle["comp"] = i;
                        circleData.push(new_circle);
                    }
                    
                }

                // order and draw
                circleData = circleData.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});
                
                // points
                all_lines.append("g")
                .selectAll("circle")
                .data(circleData)
                .join("circle")
                .attr("cx", d => xScale_par(d.x))
                .attr("cy", d => yScales[d.x](d.y))
                .attr("r", currentRadius)
                .attr("class", "point point"+j)
                .attr("filter", "url(#specular)")
                .attr("stroke", d => d.colour)
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", 0.5)
                .attr("cursor", "pointer")
                .attr("fill", function(d,i){
                    var miss = machine_data.components[d.comp].lcms_metrics[d.x].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                .on("click", function(event, d){
        
                    // get values at metric
                    var yValues = [];
                    var metricCircles = d3.selectAll(".point").filter(function(e){
                        if(e.x == d.x){
                            yValues.push(e.y);
                            return e.y;
                        }
                    });

                    if(!axesExpand[d.x]){
                        // change y scale domain (expand)
                        var offsetY = (4*currentRadius/height)*(d3.max(yValues)-d3.min(yValues));
                        yScales[d.x].domain([d3.min(yValues) -offsetY, d3.max(yValues) + offsetY]);
                        axesExpand[d.x] =true;
                    }
                    else{ // contract
                        yScales[d.x].domain(getDomain(d.x));
                        axesExpand[d.x] = false;
                    }

                    // redraw circles
                    d3.selectAll(".point").transition().duration(1000)
                    .attr("cy", d => yScales[d.x](d.y));

                    // redraw lines
                    d3.selectAll(".lines").transition().duration(1000)
                    .attr("d", path);

                    // axis
                    d3.selectAll(".parAxes")
                    .each(function(d) { d3.select(this).transition().duration(1000)
                        .call(d3.axisLeft().tickSize(2*currentRadius).ticks(5).scale(yScales[d])); });
                });
            }

            // add metric names (dont set x and y to rotate, put in translate)
            svg.selectAll("metricnames")
            .data(metrics).enter()
            .append("text")
            .style("text-anchor", "middle")
            //.style("cursor", "pointer")
            .on("click", function(event, d){
                /* removed, need to add logic for button disabled to include
                // change background and update state
                var buttons = document.getElementsByName("chart-buttons");
                for(let i =0; i<buttons.length; i++){
                    if(buttons[i].id == "line"){
                        buttons[i].style.backgroundColor = "white";
                        buttons[i].style.color = "var(--dark)";
                        buttons[i].style.borderColor = "var(--dark)";
                    }else{
                        buttons[i].style.backgroundColor = "var(--dark)";
                        buttons[i].style.color = "white";
                        buttons[i].style.borderColor = "var(--info)";
                    }
                }

                // set stae and draw
                display_metric = d;
                chart_type = "line";
                metric_type = "lcms";
                draw_line_chart(true);

                // chart buttons logic
                if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                    document.getElementById("box").disabled = true;
                }
                else{
                    document.getElementById("box").disabled = false;
                }

                // chart buttons logic
                if(display_metric == "Retention Time" || display_metric == "Full Width Half Maximum"){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("stream").disabled = false;
                }
                else{
                    document.getElementById("heat").disabled = false;
                    //document.getElementById("density").disabled = false;
                    document.getElementById("stream").disabled = false;
                }

                // enable all radios and check
                var radios = document.getElementsByName("radioOptions");
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    radios[i].disabled = false;
                    if(radio_name == display_metric){
                        radios[i].checked = true;
                    }
                }
                */
            })
            .attr("class", "label-metric lineText")
            .attr("transform", function(d) {
                return "translate(" + xScale_par(d) + " " + height/2 + ") rotate(90)";
            })
            .attr("dy", -midDist/2)
            .text(function(d) { return d.toUpperCase(); })
            .attr("fill", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            }).raise();

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "ALL LC-MS METRICS";

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".lines").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".parAxes").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }

        }

        function draw_ms2_parallel_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the graph
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, right: v_width_unit, 
                bottom: chart_bottom.offsetHeight + 2*v_height_unit, left: v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.opacity = 1;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clipPar") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clipPar)")
                .attr("id", "all_lines");

            // get all metrics (hard code for order)
            var metrics = ["MS/MS Spectra", "Target PSMs", "Unique Target Peptides",
                            "Target Protein Groups", "Precursor Mass Error"];
           

            // set scales function
            function setScales(){
                let Scales = {};
                for(let j in machine_data.ms2_metrics){
                    var newScale = d3.scaleLinear()
                            .range([height-currentRadius, currentRadius]);
                            
                    if(machine_data.ms2_metrics[j].display_name == "Precursor Mass Error"){
                        newScale.domain([-9,9])
                    }
                    else{
                        newScale.domain([0, machine_data.ms2_metrics[j].stats.max]);
                    }
                    
                    Scales[machine_data.ms2_metrics[j].display_name] = newScale;
                }
                return Scales;
            }

            // get scale domain for reset
            function getDomain(metricName){
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name == metricName){
                        if(machine_data.ms2_metrics[j].display_name == "Precursor Mass Error"){
                            return [-9,9];
                        }
                        return [0, machine_data.ms2_metrics[j].stats.max];
                    }
                } 
            }
            
            if(Object.keys(yScales_ms2).length == 0){
                yScales_ms2 = setScales();
            }

            // update range if controls changed
            var newRange = height - currentRadius;
            for(let i in yScales_ms2){
                yScales_ms2[i].range([newRange, currentRadius]);
            }

            // find the best position for each Y axis
            if(xScale_par_ms2 == null){
                xScale_par_ms2 = d3.scalePoint()
                    .range([0, width])
                    .padding(1)
                    .domain(metrics);
            }

            var midDist = (xScale_par_ms2("MS/MS Spectra") - xScale_par_ms2("Target PSMs"))/2;

            // draw the axes
            all_lines.selectAll("myAxis")
            .data(metrics).enter()
            .append("g")
            .attr("transform", function(d) { return "translate(" + xScale_par_ms2(d) + ")"; })
            .each(function(d) { d3.select(this).call(d3.axisLeft().tickSize(2*currentRadius).ticks(8).scale(yScales_ms2[d])); })
            .attr("class", "parAxes")
            .style("opacity", 0.7)
            .style('font-size', '1.8vh');

            // get and draw path data
            var pathData = {};
            for(let j in machine_data.ms2_metrics){
                var new_value = machine_data.ms2_metrics[j].values[run_index];
                pathData[machine_data.ms2_metrics[j].display_name]= new_value;
            }
            
            // draw the line
            all_lines.append("path")
            .datum(pathData)
            .style("fill", function(d){
                return "none";
            })
            .attr("d", path_ms2)
            .attr("class", "lines")
            .style("stroke", "gray")
            .style("stroke-width", lineWidth)
            .style("stroke-opacity", 0.5);
            
            // get and draw circles (metrics first loop for order)
            var circleData = [];
            for(let i in machine_data.ms2_metrics){
                var new_circle = {};
                var new_value = machine_data.ms2_metrics[i].values[run_index];
                new_circle["x"]= machine_data.ms2_metrics[i].display_name;
                new_circle["y"] = new_value;
                new_circle["colour"] = machine_data.ms2_metrics[i].colour;
                circleData.push(new_circle);
            } 
                
            // points
            all_lines.append("g")
            .selectAll("circle")
            .data(circleData)
            .join("circle")
            .attr("cx", d => xScale_par_ms2(d.x))
            .attr("cy", d => yScales_ms2[d.x](d.y))
            .attr("r", currentRadius)
            .attr("class", "point")
            .attr("filter", "url(#specular)")
            .attr("stroke", d => d.colour)
            .attr("stroke-width", lineWidth/2)
            .attr("stroke-opacity", 0.5)
            .attr("fill", function(d,i){
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name == d.x){
                        var miss = machine_data.ms2_metrics[i].missing;
                        break;
                    }
                }
                if(miss.includes(run_index)){
                    return "var(--dark)";
                }else{
                    return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                } 
            })
            
            // add metric names (dont set x and y to rotate, put in translate)
            svg.selectAll("metricnames")
            .data(metrics).enter()
            .append("text")
            .style("text-anchor", "middle")
            //.style("cursor", "pointer")
            .on("click", function(event, d){
                 /* removed, need to add logic for button disabled to include
                // change background and update state
                var buttons = document.getElementsByName("chart-buttons");
                for(let i =0; i<buttons.length; i++){
                    if(buttons[i].id == "line"){
                        buttons[i].style.backgroundColor = "white";
                        buttons[i].style.color = "var(--dark)";
                        buttons[i].style.borderColor = "var(--dark)";
                    }else{
                        buttons[i].style.backgroundColor = "var(--dark)";
                        buttons[i].style.color = "white";
                        buttons[i].style.borderColor = "var(--info)";
                    }
                }

                // set state and draw
                display_metric = d;
                chart_type = "line";
                metric_type = "ms2";
                draw_ms2_line(true);

                document.getElementById("box").disabled = true;
                document.getElementById("heat").disabled = true;
                document.getElementById("stream").disabled = false;
                //document.getElementById("density").disabled = false;
               
                // chart buttons logic
                if(display_metric == "Precursor Mass Error"){
                    document.getElementById("stream").disabled = true;
                }

                // enable all radios and check
                var radios = document.getElementsByName("radioOptions");
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    radios[i].disabled = false;
                    if(radio_name == display_metric){
                        radios[i].checked = true;
                    }
                }
                */
            })
            .attr("class", "label-metric lineText")
            .attr("transform", function(d) {
                return "translate(" + xScale_par_ms2(d) + " " + height/2 + ") rotate(90)";
            })
            .attr("dy", midDist/2)
            .text(function(d) { return d.toUpperCase(); })
            .attr("fill", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            }).raise();

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "ALL MS2 METRICS";

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".lines").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".parAxes").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }

        }

        function changeControls(){
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var fromMain = false;
            
            // clicked from force nav
            if(mainForce){
                //mainForce = false;
                fromMain = true;
                // set reset controls
                if(controls){
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                    controls = false;
                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                    controls = true;
                }

                
                // set radios for line chart (enable all) and check radio
                var radios = document.getElementsByName("radioOptions");
                for(let i = 0; i<radios.length; i++){
                    //radios[i].disabled = false;
                    var radio_name = radios[i].labels[0].innerText;
                    if(radio_name == display_metric){
                        radios[i].checked = true;
                    }
                }

                draw_force_main(true);
                
            }
            
            if(!fromMain){
                // swap control state
                if(controls){
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                    controls = false;

                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                    controls = true;

                }
                controlsDraw();
            }
        }

        function controlsDraw(){

            // reset yscales
            yScale_chart = null;
            yScale_pressure = null;
            yScale_ms2 = null;

            for(let i in machine_data.lcms_metrics){
                machine_data.lcms_metrics[i].yScale = null;
            }
            
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
            }

            for(let i in machine_data.ms2_metrics){
                machine_data.ms2_metrics[i].yScale = null;
            }

            if(metric_type == "lcms"){
                // redraw charts after removing controls
                
                if(chart_type == "line"){
                    draw_line_chart(true);
                }
                else if(chart_type == "box"){
                    yScale_box = null;
                    draw_box_plot(true);
                }
                else if(chart_type == "heat"){
                    draw_heat_map(true);
                }
                else if(chart_type == "density"){
                    draw_density_plots(true);
                }
                else if(chart_type == "stream"){
                    draw_stream_graph(true);
                }
                else if(chart_type == "parallel"){
                    draw_parallel_graph(true);
                }
            }
            else if(metric_type == "ms2"){
                if(chart_type == "line"){
                    draw_ms2_line(true);
                }
                else if(chart_type == "density"){
                    draw_density_plots(true);
                }
                else if(chart_type == "stream"){
                    draw_ms2_stream_graph(true);
                }
                else if(chart_type == "parallel"){
                    draw_ms2_parallel_graph(true);
                }
            }
            else{
                draw_pressure_line(true);
            }
        }

        function componentDraw(){
            if(mainForce){
                    var graph = getGraph(forceWidth, forceHeight);
                    //reStartSim(graph);
                    draw_force_main(false);
                    return;
                    //draw_force_main(false);
            }

            if(metric_type == "lcms"){
                // redraw charts after component change
                if(!zoom){
                    yScale_chart = null;
                }
                if(chart_type == "line"){
                    draw_line_chart(false);
                }
                else if(chart_type == "box"){
                    yScale_box = null;
                    draw_box_plot(false);
                }
                else if(chart_type == "heat"){
                    draw_heat_map(false);
                }
                else if(chart_type == "density"){
                    draw_density_plots(false);
                }
                else if(chart_type == "parallel"){
                    draw_parallel_graph(false);
                }   
            }
        }

        function clickSelectAll(event){
            
            d3.selectAll(".positive").transition().duration(300)
            .style("fill", function(d, i){
                // update data structures and change fill
                checked_components[d.component_name] = true;
                if(!(stackKeys.includes(d.component_name))){
                    stackKeys.push(d.component_name);
                }
                return d.colour; //"url(#circleGradLight"+d.c_index+")";
            })
            
            if(chart_type == "stream" && !mainForce){update_stream_graph(false);}
            componentDraw();
        }

        // OLD on click components menu
        function clickComponent(event){
            
            // handle normal behaviour
            if(event.target.hasAttribute("type")){
                if(metric_type == "lcms"){
                    if(!zoom){
                        yScale_chart = null;
                    }
                    if(chart_type == "line"){
                        draw_line_chart(true);
                    }
                    else if(chart_type == "box"){
                        yScale_box = null;
                        draw_box_plot(true);
                    }
                    else if(chart_type == "heat"){
                        draw_heat_map(true);
                    }
                    else if(chart_type == "density"){
                        draw_density_plots(true);
                    }
                    
                }
                checked_components[event.target.labels[0].innerText] = !checked_components[event.target.labels[0].innerText];
                return;
            }

            if(event.target.hasAttribute("data-c-index")){
                // update chromatogram or select one
                data_index = parseInt(event.target.getAttribute("data-c-index"));
                if(data_index != -1){
                    comp_index = data_index; // update comp index
                    // select one
                    if(window.event.shiftKey){ 
                        var pos_checks = document.getElementsByName("positive");

                        for(let i =0; i<pos_checks.length; i++){
                            if(pos_checks[i].labels[0].getAttribute("data-c-index") == data_index){
                                pos_checks[i].checked = true;
                                checked_components[pos_checks[i].labels[0].innerText] = true;
                            }
                            else{
                                pos_checks[i].checked = false;
                                checked_components[pos_checks[i].labels[0].innerText] = false;
                            }
                        }
                        if(metric_type == "lcms"){
                            // redraw line charts
                            if(!zoom){
                                yScale_chart = null;
                            }
                            if(chart_type == "line"){
                                draw_line_chart(true);
                            }
                            else if(chart_type == "box"){
                                yScale_box = null;
                                draw_box_plot(true);
                            }
                            else if(chart_type == "heat"){
                                draw_heat_map(true);
                            }
                            else if(chart_type == "density"){
                                draw_density_plots(true);
                            }
                        }
                        draw_chromatogram(true);
                    }// change chromatogram
                    else{ 
                        xScale_chrom = null;
                        draw_chromatogram(true);
                    }
                    event.preventDefault(); // don't change checkbox
                }
                else{ // select all
                    
                    var pos_checks = document.getElementsByName("positive");
                    for(let i =0; i<pos_checks.length; i++){
                        pos_checks[i].checked = true;
                        checked_components[pos_checks[i].labels[0].innerText] = true;
                    }

                    if(metric_type == "lcms"){
                        // redraw line charts
                        if(!zoom){
                            yScale_chart = null;
                        }
                        if(chart_type == "line"){
                            draw_line_chart(true);
                        }
                        else if(chart_type == "box"){
                            yScale_box = null;
                            draw_box_plot(true);
                        }
                        else if(chart_type == "heat"){
                            draw_heat_map(true);
                        }
                        else if(chart_type == "density"){
                            draw_density_plots(true);
                        }
                    }
                }

                // add and remove click outline
                event.target.style.outline = "0.3em ridge var(--dark)";
                setTimeout(function(){
                    event.target.style.outline = "";
                }, 10);
                }
            }
        

            function create_chart_area(){

                // get container
                var chart_div = document.getElementById("chart");

                // div for content
                var chart_inner = document.createElement("div");
                chart_inner.style.position = "absolute";
                chart_inner.style.left = "0%";
                chart_inner.style.top = "2.5%"; 
                chart_inner.style.width = "97.5%";
                chart_inner.style.height = "95%";
                //chart_inner.style.backgroundColor = "var(--dark)";
                //chart_inner.style.borderRight = "0vh solid var(--dark)";
                chart_inner.style.borderTopLeftRadius = "0em";
                //chart_inner.style.borderBottomLeftRadius = "0em";
                chart_inner.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
                if(theme == "dark"){chart_inner.className = "darkTheme Theme";}
                else{chart_inner.className = "lightTheme Theme";}
                //chart_inner.style.boxShadow = "1vh 1vh 0.5vh var(--gray)";
                chart_inner.style.fontSize = "2vh";
                chart_inner.style.opacity = 0;
                chart_inner.style.overflow = "none";
                chart_inner.id = "chart_inner";

                /**** scale/runs buttons ****/
                // container div
                var new_top_div = document.createElement("div");
                new_top_div.style.height = "8%";
                new_top_div.className = "text-center";
                new_top_div.style.position = "absolute";
                new_top_div.style.left = 0;
                new_top_div.style.top = 0;
                new_top_div.style.display = "block";
                //if(theme == "dark"){new_top_div.style.backgroundColor = "var(--dark)";}
                //else{new_top_div.style.backgroundColor = "lightsmoke"}
                new_top_div.style.backgroundColor = "var(--dark)";
                //new_top_div.style.backgroundColor = "var(--dark)";
                new_top_div.style.width = "100%";
                new_top_div.id = "chart_top";

                // button group
                var button_group = document.createElement("div");
                button_group.className = "btn-group";
                button_group.style.width = "100%";
                button_group.style.height = "100%";

                // buttons

                // METRIC NAME
                var chart_metric_name = document.createElement("p");
                chart_metric_name.id = "chartHeader";
                chart_metric_name.innerHTML = display_metric.toUpperCase();
                chart_metric_name.style.color = "white";
                chart_metric_name.style.fontWeight = "bold";
                chart_metric_name.style.padding = "0.2em";
                chart_metric_name.style.fontSize = "1.2vw";
                chart_metric_name.style.opacity = 0.8;
                chart_metric_name.style.letterSpacing = "0.5vh";
                //chart_metric_name.style.marginLeft = "5vh";
                //chart_metric_name.className = "text-center";

                // MENU icon
                var new_menu = document.createElement("span");
                new_menu.className = "fa fa-bars";
                //new_menu.style.opacity = 0.8;
                new_menu.style.color = "white";
                new_menu.style.cursor = "pointer";
                new_menu.style.marginRight = "3vw";
                new_menu.style.padding = "0.5em";
                new_menu.style.fontSize = "1.2vw";
                new_menu.style.opacity = 0.8;
                new_menu.id = "metric_menu";
                new_menu.setAttribute("data-tooltip", "Click for Metric Menu")
                new_menu.addEventListener("click", showMenu);

                // TIME SCALE
                if(scaleType == "time"){
                    var new_button = ButtonOnChart("TIME SCALE", "scale-buttons", changeScale);
                    new_button.disabled = true;
                    new_button.style.boxShadow = "";
                    new_button.classList = "btn";
                }
                else{
                    var new_button = ButtonOffChart("TIME SCALE", "scale-buttons", changeScale);
                    new_button.style.boxShadow = "";
                    new_button.classList = "btn";
                    new_button.disabled = true;
                }
                new_button.id = "timeScale";
                new_button.style.width = "5vw";
                new_button.style.marginLeft = "1vw";
                button_group.append(new_button);

                // RUNS SCALE
                if(scaleType == "runs"){
                    var new_button = ButtonOnChart("RUNS SCALE", "scale-buttons", changeScale);
                    new_button.style.boxShadow = "";
                    new_button.disabled = true;
                    new_button.classList = "btn";
                }
                else{
                    var new_button = ButtonOffChart("RUNS SCALE", "scale-buttons", changeScale);
                    new_button.style.boxShadow = "";
                    new_button.disabled = true;
                    new_button.classList = "btn";
                }

                new_button.id = "runsScale";
                new_button.style.width = "5vw";
                new_button.style.marginRight = "3vw";
                button_group.append(new_button);

                button_group.append(chart_metric_name);
                button_group.append(new_menu);

                /*  number of runs */
                var new_button = ButtonOnChart("10", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);

                /*  number of runs */
                var new_button = ButtonOffChart("20", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);

                /*  number of runs */
                var new_button = ButtonOffChart("30", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);

                /*  number of runs */
                var new_button = ButtonOffChart("40", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);

                /*  number of runs */
                if(machine_data.run_data.length > 50){
                    var new_button = ButtonOffChart("50", "run-buttons", displayRuns);
                    new_button.disabled = true;
                    new_button.style.boxShadow = "";
                    new_button.classList = "btn";
                    button_group.append(new_button);
                }

                /*  number of runs */
                if(machine_data.run_data.length > 100){
                    var new_button = ButtonOffChart("100", "run-buttons", displayRuns);
                    new_button.disabled = true;
                    new_button.style.boxShadow = "";
                    new_button.classList = "btn";
                    button_group.append(new_button);
                }

                /*  number of runs */
                if(machine_data.run_data.length > 150){
                    var new_button = ButtonOffChart("150", "run-buttons", displayRuns);
                    new_button.disabled = true;
                    new_button.style.boxShadow = "";
                    new_button.classList = "btn";
                    button_group.append(new_button);
                }

                /*  number of runs */
                var new_button = ButtonOffChart("All", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                new_button.marginRight = "5vw";
                button_group.append(new_button);

                new_top_div.append(button_group);

                /* chart type buttons */
                // container div
                var new_bottom_div = document.createElement("div");
                new_bottom_div.style.height = "8%";
                new_bottom_div.style.position = "absolute";
                new_bottom_div.style.left = 0;
                new_bottom_div.style.bottom = 0;
                new_bottom_div.style.display = "block";
                if(theme == "dark"){new_bottom_div.class = "headerDarkTheme Theme";}
                else{new_bottom_div.class = "headerLightTheme Theme";}
                new_bottom_div.style.width = "100%";
                new_bottom_div.id = "chart_bottom";

                // button group
                var button_group = document.createElement("div");
                button_group.className = "btn-group";
                button_group.style.width = "100%";
                button_group.style.height = "100%";
                //button_group.style.fontSize = "0.7rem";

                // buttons

                //force
                var new_button = ButtonOnChart("SUMMARY", "chart-buttons", updateChartType);
                new_button.id = "force";
                //new_button.style.width = "5vw";
                new_button.style.marginLeft = "3vw";
                button_group.append(new_button);

                //line
                var new_button = ButtonOffChart("LINE CHARTS", "chart-buttons", updateChartType);
                new_button.id = "line";
                //new_button.style.width = "5vw";
                //new_button.style.marginLeft = "6vw";
                button_group.append(new_button);

                // stream
                var new_button = ButtonOffChart("STREAM GRAPH", "chart-buttons", updateChartType);
                new_button.id = "stream";
                //new_button.style.width = "5vw";
                button_group.append(new_button);

                // parallel
                var new_button = ButtonOffChart("PARALLEL GRAPH", "chart-buttons", updateChartType);
                new_button.id = "parallel";
                //new_button.style.width = "5vw";
                button_group.append(new_button);

                //heat
                var new_button = ButtonOffChart("HEAT MAP", "chart-buttons", updateChartType);
                new_button.id = "heat";
                //new_button.style.width = "5vw";
                button_group.append(new_button);

                // box
                var new_button = ButtonOffChart("BOX PLOTS", "chart-buttons", updateChartType);
                new_button.id = "box";
                //new_button.style.marginRight = "3vw"
                //new_button.style.width = "5vw";
                button_group.append(new_button);

                //density
                var new_button = ButtonOffChart("RIDGE LINES", "chart-buttons", updateChartType);
                new_button.id = "density";
                //new_button.style.width = "5vw";
                new_button.style.marginRight = "3vw";
                button_group.append(new_button);

                new_bottom_div.append(button_group);

                // plot area 
                var plot_area = document.createElement("div");
                plot_area.id = "plot_chart";
                plot_area.style.width = "100%";
                plot_area.style.height = "100%";
                plot_area.style.opacity = 0;

                chart_inner.append(new_top_div);
                chart_inner.append(plot_area);
                chart_inner.append(new_bottom_div);
                chart_div.append(chart_inner);

                // transition on load
                var t = d3.transition().duration(1500);
                d3.select("#chart_inner").transition(t).style("opacity", 1);
}

        function updateChartType(event){

            // change background and update state
            var buttons = document.getElementsByName("chart-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            event.target.style.backgroundColor = "white";
            event.target.style.borderColor = "var(--dark)";
            event.target.style.color = "var(--dark)";
            chart_type = event.target.id;

            // radios and buttons
            var radios = document.getElementsByName("radioOptions");
            var scale_buttons = document.getElementsByName("scale-buttons");
            var run_buttons = document.getElementsByName("run-buttons");


            // default disable scale buttons (enable below for LINE and STREAM)
            for(let i = 0; i<scale_buttons.length; i++){
                    scale_buttons[i].disabled = true;
                    scale_buttons[i].style.boxShadow = "";
                    scale_buttons[i].classList = "btn";
            }

            // default disable run buttons (enable below for LINE and STREAM and HEAT)
            for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = true;
                    run_buttons[i].style.boxShadow = "";
                    run_buttons[i].classList = "btn";
            }

            // force graph (sumamry)
            if(chart_type == "force"){
                mainForce = true;
                draw_force_main(true);

                // enable all radios
                for(let i = 0; i<radios.length; i++){
                    radios[i].disabled = false;
                }

                return;
            }
            else{
                mainForce = false;
            }

            // draw chart
            if(chart_type == "line"){
                // enable line charts for normalised and all
                for(let i = 0; i<radios.length; i++){
                    radios[i].disabled = false;
                }
                if(metric_type == "lcms"){
                    draw_line_chart(true);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_line(true);
                }
                else{
                    draw_pressure_line(true);
                }

                // enable scale buttons
                for(let i = 0; i<scale_buttons.length; i++){
                    scale_buttons[i].disabled = false;
                    scale_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    scale_buttons[i].classList = "btn btn-custom";
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }
            }
            else if(chart_type == "parallel"){
                // disable pressure metrics 
                for(let i = 0; i<radios.length; i++){
                    if(radios[i].classList.contains("pressure")){
                            radios[i].disabled = true;
                        }
                }
                if(metric_type == "lcms"){
                    draw_parallel_graph(true);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_parallel_graph(true);
                }
                
            }
            else if(chart_type == "box"){
                
                for(let i = 0; i<radios.length; i++){
                    // disable box plots for normalised
                    var radio_name = radios[i].labels[0].innerText;
                    if(radio_name == "Area (normalised)" || radio_name == "Height (normalised)"){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }
                    
                    // disable ms2 and pressure metrics (no box plots)
                    if(radios[i].classList.contains("pressure") || radios[i].classList.contains("ms2")){
                        radios[i].disabled = true;
                    }
                }

                if(metric_type == "lcms"){
                    yScale_box = null;
                    draw_box_plot(true);
                } 
            }
            else if(chart_type == "heat"){
               
                // disable heat maps 
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    if(radios[i].classList.contains("pressure") || radios[i].classList.contains("ms2")){
                        radios[i].disabled = true;
                    }
                    else if(radio_name == "Retention Time" || radio_name == "Full Width Half Maximum"){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }

                draw_heat_map(true);
            }
            else if(chart_type == "density"){
                // enable all
                //for(let i = 0; i<radios.length; i++){
                    //radios[i].disabled = false;
                //}
                draw_density_plots(true);
                
            }
            else if(chart_type == "stream"){
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }

                    if(radio_name == "Precursor Mass Error"){
                        radios[i].disabled = true;
                    }
                    
                }

                // enable scale buttons
                for(let i = 0; i<scale_buttons.length; i++){
                        scale_buttons[i].disabled = false;
                        scale_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                        scale_buttons[i].classList = "btn btn-custom";
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }

                if(metric_type == "lcms"){
                    draw_stream_graph(true);
                }
                else if(metric_type == "ms2"){
                    draw_ms2_stream_graph(true);
                }

            }
        }

        function streamChartFilterUpdate(){
            // allow for circles (on full view, even for stream)
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
                xScale_chart.domain([minX, maxX]);
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
                xScale_chart.domain([maxX, minX]);
            }

            // get new ymax (total view only)
            var component_indexes = getComponentIndexes();
            var y_max = -Infinity;
            for(let j = 0; j < x_values_chart.length; j++){
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                        else{
                            break;
                        }
                    }
                }
            }

            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // update y scale
            if(!streamExpand){
                yScale_stream.domain([y_max, 0]);
            }

            // y-axis
            d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

            // x-axis
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);

            // streams
            d3.selectAll(".streams")
            .transition().duration(1000)
            .attr("d", area);

            // marker
            d3.select("#marker")
            .transition()
            .duration(1000)
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("x2", xScale_chart(x_values_chart[run_index]));
        }

        function streamChartFilterUpdateMS2(){
            // allow for circles (on full view, even for stream)
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
                xScale_chart.domain([minX, maxX]);
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
                xScale_chart.domain([maxX, minX]);
            }

            // loop for d3 stacked data
            var y_max = -Infinity;
            for(let j = 0; j < x_values_chart.length; j++){
                let total = 0;
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                        var new_value = Math.abs(machine_data.ms2_metrics[i].values[j]);
                        total += new_value;
                        
                        // get total and store max (in filter range)
                        if(total > y_max){
                            if(j<filter){
                                y_max = total;
                            }
                            else{
                                break;
                            }
                        }
                    }
                }
            }

            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream_ms2(d[0]);})
                    .y1(function(d) { return yScale_stream_ms2(d[1]);});

            // update y scale
            if(!streamExpand){
                yScale_stream_ms2.domain([y_max, 0]);
            }

            // y-axis
            d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream_ms2);

            // x-axis
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);

            // streams
            d3.selectAll(".streams")
            .transition().duration(1000)
            .attr("d", area);

            // marker
            d3.select("#marker")
            .transition()
            .duration(1000)
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("x2", xScale_chart(x_values_chart[run_index]));
        }

        function updateChangeScaleStream(){

            // loop for d3 stacked data
            var d3_data = [];
            var component_indexes = getComponentIndexes();
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                    }
                }
                d3_data.push(new_row);
            }

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // streams
            d3.selectAll(".streams")
            .data(stack)
            .transition().duration(1000)
            .attr("d", area);

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_stream_graph(false);
            }, 1000);

        }

        function updateChangeScaleStreamMS2(){

            /// loop for d3 stacked data
            var d3_data = [];
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                        var new_value = Math.abs(machine_data.ms2_metrics[i].values[j]);
                        new_row[machine_data.ms2_metrics[i].display_name] = new_value;
                    }
                }
                d3_data.push(new_row);
            }

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeysMS2);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream_ms2(d[0]);})
                    .y1(function(d) { return yScale_stream_ms2(d[1]);});

            // streams
            d3.selectAll(".streams")
            .data(stack)
            .transition().duration(1000)
            .attr("d", area);

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_ms2_stream_graph(false);
            }, 1000);

        }

        function update_stream_graph(selectOne){
            //** called to transition component change **//

            // loop for d3 stacked data
            var component_indexes = getComponentIndexes();
            var d3_data = [];
            var y_max = -Infinity;
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                    }
                }
                d3_data.push(new_row);
            }

            // update y scale
            if(!streamExpand){
                yScale_stream.domain([y_max, 0]);
            }

            // handle single component in expand (reset to no offset)
            if(streamExpand && component_indexes.length == 1){
                // reset y domain and axis
                yScale_stream = yScale_stream_total;
                y_axis_stream = y_axis_stream_total;

                // change stack
                offsetType = d3.stackOffsetNone;

                streamExpand = false;
            }

            // y-axis
            d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            if(selectOne){
                d3.selectAll(".streams").style("opacity", 0);
            }

            if(streamExpand && component_indexes.length == 1){
                d3.selectAll(".streams").style("opacity", 0);
            }

            // streams
            d3.selectAll(".streams")
            .data(stack)
            .transition().duration(1000)
            .style("fill", function(d) {
                    return  'url(#circleGradLight' + d.key +')'; //colourByKey[d.key];
                })
            .style("stroke", function(d) {return colourByKey[d.key];})
            .style("opacity", 1)
            .attr("d", area);

            // re-draw to reset
            setTimeout(function(){
                draw_stream_graph(false);
            }, 1000);

        }

        function draw_stream_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot (same as draw line and pressure)
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            
            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // reset from zero components
            plot_area.style.opacity = 1;

            // get indexes of checked components
            var component_indexes = getComponentIndexes();
    
            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View the Stream Graph";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // circle gradient fills (have to use names as streams change and use key)
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + machine_data.components[parseInt(component_indexes[i])].component_name)
                //.attr('x1', '0%')
                //.attr('y1', '100%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                
                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour + '80')
                .style('stop-opacity', 1);
                

                //gradFill.append('stop')
                //.attr('offset', '100%')
                //.style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                //.style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('radialGradient')
                .attr('id', 'circleGradLightRad' + component_indexes[i])
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // define a clipPath: everything out of this area won't be drawn (else draws in margin)
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipStream") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // add the clip path
            var all_streams = svg.append('g')
                .attr("clip-path", "url(#clipStream)");

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // offsets and extents (allow for circles) 
            //var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }

            // loop for d3 stacked data
            var d3_data = [];
            var y_max = -Infinity;
            var y_min = Infinity; // just using zero
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                    }
                }
                d3_data.push(new_row);
            }

            // names (create stack on first draw)
            if(stackKeys.length == 0){
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        stackKeys.push(machine_data.components[i].component_name);
                    }
                }
            }

            // colours
            colourByKey = {};
            for(let i in machine_data.components){
                colourByKey[machine_data.components[i].component_name] = machine_data.components[i].colour;
            }

            /* Y scales and axes */
            yScale_stream_expand = d3.scaleLinear()
                .domain([1, 0]) 
                .range([height, 0]);

            yScale_stream_total = d3.scaleLinear()
                .domain([y_max, 0]) 
                .range([height, 0]);

            // y scale dual scales
            if(streamExpand){
                yScale_stream = yScale_stream_expand;
            }
            else{
                yScale_stream = yScale_stream_total;
            }

            /** y-axis based on state**/
            y_axis_stream_total = d3.axisLeft().ticks(5).scale(yScale_stream_total)
            .tickSize(v_height_unit).tickSizeOuter(0);

            y_axis_stream_expand = d3.axisLeft().ticks(5).scale(yScale_stream_expand)
            .tickSize(v_height_unit).tickSizeOuter(0).tickFormat(i => parseInt(i*100) + "%");

            if(streamExpand){
                y_axis_stream = y_axis_stream_expand;
            }
            else{
                y_axis_stream = y_axis_stream_total;
            }

            // handle single component in expand (reset to no offset)
            if(streamExpand && component_indexes.length == 1){
                // reset y domain and axis
                yScale_stream = yScale_stream_total;
                y_axis_stream = y_axis_stream_total;

                // change stack
                offsetType = d3.stackOffsetNone;

                streamExpand = false;
            }

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // plot the streams
            all_streams
            .selectAll("layers")
            .data(stack)
            .enter()
            .append("path")
            .attr("class", "streams")
            .style("fill", function(d) {
                return  'url(#circleGradLight' + d.key +')'; //colourByKey[d.key];
            })
            .style("fill-opacity", 1)
            .style("stroke", function(d) {return colourByKey[d.key];})//colourByKey[d.key]
            .style("stroke-opacity", 0.5)
            .style("stroke-width", lineWidth)
            .on("mouseover", function(event, d){
                // text location boundaries
                var x = event.layerX;
                var y = event.layerY;
                var anchor = "middle"; 
                if(x >= lineChartWidth -100){
                    x = lineChartWidth - 200;
                    anchor = "start";
                };
                if(x <= 150){
                    x = x + 150;
                }
                if(y >= height -100){
                    y = height - 100;
                }
                
                // add text (name)
                all_streams.append("text")
                .attr("class", "hover-text")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", "1em")
                .attr("font-size", "1em")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .style("text-anchor", anchor)
                .style("text-shadow", "0.1vh 0.1vh gray")
                .text(d.key);


                // highlight
                d3.selectAll(".streams").style("opacity", function(e){
                    if(e.key == d.key){return 1;}
                    return 0.1;
                });
                
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".streams").style("opacity", 1);
                d3.selectAll(".hover-text").remove();
            })
            .attr("d", area);

            // add vertical marker
           all_streams.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 1)
            .attr("cursor", "pointer")
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .on("mouseover", function(event){

                // overlays to highlight
                if(run_index < filter){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return xScale_chart(x_values_chart[run_index+1]);
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                if(run_index !=0){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", xScale_chart(x_values_chart[run_index-1]))
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return lineChartWidth;
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                
            })
            .on("mouseout", function(event){
                d3.selectAll(".streamHighlight").remove();
            })
            .on("click", function(event){

                if(stackKeys.length == 1){return;}
                // CLOSE
                if(streamExpand){
                    // reset y domain and axis
                    yScale_stream = yScale_stream_total;
                    y_axis_stream = y_axis_stream_total;
                    d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

                    // change stack
                    offsetType = d3.stackOffsetNone;
                    stackedData = d3.stack()
                        .offset(offsetType)
                        .order(d3.stackOrderNone)
                        .keys(stackKeys);

                    stack = stackedData(d3_data);

                    // redraw
                    d3.selectAll(".streams")
                    .data(stack)
                    .transition().duration(1000)
                    .attr("d", area);

                    streamExpand = false;
                    return;
                }

                // EXPAND
                // set y domain
                yScale_stream = yScale_stream_expand;
                y_axis_stream = y_axis_stream_expand;
                d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

                // change stack
                offsetType = d3.stackOffsetExpand;
                stackedData = d3.stack()
                    .offset(offsetType)
                    .order(d3.stackOrderNone)
                    .keys(stackKeys);

                stack = stackedData(d3_data);

                // redraw
                d3.selectAll(".streams")
                .data(stack)
                .transition().duration(1000)
                .attr("d", area);

                streamExpand = true;
                
            });

        
            // ylabel left (units)

            // add ABS. to metric names
            var abs_metrics = ["Mass Error (ppm)", "Mass Error (mDa)", "Area (normalised)", "Height (normalised)"];
            if(abs_metrics.includes(display_metric)){
                var displayText = y_labels[display_metric].toUpperCase() + " (Abs.)";
            }
            else{
                var displayText = y_labels[display_metric].toUpperCase(); 
            }

            svg.append("text")
            .attr("class", "label lineText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(displayText);

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            }
            );

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis_stream);
                
            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            //.style('fill-opacity', 0.5)
            .call(x_axis);

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".streams").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }

            // double click reset chart(removed for exapand mode)
            /*
            svg.on("dblclick",function(){
                // set scale
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }

                // x-axis
                x_axis_call.transition().duration(1000).call(x_axis);

                // streams
                d3.selectAll(".streams")
                .transition().duration(1000)
                .attr("d", area);
                
                // marker
                d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));
            });
            */

        }

        function draw_ms2_stream_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot (same as draw line and pressure)
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            
            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // reset from zero components
            plot_area.style.opacity = 1;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // circle gradient fills (have to use names as streams change and use key)
            for(let i in machine_data.ms2_metrics){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + machine_data.ms2_metrics[i].metric_id)
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.ms2_metrics[i].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + machine_data.ms2_metrics[i].metric_id)
                //.attr('x1', '0%')
                //.attr('y1', '100%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.ms2_metrics[i].colour)
                .style('stop-opacity', 1);

                
                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.ms2_metrics[i].colour + '80')
                .style('stop-opacity', 1);
                

                //gradFill.append('stop')
                //.attr('offset', '100%')
                //.style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                //.style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('radialGradient')
                .attr('id', 'circleGradLightRad' + machine_data.ms2_metrics[i].metric_id)
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.ms2_metrics[i].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // define a clipPath: everything out of this area won't be drawn (else draws in margin)
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipStream") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // add the clip path
            var all_streams = svg.append('g')
                .attr("clip-path", "url(#clipStream)");

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // offsets and extents (allow for circles) 
            //var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }


            // loop for d3 stacked data
            var d3_data = [];
            var y_max = -Infinity;
            var y_min = Infinity; // just using zero
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                let total = 0;
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                        var new_value = Math.abs(machine_data.ms2_metrics[i].values[j]);
                        new_row[machine_data.ms2_metrics[i].display_name] = new_value;
                        new_row["id"] = machine_data.ms2_metrics[i].metric_id;
                        total += new_value;
                        
                        // get total and store max (in filter range)
                        if(total > y_max){
                            if(j<filter){
                                y_max = total;
                            }
                        }
                    }
                }
                d3_data.push(new_row);
            }

            // names (create stack on first draw)
            if(stackKeysMS2 == null){
                stackKeysMS2 = [];
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                        stackKeysMS2.push(machine_data.ms2_metrics[i].display_name);
                    }
                }
            }
            
            // fill colours
            var colourByKeyMS2 = {};
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                    colourByKeyMS2[machine_data.ms2_metrics[i].display_name] = "url(#circleGradLight" + machine_data.ms2_metrics[i].metric_id +")";
                }
            }

            // stroke colours
            var strokeByKeyMS2 = {};
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name != "Precursor Mass Error"){
                    strokeByKeyMS2[machine_data.ms2_metrics[i].display_name] = machine_data.ms2_metrics[i].colour;
                }
            }

            /* Y scales and axes */
            yScale_stream_expand_ms2 = d3.scaleLinear()
                .domain([1, 0]) 
                .range([height, 0]);

            yScale_stream_total_ms2 = d3.scaleLinear()
                .domain([y_max, 0]) 
                .range([height, 0]);

            // y scale dual scales
            if(streamExpand){
                yScale_stream_ms2 = yScale_stream_expand_ms2;
            }
            else{
                yScale_stream_ms2 = yScale_stream_total_ms2;
            }

            /** y-axis based on state**/
            y_axis_stream_total_ms2 = d3.axisLeft().ticks(5).scale(yScale_stream_total_ms2)
            .tickSize(v_height_unit).tickSizeOuter(0).tickFormat(d => (d/1000) + " K");

            y_axis_stream_expand_ms2 = d3.axisLeft().ticks(5).scale(yScale_stream_expand_ms2)
            .tickSize(v_height_unit).tickSizeOuter(0).tickFormat(i => parseInt(i*100) + "%");

            if(streamExpand){
                y_axis_stream_ms2 = y_axis_stream_expand_ms2;
            }
            else{
                y_axis_stream_ms2 = y_axis_stream_total_ms2;
            }

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text("ALL MS2 METRICS");

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "ALL MS2 METRICS";

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeysMS2);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream_ms2(d[0]);})
                    .y1(function(d) { return yScale_stream_ms2(d[1]);});

            // plot the streams
            all_streams
            .selectAll("layers")
            .data(stack)
            .enter()
            .append("path")
            .attr("class", "streams")
            .style("fill", function(d) {
                return  colourByKeyMS2[d.key];//'url(#circleGradLight' + d.key +')'; 
            })
            .style("fill-opacity", 1)
            .style("cursor", "pointer")
            .style("stroke", function(d) {return strokeByKeyMS2[d.key];})//colourByKey[d.key]
            .style("stroke-opacity", 0.5)
            .style("stroke-width", lineWidth)
            .on("click", function(event, d){
                stackKeysMS2 = stackKeysMS2.filter(e => e != d.key);
                stackKeysMS2.unshift(d.key);
                
                stackedData = d3.stack()
                .offset(offsetType)
                .order(d3.stackOrderNone)
                .keys(stackKeysMS2);

                stack = stackedData(d3_data);

                d3.selectAll(".streams").data(stack)
                .transition().duration(1000)
                .style("fill", function(d) {
                    return  colourByKeyMS2[d.key];//'url(#circleGradLight' + d.key +')'; 
                })
                .style("stroke", function(d) {
                    return strokeByKeyMS2[d.key];
                })
                .attr("d", area);
                

            })
            .on("mouseover", function(event, d){
                // text location boundaries
                var x = event.layerX;
                var y = event.layerY;
                var anchor = "middle"; 
                if(x >= lineChartWidth -100){
                    x = lineChartWidth - 200;
                    anchor = "start";
                };
                if(x <= 150){
                    x = x + 150;
                }
                if(y >= height -100){
                    y = height - 100;
                }
                
                // add text (name)
                all_streams.append("text")
                .attr("class", "hover-text")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", "1em")
                .attr("font-size", "1em")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .style("text-anchor", anchor)
                .style("text-shadow", "0.1vh 0.1vh gray")
                .text(d.key);

                // highlight
                d3.selectAll(".streams").style("opacity", function(e){
                    if(e.key == d.key){return 1;}
                    return 0.1;
                });
                
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".streams").style("opacity", 1);
                d3.selectAll(".hover-text").remove();
                
            })
            .attr("d", area);

            // add vertical marker
           all_streams.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 1)
            .attr("cursor", "pointer")
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .on("mouseover", function(event){

                // overlays to highlight
                if(run_index < filter){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return xScale_chart(x_values_chart[run_index+1]);
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                if(run_index !=0){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", xScale_chart(x_values_chart[run_index-1]))
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return lineChartWidth;
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                
            })
            .on("mouseout", function(event){
                d3.selectAll(".streamHighlight").remove();
            })
            .on("click", function(event){

                // CLOSE
                if(streamExpand){
                    // reset y domain and axis
                    yScale_stream_ms2 = yScale_stream_total_ms2;
                    y_axis_stream_ms2 = y_axis_stream_total_ms2;
                    d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream_ms2);

                    // change stack
                    offsetType = d3.stackOffsetNone;
                    stackedData = d3.stack()
                        .offset(offsetType)
                        .order(d3.stackOrderNone)
                        .keys(stackKeysMS2);

                    stack = stackedData(d3_data);

                    // redraw
                    d3.selectAll(".streams")
                    .data(stack)
                    .transition().duration(1000)
                    .attr("d", area);

                    streamExpand = false;
                    return;
                }

                // EXPAND
                // set y domain
                yScale_stream_ms2 = yScale_stream_expand_ms2;
                y_axis_stream_ms2 = y_axis_stream_expand_ms2;
                d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream_ms2);

                // change stack
                offsetType = d3.stackOffsetExpand;
                stackedData = d3.stack()
                    .offset(offsetType)
                    .order(d3.stackOrderNone)
                    .keys(stackKeysMS2);

                stack = stackedData(d3_data);

                // redraw
                d3.selectAll(".streams")
                .data(stack)
                .transition().duration(1000)
                .attr("d", area);

                streamExpand = true;
                
            });

            /*
            const labels = all_streams.selectAll('text').data(stack);
            labels
            .enter().append('text')
            .attr('class', 'area-label')
            .merge(labels)
            .text(d => d.key)
            .attr('transform', d3.areaLabel(area))
            */
        
            // ylabel left (units)
            svg.append("text")
            .attr("class", "label lineText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text("");

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            }
            );

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis_stream_ms2);
                
            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            //.style('fill-opacity', 0.5)
            .call(x_axis);

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".streams").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
        }

        function draw_density_plots(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;
            var legend_height = plot_height/10; 

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }


            // get indexes of checked components
            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Ridge Line";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 12*v_height_unit, 
                          right: 4*v_width_unit + currentRadius, 
                          bottom: chart_bottom.offsetHeight+6*v_height_unit, 
                          left: v_width_unit};

            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'ridgeFill')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', "var(--info)")
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', 'var(--info)')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'skyblue')
                .style('stop-opacity', 1);

            // define a clipPath: everything out of this area won't be drawn (else draws in margin)
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipRidge") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width - currentRadius*4)
                .attr("height", height + 2*margin.top)
                .attr("x",-margin.left/2)
                .attr("y", - margin.top);

            // add the clip path
            var all_ridges = svg.append('g')
                .attr("clip-path", "url(#clipRidge)");

            //** CHROM dAta **/
            var ridgeData = [];
            var ridgeNames = [];
            var xMax = 45; 
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var new_chrom = {"key": machine_data.components[i]["component_name"],
                                    "rt": machine_data.components[i]["lcms_metrics"]["Retention Time"].values[run_index],
                                    "colour": machine_data.components[i]["colour"],
                                    "data": machine_data.components[i].chromatograms[run_index]};
                    
                    //  Y scale for values (per chromatogram)
                    new_chrom["scale"] = d3.scaleLinear()
                        .domain([0, 3.5*d3.max(new_chrom.data, d=>d.y)])
                        .range([height, 0]);

                    // set bigger if one
                    if(component_indexes.length == 1){
                        new_chrom["scale"].domain([0, 0.8*d3.max(new_chrom.data, d=>d.y)])
                    }

                    ridgeData.push(new_chrom);
                }
            }

            // sort by retention time
            ridgeData.sort((a, b) => a["rt"] < b["rt"]);
            ridgeNames = ridgeData.map(d => d.key);

            //  Y scale for names
            var yScale_names = d3.scaleBand()
                .domain(ridgeNames)
                .range([0, height])
                .paddingInner(1);

            // X scale
            var xScale = d3.scaleLinear()
                .domain([17, xMax])
                .range([ 0, width]);

            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale)
            .tickSize(v_height_unit/2).ticks(5).tickSizeOuter(0);
            
            
            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text("CHROMATOGRAMS");

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "CHROMATOGRAMS";

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "90%")
            .attr("y", "-15%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("text-anchor", "middle")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("x", width / 2)
                .attr("y", height + margin.bottom/3)
                .text("MINUTES");
                
            // curved line
            var line = d3.line().curve(d3.curveLinear)
                                    .x(function(d, i) {return xScale(d.x)})
                                        .y(function(d, i) {return yScale_ridge(d.y)});

            // area under curve
            var area = d3.area().curve(d3.curveLinear)
                        .x(function(d) {return xScale(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale_ridge(d.y);});

            // draw the ridges
            for(let i in ridgeData){ 
                // set yscale (or leave)
                if(!chromExpand){
                    yScale_ridge = ridgeData[i].scale;
                }
                if(yScale_ridge == null){
                    yScale_ridge = ridgeData[i].scale;
                }

                // set xscale domain per component
                var currentRT = ridgeData[i].rt;
                //xScale.domain([currentRT - 0.1, currentRT + 0.1])

                // handle single component
                var translateY = yScale_names(ridgeData[i].key)-height;
                if(component_indexes.length == 1){
                    var translateY = 0;
                }

                all_ridges.append("path")
                    .attr("id", "ridge"+i)
                    .attr("class", "ridge")
                    .attr("fill", function(){
                        //if(theme == "dark"){return "white"}
                        return "url(#ridgeFill)";//"var(--dark)";
                    })
                    .attr("fill-opacity", 1)
                    .attr("stroke", function(){
                        if(theme == "dark"){return "white"}
                        return "var(--dark)";
                    })
                    .attr("stroke-width", lineWidth/4)
                    .attr("transform", function(d){return("translate(" + '0' + "," + translateY +")" )})
                    .datum(ridgeData[i].data)
                    .attr("d", area)
                    //.attr("filter", "url(#diffuse)")
                    .attr("cursor", "pointer")
                    .on("click", function(event, d){
                        // reset
                        if(chromExpand){
                            for(let j in ridgeData){ 
                                yScale_ridge = ridgeData[j].scale;
                                d3.select("#ridge"+j)
                                .transition().duration(1000)
                                .attr("d", area);
                            }
                            chromExpand = false;
                        } // expand
                        else{
                            // set yScale to clicked chrom
                            yScale_ridge = ridgeData[i].scale;
                            d3.selectAll(".ridge")
                            .transition().duration(1000)
                            .attr("d", area);
                            chromExpand = true;
                        }
                    });
                
                // add comp circles
                svg
                    .append("circle")
                    .attr("cx", width - currentRadius)
                    .attr("cy", yScale_names(ridgeData[i].key) - currentRadius)
                    .attr("r", currentRadius)
                    .attr("fill", function(d){ 
                        return ridgeData[i].colour;//"url(#circleGradLight"+d.c_index+")";
                    })
                    .attr("stroke", function(d){
                        return ridgeData[i].colour; //"url(#circleGradLight"+d.c_index+")";
                    })
                    .attr("filter", "url(#specular)")
                    .attr("stroke-opacity", 0.5)
                    .attr("stroke-width", lineWidth/2)
                    .attr("class", "point")
                    .on("mouseover", function(event, d){
                        d3.selectAll(".ridge").style("opacity", 0.05);
                        d3.select("#ridge"+i).style("opacity", 1);

                        // add name
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", 2*v_width_unit)
                        .attr("y", yScale_names(ridgeData[i].key))
                        .attr("dy", "1em")
                        .attr("font-size", "1.5em")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .style("text-shadow", "0.1vh 0.1vh gray")
                        .text(ridgeData[i].key);
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".ridge").style("opacity", 1);
                        d3.selectAll(".hover-text").remove();
                    });

                    // move ridges to correct location
                    xScale.domain([17, xMax]);
                    //d3.select("#ridge"+i).attr("transform", "translate(" + xScale(currentRT-17) + "," + translateY + ")")
                
            }

             // create x-axis 
             xScale.domain([17, xMax]);
             var x_axis_call = all_ridges.append("g")
            .attr("transform", "translate(0," + (height) + ")") 
            .call(x_axis)
            //.style('stroke-width', '0.4vh')
            .style('font-size', '1.8vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis xAxis axis-light";
                });

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".ridge").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select(".xAxis").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

            }
        }

        function draw_heat_map(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            
            plot_area.style.opacity = 1;
                
            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Heat Map";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 2*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight+2*v_height_unit, 
                          left: 2*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // create data range for legend
            var heat_range = heat_ranges[display_metric].hi - heat_ranges[display_metric].low;
            var step = heat_range/5000; // granularity of legend
            var interval = heat_ranges[display_metric].low - step;
            var legend_data = [interval];
        
            while(interval < heat_ranges[display_metric].hi){
                new_interval = interval + step;
                interval = parseFloat(new_interval.toFixed(4));
                legend_data.push(interval);
            }

            // rect width and scale for legend
            var rect_width = width/legend_data.length; // for last drawn
            var legend_height = 2*v_height_unit;
            var legendScale = d3.scaleLinear()
            .domain([heat_ranges[display_metric].low - step, heat_ranges[display_metric].hi + step])
            .range([0, width]);

            // create colour scale
            var colourScale = d3.scaleSequential()
                .interpolator(d3.interpolateRdBu)
                .domain([heat_ranges[display_metric].low - step, heat_ranges[display_metric].hi + step])

            // legend
            svg
            .selectAll("legend")
            .data(legend_data)
            .enter()
            .append("rect")
            .attr("x", (d) => Math.floor(legendScale(d)))
            .attr("y", 0)
            .attr("height", legend_height)
            .attr("width", function(d,i){
                if(i==legend_data.length-1){
                    return rect_width;
                }
                return Math.floor(legendScale(legend_data[i+1]))-Math.floor(legendScale(d));
            })
            .attr("fill", (d) => colourScale(d));

            // legend axis label 
            var legend_axis = d3.axisBottom().scale(legendScale).tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // add legend axis
            svg.append("g")
            .attr("transform", "translate(0," + legend_height + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .attr("id", "legendAxis")
            .call(legend_axis)
            .style('font-size', '1.6vh');

            // legend label
            svg.append("text")
            .attr("class", "label-heat")
            .attr("y", legend_height/2 + legend_height/4)
            .attr("x",width / 2)
            .style("text-anchor", "middle")
            .style('font-size', '1.6vh')
            .attr("stroke", function(){
                    //if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("fill", function(){
                    //if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .text(y_labels[display_metric].toUpperCase());

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "95%")
            .attr("y", "2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // x values
            var run_values = machine_data.run_data
            var x_values = [];
            for(let run in run_values){
                if(run < filter){
                    if(run < 40){ // cap heat maps to 40
                        x_values.push(run_values[run].date_time);
                    }
                }
                else{
                    break;
                }
            }

            // set cell height
            var height_pad = 0;//v_height_unit/2;
            cell_height = (height - 2*currentRadius - 2*v_height_unit - legend_height - margin.bottom- height_pad*(x_values.length-1))/(x_values.length+1);

            // heat column width
            var map_width = width - 4*v_width_unit; // space for marker (match to scale)
            var heat_padding = 0;
            if(component_indexes.length > 3){
                var heat_width = (map_width - (heat_padding*(component_indexes.length)+ heat_padding))/component_indexes.length;
            }
            else{
                var heat_width = width/4;
            }

            // heat maps container
            var translateY = 4*legend_height;
            var heat_maps = svg.append("g")
            .attr("transform", "translate(0," + translateY + ")");

            // x scale names
            var names = [];
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    names.push({"name": machine_data.components[i].component_name,
                                "mode": machine_data.components[i].component_mode});
                }
            }
            
            // sort by mode and name to match menu order
            names.sort((a, b) => a["name"] > b["name"]);
            names.sort((a, b) => a["mode"] < b["mode"]);
            names = names.map(function(entry){
                return entry.name;
            })

            // x scale
            var xScale_heat = d3.scaleBand()
                .range([2*v_width_unit, width-2*v_width_unit])
                .domain(names)
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // add horizontal marker
            heat_maps.append("line")
                .attr("id", "heatMarker")
                .attr("x1", 0)
                .attr("y1", cell_height*run_index + cell_height/2)
                .attr("x2", width)
                .attr("y2", cell_height*run_index + cell_height/2)
                .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
                .attr("stroke-width", lineWidth)
                .attr("stroke-opacity" ,1)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white"}
                    return "var(--dark)";
                })
                .attr("opacity", function(){
                    if(run_index < filter){
                        return 1;
                    }
                    else{
                        return 0;
                    }
                });
            
            
            // draw columns of heat map
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j<filter; j++){ 
                        // handle less than 40 runs
                        if(j >= machine_data.run_data.length){break;}
                        if(j >= 40){break;}
                        let new_row = {'x': x_values[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }

                    // draw heat map column
                    heat_maps
                    .selectAll("heatmap")
                    .data(data)
                    .enter()
                    .append("rect")
                    //.attr("rx", 1)
                    //.attr("ry", 1)
                    .attr("x", function(d){return(xScale_heat(machine_data.components[i].component_name)- heat_width/2)})
                    .attr("y", function(d,i){
                        return Math.floor(cell_height*i) + i*height_pad;
                    })
                    .attr("height", function(d,i){
                        return Math.floor(cell_height);
                    })
                    .attr("width", function(d,i){
                        return Math.floor(heat_width);
                    })
                    .attr("class", function(d,j){
                        return "heat heat" + i + " hover" + j;
                    })
                    .attr("stroke-width", function(d,j){
                        return base_line_width;
                    })
                    .attr("stroke", function(d, j){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            return "var(--dark)";
                        }
                        else{
                            return colourScale(d.y);
                        }
                    })
                    .attr("fill", function(d){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            return "var(--dark)";
                        }
                        else{
                            return colourScale(d.y);
                        }
                    })
                    .on("mouseover", function(event, d){
                        
                        var tooltip = d3.select("#tooltip");
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            var tooltipHTML = "<strong>" + machine_data.components[i].component_name.replace("_", " ") + 
                                            "</strong><br>" + d.x.toDateString() + "<br>" +
                                                get_time(d.x) +  "<br><strong>" +
                                                "NO VALUE" + "</strong>";
                        } else{
                            var tooltipHTML = "<strong>" + machine_data.components[i].component_name.replace("_", " ") + 
                                            "</strong><br>" + d.x.toDateString() + "<br>" +
                                                get_time(d.x) +  "<br><strong>" +
                                                Number.parseFloat(d.y).toFixed(3) + "</strong>";
                        }
                        tooltip.html(tooltipHTML);
                        tooltip.style('left', (event.pageX+10) + 'px');
                        tooltip.style('top', (event.pageY+10) + 'px');
                        tooltip.style("visibility", "visible");
                        // highlights
                        //d3.select(this).attr("stroke", "var(--dark)");
                        //d3.selectAll(".heat").style("opacity", 0.5);
                        //d3.select(this).style("opacity", 1);

                        if(d.index == run_index){
                            d3.selectAll(".heat").style("opacity", 0.1);
                            d3.selectAll(".hover"+run_index).style("opacity", 1);
                        }
                            
                        
                    })
                    .on("mouseout", function(event, d){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        var tooltip = d3.select("#tooltip");
                        tooltip.style('left', '0px');
                        tooltip.style('top', '0px');
                        tooltip.style("visibility", "hidden");
                        // de-highlight
                        d3.selectAll(".heat").style("opacity",1);
                    });

                    // add component marker
                    heat_maps
                    .append("circle")
                    .attr("x", xScale_heat(machine_data.components[i].component_name))
                    .attr("y", function(d,i){
                        return (cell_height+height_pad)*(x_values.length) + 2*v_height_unit;
                    })
                    .attr("cx", xScale_heat(machine_data.components[i].component_name))
                    .attr("cy", function(d,i){
                        return (cell_height+height_pad)*(x_values.length) + 2*v_height_unit;
                    })
                    .attr("r", currentRadius)
                    .attr("filter", "url(#specular)")
                    .attr("fill", machine_data.components[i].colour)
                    .attr("stroke", machine_data.components[i].colour)
                    .attr("stroke-width", lineWidth/2)
                    .attr("stroke-opacity", 0.5)
                    .attr("cursor", "pointer")
                    .attr("class", "heat heat" + i)
                    .on("mouseover", function(event, d){
                        var tooltip = d3.select("#tooltip");
                        var tooltipHTML = machine_data.components[i].component_name.replace("_"," ");                   
                        tooltip.html(tooltipHTML);
                        tooltip.style('left', (event.pageX + 30) + 'px');
                        tooltip.style('top', (event.pageY-50) + 'px');
                        tooltip.style("visibility", "visible");

                        d3.selectAll(".heat").style("opacity", 0.1);
                        d3.selectAll(".heat" + i).style("opacity", 1);
                    })
                    .on("mouseout", function(event, d){
                        var tooltip = d3.select("#tooltip");
                        tooltip.style('left', '0px');
                        tooltip.style('top', '0px');
                        tooltip.style("visibility", "hidden");
                        d3.selectAll(".heat").style("opacity", 1);
                    })
                    .on("click", function(event, d){
                        comp_index = i;
                        draw_chromatogram(true);
                    });

                }
            }
    
            if(transition){
                d3.selectAll(".heat").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#heatMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll("rect").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".label-heat").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll("#legendAxis").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

            }
        }

        function create_metric_menu(transition){

            // get container
            var metric_menu_div = document.getElementById("menu");

            // remove any elements
            while (metric_menu_div.firstChild) {
                metric_menu_div.removeChild(metric_menu_div.firstChild);
            }

            // div for content
            var metric_menu_inner = document.createElement("div");
            metric_menu_inner.style.position = "absolute";
            metric_menu_inner.style.left = "2.5%";
            metric_menu_inner.style.top = "2.5%"; 
            metric_menu_inner.style.width = "95%";
            //metric_menu_inner.style.height = "95%";
            metric_menu_inner.style.fontSize = "2vh";
            metric_menu_inner.style.opacity = 0;
            metric_menu_inner.style.cursor = "move";
            metric_menu_inner.id = "metric_menu_inner";
            metric_menu_inner.style.backgroundColor = "white";
            metric_menu_inner.style.border = "1.5vh solid white";
            metric_menu_inner.className = "text-center";
            metric_menu_inner.addEventListener("click", radioUpdate);

            // DIV for Collapse Menu
            var collapse_div1 = document.createElement("div");
            collapse_div1.id = "radios1";
            collapse_div1.className = "collapse collapseDiv";
            collapse_div1.setAttribute("data-parent", "#metric_menu_inner");
            collapse_div1.className = "text-center";
            collapse_div1.style.left = 0;
            collapse_div1.style.top = 0;
            //collapse_div1.style.backgroundColor = "var(--dark)";
            collapse_div1.style.width = "100%";

            // LC-MS title
            var new_title = document.createElement("button");
            new_title.style.fontSize = "2vh";
            new_title.style.letterSpacing = "0.4vh";
            new_title.style.fontWeight = 700;
            new_title.style.color = "var(--white)";
            new_title.style.marginBottom = "1em";
            new_title.style.padding = "0em";
            new_title.style.backgroundColor = "var(--dark)";
            new_title.className = "text-center btn btn-block";
            //var new_title = ButtonOffChart("LC-MS METRICS", "metricMenuDrop", function(){});
            //new_title.setAttribute("data-toggle", "collapse");
            //new_title.setAttribute("data-target", "radios1");
            //new_title.className = "btn btn-block btn-custom";
            new_title.setAttribute("type", "button");
            new_title.innerHTML = "LC-MS METRICS";

            // add drop down caret
            var new_caret = document.createElement("span");
            new_caret.style.padding = 0;
            new_caret.style.position = "absolute";
            new_caret.style.right = "1em";
            //new_caret.style.top = 0;
            //new_caret.style.fontSize = "1.5em";
            new_caret.className = "fas fa-caret-down";
            new_title.append(new_caret);
            //new_top_div.append(new_title);
            metric_menu_inner.append(new_title);

            /* LCMS radio buttons for metrics*/
            for(let i in machine_data.lcms_metrics){

                // get breach metrics
                try{
                    var breach_metrics = Object.keys(machine_data.run_data[run_index].summary);
                   
                    breach_metrics = breach_metrics.map(function(metric){
                        return metrics_obj_prot[metric];
                    })
                }
                catch{
                    var breach_metrics = [];
                }
                
                // create radio button and label
                var new_div = document.createElement("div");
                //new_div.className = "text-center";
                var new_label = document.createElement("label");
                new_label.className = "radio form-check-label";
                new_label.innerHTML = machine_data.lcms_metrics[i].display_name.replace("_", " ");
                var new_input = document.createElement("input");
                new_input.setAttribute("type", "radio");
                new_input.setAttribute("name", "radioOptions");
                new_input.className = "radio-box";

        
                // add breach marker
                if(breach_metrics.includes(machine_data.lcms_metrics[i].display_name)){
                   var new_marker = document.createElement("span");
                   new_marker.style.padding = 0;
                   new_marker.style.position = "absolute";
                   new_marker.style.right = 0;
                   new_marker.style.top = 0;
                   new_marker.style.opacity = 0;
                   //new_marker.style.fontSize = "1.5em";
                   new_marker.className = "fas fa-exclamation-triangle text-danger new_icon";
                   new_label.append(new_marker);
                }

                new_label.append(new_input);
                new_div.append(new_label);

                collapse_div1.append(new_div);
            };

            metric_menu_inner.append(collapse_div1);

            // DIV for Collapse Menu
            var collapse_div2 = document.createElement("div");
            collapse_div2.id = "radios2";
            collapse_div2.className = "collapse collapseDiv";
            collapse_div2.setAttribute("data-parent", "#metric_menu_inner");

            // MS2 title
            var new_title_ms2 = document.createElement("button");
            new_title_ms2.style.fontSize = "2vh";
            new_title_ms2.style.letterSpacing = "0.4vh";
            new_title_ms2.style.fontWeight = 700;
            new_title_ms2.style.color = "var(--white)";
            new_title_ms2.style.marginBottom = "1em";
            new_title_ms2.style.marginTop = "1em";
            new_title_ms2.style.padding = "0em";
            new_title_ms2.style.backgroundColor = "var(--dark)";
            new_title_ms2.className = "menuBorder text-center btn btn-block";
            new_title_ms2.setAttribute("data-toggle", "collapse");
            new_title_ms2.setAttribute("data-target", "radios2");
            new_title_ms2.setAttribute("type", "button");
            new_title_ms2.innerHTML = "MS2 METRICS";

            // add drop down caret
            var new_caret = document.createElement("span");
            new_caret.style.padding = 0;
            new_caret.style.position = "absolute";
            new_caret.style.right = "1em";
            //new_caret.style.top = 0;
            //new_caret.style.fontSize = "1.5em";
            new_caret.className = "fas fa-caret-down";
            new_title_ms2.append(new_caret);
            metric_menu_inner.append(new_title_ms2);

            /* MS2 radio buttons for metrics*/
            for(let i in machine_data.ms2_metrics){

                // create radio button and label
                var new_div = document.createElement("div");
                //new_div.className = "text-center";
                var new_label = document.createElement("label");
                new_label.className = "radio form-check-label";
                new_label.innerHTML = metrics_obj_prot[machine_data.ms2_metrics[i].display_name];
                var new_input = document.createElement("input");
                new_input.setAttribute("type", "radio");
                new_input.setAttribute("name", "radioOptions");
                new_input.className = "radio-box ms2";


                // add breach marker
                if(breach_metrics.includes(metrics_obj_prot[machine_data.ms2_metrics[i].display_name])){
                    var new_marker = document.createElement("span");
                    new_marker.style.padding = 0;
                    new_marker.style.position = "absolute";
                    new_marker.style.right = 0;
                    new_marker.style.top = 0;
                    new_marker.style.opacity = 0;
                    //new_marker.style.fontSize = "1.5em";
                    new_marker.className = "fas fa-exclamation-triangle text-danger new_icon";
                    new_label.append(new_marker);
                }

                new_label.append(new_input);
                new_div.append(new_label);

                collapse_div2.append(new_div);
            };

            
            metric_menu_inner.append(collapse_div2);

            // Pressure metrics for thermo machines
            if(machine_data.machine_details.machine_type == "thermo"){

                // DIV for Collapse Menu
                var collapse_div3 = document.createElement("div");
                collapse_div3.id = "radios3";
                collapse_div3.className = "collapse collapseDiv";
                collapse_div3.setAttribute("data-parent", "#metric_menu_inner");

                // Loading Pump title
                var new_title = document.createElement("button");
                new_title.style.fontSize = "2vh";
                new_title.style.letterSpacing = "0.4vh";
                new_title.style.fontWeight = 700;
                new_title.style.color = "var(--white)";
                new_title.style.marginBottom = "1em";
                new_title.style.marginTop = "1em";
                new_title.style.padding = "0em";
                new_title.style.backgroundColor = "var(--dark)";
                new_title.className = "menuBorder text-center btn btn-block";
                new_title.setAttribute("data-toggle", "collapse");
                new_title.setAttribute("data-target", "radios3");
                new_title.setAttribute("type", "button");
                new_title.innerHTML = "LOADING PUMP";

                // add drop down caret
                var new_caret = document.createElement("span");
                new_caret.style.padding = 0;
                new_caret.style.position = "absolute";
                new_caret.style.right = "1em";
                //new_caret.style.top = 0;
                //new_caret.style.fontSize = "1.5em";
                new_caret.className = "fas fa-caret-down";
                new_title.append(new_caret);
                metric_menu_inner.append(new_title);

                // loading pump metrics
                for(metric in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[metric].metric_description == "loading pump"){
                        // create radio button and label
                        var new_div = document.createElement("div");
                        //new_div.className = "text-center";
                        var new_label = document.createElement("label");
                        new_label.className = "radio form-check-label";
                        new_label.innerHTML = machine_data.pressure_metrics[metric].display_name;
                        var new_input = document.createElement("input");
                        new_input.setAttribute("type", "radio");
                        new_input.setAttribute("name", "radioOptions");
                        new_input.className = "radio-box pressure lp";

                        new_label.append(new_input);
                        new_div.append(new_label);
                        collapse_div3.append(new_div);
                    }
                }

                metric_menu_inner.append(collapse_div3);

                // DIV for Collapse Menu
                var collapse_div4 = document.createElement("div");
                collapse_div4.id = "radios4";
                collapse_div4.className = "collapse collapseDiv";
                collapse_div4.setAttribute("data-parent", "#metric_menu_inner");

                // Nano Pump title
                var new_title = document.createElement("button");
                new_title.style.fontSize = "2vh";
                new_title.style.letterSpacing = "0.4vh";
                new_title.style.fontWeight = 700;
                new_title.style.color = "var(--white)";
                new_title.style.marginBottom = "1em";
                new_title.style.marginTop = "1em";
                new_title.style.padding = "0em";
                new_title.style.backgroundColor = "var(--dark)";
                new_title.className = "menuBorder text-center btn-block";
                new_title.setAttribute("data-toggle", "collapse");
                new_title.setAttribute("type", "button");
                new_title.setAttribute("data-target", "radios4");
                new_title.innerHTML = "NANO PUMP";

                // add drop down caret
                var new_caret = document.createElement("span");
                new_caret.style.padding = 0;
                new_caret.style.position = "absolute";
                new_caret.style.right = "1em";
                //new_caret.style.top = 0;
                //new_caret.style.fontSize = "1.5em";
                new_caret.className = "fas fa-caret-down";
                new_title.append(new_caret);
                metric_menu_inner.append(new_title);

                // nano pump metrics
                for(metric in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[metric].metric_description == "nano pump"){
                        // create radio button and label
                        var new_div = document.createElement("div");
                        //new_div.className = "text-center";
                        var new_label = document.createElement("label");
                        new_label.className = "radio form-check-label";
                        new_label.innerHTML = machine_data.pressure_metrics[metric].display_name;
                        var new_input = document.createElement("input");
                        new_input.setAttribute("type", "radio");
                        new_input.setAttribute("name", "radioOptions");
                        new_input.className = "radio-box pressure np";

                        new_label.append(new_input);
                        new_div.append(new_label);
                        collapse_div4.append(new_div);
                    }
                }

                metric_menu_inner.append(collapse_div4);
            }

            metric_menu_div.append(metric_menu_inner);

            // check the display metric radio button
            var radios = document.getElementsByName("radioOptions");
            for(let i =0; i<radios.length; i++){
                // match name to display_name from DB (watch this), could use obj
                // come from summary page without (), test all metrics with proteomics
                var menu_metric = radios[i].labels[0].innerText.replace(")", "").replace("(", "").toUpperCase(); 
                // disable normalised if box
                if(chart_type == "box"){
                    if(menu_metric == "AREA NORMALISED" || menu_metric == "HEIGHT NORMALISED"){
                        radios[i].disabled = true;
                    }
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    if(radios[i].classList.contains("ms2")){
                        radios[i].disabled = true;
                    }
                } // disable heat
                else if(chart_type == "heat"){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else if(radios[i].classList.contains("ms2")){
                        radios[i].disabled = true;
                    }
                    else if(menu_metric == "RETENTION TIME" || menu_metric == "FULL WIDTH HALF MAXIMUM"){
                        radios[i].disabled = true;
                    }
                }
                else if(chart_type == "stream"){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else if(menu_metric == "PRECURSOR MASS ERROR"){
                        radios[i].disabled = true;
                    }
                }
                else if(chart_type == "parallel"){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                }
                // check display metric
                if(menu_metric == display_metric.replace(")", "").replace("(", "").toUpperCase()){
                    radios[i].checked = true;
                }
            }

            // handle collapse menu (show all first)
            document.getElementById("radios1").className = "collapse show collapseDiv";
            document.getElementById("radios2").className = "collapse show collapseDiv";
            if(machine_data.machine_details.machine_type == "thermo"){
                document.getElementById("radios3").className = "collapse show collapseDiv";
                document.getElementById("radios4").className = "collapse show collapseDiv";
            }
            
            // then collapse by menu state 
            for(let header in menu_state){
                if(!menu_state[header]){
                    if(header == "lcms"){
                        document.getElementById("radios1").classList.remove("show");
                    }
                    else if(header == "ms2"){
                        document.getElementById("radios2").classList.remove("show");
                    }
                    else if(header == "loading"){
                        if(machine_data.machine_details.machine_type == "thermo"){
                        document.getElementById("radios3").classList.remove("show");
                        }
                    }
                    else if(header == "nano"){
                        if(machine_data.machine_details.machine_type == "thermo"){
                        document.getElementById("radios4").classList.remove("show");
                        }
                    }
                }
            }

            // transition on load
            var t = d3.transition().duration(1500);
            if(transition){
                // transition any new icons
                d3.selectAll(".new_icon").transition(t).style("opacity", 1);
                d3.select("#metric_menu_inner").transition(t).style("opacity", 1);
            }
            else{
                document.getElementById("metric_menu_inner").style.opacity =1;
                // transition any new icons
                d3.selectAll(".new_icon").transition(t).style("opacity", 1);
            }
        }

        function draw_box_plot(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Box Plot";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // get y-axis extents and data
            var y_max = -Infinity;
            var y_min = Infinity;
            var IQR = -Infinity;
            var all_boxes = [];
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){

                    var new_obj = {};
                    new_obj["mean"] = machine_data.components[i].stats[display_metric].mean;
                    new_obj["std"] = machine_data.components[i].stats[display_metric].std;
                    new_obj["min"] = machine_data.components[i].stats[display_metric].min;
                    new_obj["25_percent"] = machine_data.components[i].stats[display_metric]["25_percent"];
                    new_obj["50_percent"] = machine_data.components[i].stats[display_metric]["50_percent"];
                    new_obj["75_percent"] = machine_data.components[i].stats[display_metric]["75_percent"];
                    new_obj["max"] = machine_data.components[i].stats[display_metric].max;
                    new_obj["mode"] = machine_data.components[i].component_mode;
                    new_obj["index"] = parseInt(i);
                    new_obj["colour"] = machine_data.components[i].colour;
                    new_obj["name"] = machine_data.components[i].component_name;
                    new_obj["current"] = machine_data.components[i].lcms_metrics[display_metric].values[run_index];
                    new_obj["missing"] = machine_data.components[i].lcms_metrics[display_metric].missing;
                    // y range
                    if(new_obj["25_percent"] < y_min){
                        y_min = new_obj["25_percent"];
                    }
                    if(new_obj["75_percent"] > y_max){
                        y_max = new_obj["75_percent"];
                    }
                    // IQR
                    if((new_obj["75_percent"] - new_obj["25_percent"]) > IQR){
                        IQR = new_obj["75_percent"] - new_obj["25_percent"]; 
                    }
                    all_boxes.push(new_obj); 
                }
            }

            // set the dimensions and margins of the plot
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight+2*v_height_unit, 
                          left: 4*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            
            // boxwidth
            var box_padding = v_width_unit;
            if(component_indexes.length > 3){
                 box_width = (width - (box_padding*(component_indexes.length)+ box_padding))/component_indexes.length;
            }
            else{
                box_width = width/4;
            }
            box_area_height = plot_height - margin.top - margin.bottom;

            /*
            // sort by median
            all_boxes = all_boxes.sort(function(a, b) {
               return a["50_percent"] > b["50_percent"] ? -1 : 1;
            });
        
            // sort polarity (pos first)
            all_boxes = all_boxes.sort(function(a, b){
                return a["mode"] < b["mode"]? -1 : 1;}
                ) ;
            */

            // sort by current
            all_boxes = all_boxes.sort(function(a, b) {
               return a["current"] > b["current"] ? -1 : 1;
            });

            // names for x scale
            var names = all_boxes.map(function(obj){
                return obj.name;
            });

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFillUpper = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradupper')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillUpper.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            gradFillUpper.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            var gradFillLower = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradlower')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillLower.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            gradFillLower.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            // circle gradient fills
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("cursor", "crosshair")
                .attr("id", "backBox")
                .attr("width", width)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0)
                .on("dblclick", function(){
                    moveBoxes(true);
                })
            // x scale
            xScale_box = d3.scaleBand()
                .range([0, width])
                .domain(names)
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // x-axis 
            //var x_axis = d3.axisBottom().scale(xScale_box).tickValues([]).tickSizeOuter(0);

            // x-axis-call
            //var x_axis_call = svg.append("g")
            //.attr("transform", "translate(0," + (box_area_height-1) + ")") // -1 else hides axis
            //.attr("class", "axis-chart")
            //.call(x_axis);// x scale

            // y-scale
            // set at outlier limit
            //var IQR = y_max - y_min;
            y_min = y_min - IQR;
            y_max = y_max + IQR;
            // no less than zero for time metrics
            if(display_metric != "Mass Error (ppm)" && display_metric != "Mass Error (mDa)"){
                if(y_min < 0){
                    y_min = 0;
                }
            }

            // cap 
            if(display_metric == "Mass Error (ppm)"){
                if(component_indexes.length > 3){
                    y_min = - 6;
                    y_max = 6;
                }
            }
            else if(display_metric == "Tailing" || display_metric == "Asymmetry"){
                if(component_indexes.length > 3){
                        y_min = 0;
                        y_max = 4;
                }
            }
            
            // yscale and domains
            if(yScale_box == null){
                yScale_box = d3.scaleLinear()
                    .domain([y_min , y_max])
                    .range([box_area_height, 0]);
            }
            var yScale_box_reset = yScale_box.domain();

            // y-axis
            var y_axis = d3.axisLeft().scale(yScale_box)
            .tickSize(v_height_unit).tickSizeOuter(0);
            
            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale_box).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', function(){
                if(theme == "dark"){return "gridlines axis-grid-dark";}
                return "gridlines axis-grid-light";
            })
            .call(yAxisGrid);

            // add threshold markers
            var thresholds = getThresholds();
            if(Object.keys(thresholds).length > 0){
                // lower thresh
                if(thresholds.threshold_low != ""){
                    svg.append("line")
                    .attr("id", "thresh_low")
                    .attr("x1", 0)
                    .attr("y1", yScale_box(thresholds.threshold_low))
                    .attr("x2", width)
                    .attr("y2", yScale_box(thresholds.threshold_low))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_low = 0;
                }

                // upper thresh
                if(thresholds.threshold_high != ""){
                    svg.append("line")
                    .attr("id", "thresh_high")
                    .attr("x1", 0)
                    .attr("y1", yScale_box(thresholds.threshold_high))
                    .attr("x2", width)
                    .attr("y2", yScale_box(thresholds.threshold_high))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_high = box_area_height;
                }

                // rect overlay (top)
                svg.append("g")
                .append("rect")
                .attr("class", "topoverlay")
                .attr("width", width)
                .attr("height", function(){
                    var check_height = yScale_box(thresholds.threshold_high);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",0)
                .style("opacity",0.5)
                .attr("fill", function(){
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                    //return 'url(#gradupper)';
                });
                

                // rect overlay (bottom)
                if(thresholds.threshold_low != 0){
                    svg.append("g")
                    .append("rect")
                    .attr("class", "bottomoverlay")
                    .attr("width", width)
                    .attr("height", function(){
                        var check_height = box_area_height - yScale_box(thresholds.threshold_low);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",yScale_box(thresholds.threshold_low))
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradlower)';
                    });
                }
            }

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label boxText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (box_area_height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(y_labels[display_metric].toUpperCase());

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            }
            );

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric boxText")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // optimal line
            var optimals = ["Mass Error (ppm)", "Mass Error (mDa)", "Tailing", "Asymmetry"];
            if(optimals.includes(display_metric)){
                if(display_metric == "Mass Error (ppm)" || display_metric == "Mass Error (mDa)"){
                    var marker = 0;
                }
                else{
                    var marker = 1;
                }
                svg
                .append("line")
                .attr("id", "optimal_marker")
                .attr("x1", 0)
                .attr("y1", yScale_box(marker))
                .attr("x2", width)
                .attr("y2", yScale_box(marker))
                .attr("stroke", "var(--dark)")
                .attr("stroke-width", 2*base_line_width)
                .attr("opacity", 0); // bloceked atm
            }

            // add the boxes
            svg
            .selectAll("boxes")
            .data(all_boxes)
            .enter()
            .append("rect")
                .attr("x", function(d){return(xScale_box(d.name)- box_width/2)})
                .attr("y", function(d){return(yScale_box(d["75_percent"]))})
                .attr("height", function(d){return(yScale_box(d["25_percent"])-yScale_box(d["75_percent"]))})
                .attr("width", box_width)
                .attr("stroke", function(d){return(d.colour)})
                .attr("stroke-width", lineWidth)
                .attr("filter", "url(#specular)")
                .style("fill", function(d){
                    return 'url(#circleGradLight'+d.index+')';//d.colour
                })
                .style("fill-opacity", 0.5)
                .style("opacity", 0.8)
                .attr("id", function(d, i){return "rect"+d.index})
                .attr("class", "box")
                .attr("cursor", "pointer")
                .on("mouseover", function(event, d){
                    // tooltip
                    var tooltip = d3.select("#tooltip");
                    var tooltipHTML = "<strong>" + d.name + "</strong><br>" +
                                    "<strong>Q1 </strong>" + d["25_percent"].toFixed(3) + "<br>" +
                                    "<strong>Q3 </strong>" + d["75_percent"].toFixed(3) + "<br>" +
                                    "<strong>Median </strong>" + d["50_percent"].toFixed(3) + "<br>" +
                                    "<strong>Mean </strong>" + d["mean"].toFixed(3);
                                        
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+30) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                    // highlight
                    highlightBox(d.index, 0.1);
                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                    resetHighlight();
                })
                .on("click", function(event, d){
                    
                    // expand
                    if(d.index != boxExpand){
                        // get new extents
                        var newMinY = d["25_percent"];
                        var newMaxY = d["75_percent"];
                        var current = d.current;
                        if(current > newMaxY){newMaxY = current;}
                        if(current < newMinY){newMinY = current;}

                        // offset
                        var boxRange = newMaxY - newMinY;
                        newMaxY = newMaxY + boxRange/4;
                        newMinY = newMinY - boxRange/4;

                        // change and store domain
                        yScale_box.domain([newMinY, newMaxY]);
                        boxExpand = d.index;

                        // highlight
                        //highlightBox(d.index, 0.3);
                    }
                    else{
                        // contract
                        yScale_box.domain(yScale_box_reset);
                        boxExpand = -1;
                        //resetHighlight();
                    }
                    resetHighlight();

                    y_axis_call.transition().duration(1000).call(y_axis);
                    moveBoxes(false);

                });

            // medians
            svg
            .selectAll("medianLines")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
            .attr("y2", function(d){return(yScale_box(d["50_percent"]))})
            .attr("stroke", function(d){return(d.colour)})
            .attr("stroke-width", lineWidth)
            .attr("class", function(d){return "boxline boxline" + d.index});

             // means
             svg
            .selectAll("meanLines")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["mean"]))})
            .attr("y2", function(d){return(yScale_box(d["mean"]))})
            .attr("stroke", function(d){return(d.colour)})
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 0) // blocekd atm
            .attr("class", function(d){return "boxline boxline" + d.index})
            .style("stroke-dasharray", ("0.5vh, 0.5vh"));

            // extenders
            svg
            .selectAll("extenders")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name))})
            .attr("x2", function(d){return(xScale_box(d.name))})
            .attr("y1", function(d){
                var y1;
                if(d.current >= d["75_percent"]){
                    y1 = yScale_box(d.current);
                }
                else if(d.current <= d["25_percent"]){
                    y1 = yScale_box(d["25_percent"]);
                }
                else{
                    y1 =  yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y1 < 0){
                    return 0;
                }
                */
                return y1;
                
            })
            .attr("y2", function(d){
                var y2;
                if(d.current >= d["75_percent"]){
                    y2 = yScale_box(d["75_percent"]);
                }
                else if(d.current <= d["25_percent"]){
                    y2 = yScale_box(d.current);
                }
                else{
                    y2 = yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y2 > box_area_height){
                    return box_area_height;
                }
                */
                return y2;
                
            })
            .attr("stroke", function(d){return d.colour})
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", lineWidth)
            .attr("class", function(d){return "extender extender" + d.index});

            // current run
            svg
            .selectAll("currentRun")
            .data(all_boxes)
            .enter()
            .append("circle")
            .attr("cx", d => xScale_box(d.name))
            .attr("cy", function(d){
                    return yScale_box(d.current)
                })
            .attr("r", currentRadius)
            .attr("x", function(d, i) {return xScale_box(d.name)})
            .attr("y", function(d){
                    return yScale_box(d.current)
                })
            .attr("stroke", function(d, i) {return d.colour})
            .attr("stroke-width", lineWidth/2)
            .attr("stroke-opacity", 0.5)
            .attr("cursor", "pointer")
            .attr("filter", "url(#specular)")
            .attr("class","point")
            .attr("id",  function(d, i) {return "circle" + d.index})
            .attr("fill", function(d,j){
                var miss = d.missing;
                if(miss.includes(run_index)){
                    return "var(--dark)";
                }
                else{
                    return d.colour;// 'url(#circleGradLight'+d.index+')' ;   
                }
            })
            .on("mouseover", function(event, d){ // tooltip on hover

                var tooltip = d3.select("#tooltip");
                var miss = d.missing;
                if(miss.includes(run_index)){
                    var tooltipHTML = "<strong>" + d.name.replace("_", " ") + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        "NO VALUE" + "</strong>";
                } else{
                    var tooltipHTML = "<strong>" +  d.name.replace("_", " ")  + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        Number.parseFloat(d.current).toFixed(3) + "</strong>";
                }

                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX + 30) + 'px');
                tooltip.style('top', (event.pageY + 30) + 'px');
                tooltip.style("visibility", "visible");

                // highlight
                highlightBox(d.index, 0.1);

            })
            .on("mouseout", function(){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                resetHighlight();
                
            })
            .on("click", function(event, d){
                comp_index = d.index;
                draw_chromatogram(true);
            })

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .call(y_axis)
            .attr("id", "yAxisLine")
            .style('font-size', '1.8vh');

            function highlightBox(dIndex, opac){
                d3.selectAll(".box").style("opacity", opac);
                d3.select("#rect"+dIndex).style("opacity", 1);
                //d3.select("#rect"+boxExpand).style("opacity", 1);

                d3.selectAll(".point").style("opacity", opac);
                d3.select("#circle"+dIndex).style("opacity", 1);
                //d3.select("#circle"+boxExpand).style("opacity", 1);

                d3.selectAll(".boxline").style("opacity", opac);
                d3.selectAll(".boxline"+dIndex).style("opacity", 1);
                //d3.selectAll(".boxline"+boxExpand).style("opacity", 1);
                
                d3.selectAll(".extender").style("opacity", opac);
                d3.selectAll(".extender"+dIndex).style("opacity", 1);
                //d3.selectAll(".extender"+boxExpand).style("opacity", 1);
            }

            function resetHighlight(){
                d3.selectAll(".box").style("opacity", 0.8);
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".boxline").style("opacity", 1);
                d3.selectAll(".extender").style("opacity", 1); 
            }
            
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".box").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".boxline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".extender").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".boxText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            
        }

        function getComponentIndexes(){
            // get indexes of checked components
            var component_indexes = [];
            d3.selectAll(".positive").each(function(d,i){
                if(checked_components[d.component_name]){
                    component_indexes.push(d.c_index+"");
                }
            });
            return component_indexes;
        }

        function draw_line_chart(transition){ 
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // function vars
            var currentMaxY;
            var currentMinY;

            // set the dimensions and margins of the plot
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            plot_area.style.opacity = 1;

            // get indexes of checked components
            var component_indexes = getComponentIndexes();
    
            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Line Chart";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // get y-axis extents (or cap)
            var y_max = -Infinity;
            var y_min = Infinity;
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var new_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    var new_min = d3.min(new_values);
                    var new_max = d3.max(new_values);
                    if(new_max > y_max){
                        y_max = new_max;
                    }
                    if(new_min < y_min){
                        y_min = new_min;
                    }
                }
            }

            //cap
            if(display_metric == "Mass Error (ppm)"){
                if(component_indexes.length > 4){
                    y_min = - 5;
                    y_max = 5;
                }
            }
            else if(display_metric == "Tailing" || display_metric == "Asymmetry"){
                if(component_indexes.length > 4){
                    y_min = 0;
                    y_max = 3;
                }
            }
            else if(display_metric == "Full Width Half Maximum"){
                if(component_indexes.length > 4){
                    y_min = 0;
                    y_max = 30;
                }
            }

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFillUpper = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradupper')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFillUpper.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            gradFillUpper.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            var gradFillLower = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradlower')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillLower.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            gradFillLower.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            // circle gradient fills
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('radialGradient')
                .attr('id', 'circleGradLightRad' + component_indexes[i])
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // radius and line-width scale for zoom (NOT USED)
            var minR = base_radius;
            var maxR = 3*base_radius;
            var minL = base_line_width;
            var maxL = 3*base_line_width;
            var lowX = machine_data.run_data[machine_data.run_data.length-1].date_time;
            var hiX = machine_data.run_data[0].date_time;
            var maxX = hiX - lowX;
            var radiusScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxR, minR]);
            var lineScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxL, minL]);

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // offsets and extents (allow for circles) 
            var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            // store/use yScale/xScale
            for(let i in machine_data.lcms_metrics){
                if(machine_data.lcms_metrics[i].display_name == display_metric){
                    // store and set yScale
                    if(machine_data.lcms_metrics[i].yScale == null){
                        yScale_chart = d3.scaleLinear()
                        .domain([y_min - offsetY, y_max + offsetY])
                        .range([height, 0]);
                        machine_data.lcms_metrics[i].yScale = yScale_chart;
                    }
                    else{
                        yScale_chart = machine_data.lcms_metrics[i].yScale;
                    }

                    // set radius
                    if(machine_data.lcms_metrics[i].radius !== null){
                        //radius = machine_data.lcms_metrics[i].radius;
                        radius = base_radius;
                    }
                    else{
                        radius = base_radius;
                    }
                    // set lineWidth
                    if(machine_data.lcms_metrics[i].lineWidth !== null){
                        //lineWidth = machine_data.lcms_metrics[i].lineWidth;
                        lineWidth = base_line_width;
                    }
                    else{
                        lineWidth = base_line_width;
                    }
                    break;
                }
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }
                
            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale_chart)
            .tickSize(v_height_unit).tickSizeOuter(0);
        

            // ylabel left (units)
            svg.append("text")
            .attr("class", "label lineText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(y_labels[display_metric].toUpperCase());

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("id", "chartExpandHeader")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            /*ZOOM*/
            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip3") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // brushing
            var brush = d3.brush()                   
                .extent([[0,0], [lineChartWidth,height]]) 
                .on("end", updateZoom);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clip3)")
                .attr("id", "all_lines");
            
            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_chart(d.y)});
            
            // add threshold markers
            var thresholds = getThresholds();
            var overlay = false;
            if(Object.keys(thresholds).length > 0){
                overlay = true;
                // lower thresh
                if(thresholds.threshold_low != ""){
                    all_lines.append("line")
                    .attr("id", "thresh_low")
                    .attr("x1", xScale_chart(d3.min(x_values_chart)))
                    .attr("y1", yScale_chart(thresholds.threshold_low))
                    .attr("x2", xScale_chart(d3.max(x_values_chart)))
                    .attr("y2", yScale_chart(thresholds.threshold_low))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_low = 0;
                }

                // upper thresh
                if(thresholds.threshold_high != ""){
                    all_lines.append("line")
                    .attr("id", "thresh_high")
                    .attr("x1", xScale_chart(d3.min(x_values_chart)))
                    .attr("y1", yScale_chart(thresholds.threshold_high))
                    .attr("x2", xScale_chart(d3.max(x_values_chart)))
                    .attr("y2", yScale_chart(thresholds.threshold_high))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                    
                }
                else{
                    thresholds.threshold_high = height;
                }
            
                // rect overlay (top)
                if(display_metric != "Area (normalised)"){ // no top for area
                    all_lines.append("g")
                    .append("rect")
                    .attr("class", "topoverlay")
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch neg heights
                        var check_height = yScale_chart(thresholds.threshold_high);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",0)
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradupper)';
                    });
                }

                // rect overlay (bottom)
                if(thresholds.threshold_low != 0){
                    all_lines.append("g")
                    .append("rect")
                    .attr("class", "bottomoverlay")
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch neg heights
                        var check_height = yScale_chart(thresholds.threshold_low);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",yScale_chart(thresholds.threshold_low))
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradlower)';
                    });
                    
                }
            }

            // Add the brushing (first for line point hover events to work)
            // https://github.com/d3/d3/issues/1604
            all_lines
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // add vertical marker
           all_lines.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 1)
            .attr("cursor", "pointer")
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .on("mouseover", function(event){ // highlight on hover
                d3.selectAll(".point").style("opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 0.05;
                });
                d3.selectAll(".chartline").style("opacity", 0.1);
                
            })
            .on("mouseout", function(event){ 
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".chartline").style("opacity", 1);
            })
            .on("click", function(event){
                // hide tooltip (else sticky)
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                if(component_indexes.length > 1){
                    offsetY = (8*currentRadius/height)*(currentMaxY-currentMinY);
                    yScale_chart.domain([currentMinY - offsetY, currentMaxY + offsetY]);
                    reDrawChart();
                }
            });

            // add line (per component)
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j < x_values_chart.length; j++){

                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }

                    // line
                    all_lines.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("class", "chartline chartline"+i) // used to redraw for zoom
                    .attr("stroke", machine_data.components[i].colour) 
                    .attr("stroke-width", lineWidth)
                    .attr("stroke-opacity", 0.3)
                    .attr("cursor", "pointer")
                    .on("mouseover", function(event, d){ // highlight on hover

                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;

                        // text location boundaries
                        var x = event.layerX;
                        var y = event.layerY;
                        var anchor = "middle"; 
                        if(x >= lineChartWidth -100){
                            x = lineChartWidth - 200;
                            anchor = "start";
                        };
                        if(x <= 150){
                            x = x + 150;
                        }
                        if(y >= height -100){
                            y = height - 100;
                        }

                        // highlight
                        d3.selectAll(".chartline").style("opacity", 0.1);
                        d3.select(this).style("opacity", 1);
                        d3.select(this).style("stroke-opacity", 0.5);
                        d3.selectAll(".point").style("opacity", 0.05);
                        d3.selectAll(".point"+i).style("opacity", 1);

                        // add text
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", "1em")
                        .attr("font-size", "1em")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .style("text-anchor", anchor)
                        .style("text-shadow", "0.1vh 0.1vh gray")
                        .text(machine_data.components[i].component_name.replace("_", " "));
                        
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".chartline").style("opacity", 1);
                        d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                        d3.selectAll(".point").style("opacity", 1);
                        d3.select(".hover-text").remove();
                    })
                    .on("click", function(event, d){
                        // hide tooltip (else sticky)
                        var tooltip = d3.select("#tooltip");
                        tooltip.style("visibility", "hidden");
                        // redraw on own yscale
                        var compData = d.slice(0, filter);
                        var newMaxY = d3.max(compData, d =>d.y);
                        var newMinY = d3.min(compData, d => d.y);

                        offsetY = (8*currentRadius/height)*(newMaxY-newMinY);
                        yScale_chart.domain([newMinY - offsetY, newMaxY + offsetY]);
                        reDrawChart();
                        
                    })
                    .attr("d", line);
                }
            }

            // add points per date (so can be raised and ordered)
            for(let j = x_values_chart.length-1; j>=0; j--){
                var data = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                        // convert to d3 friendly format
                        
                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j, 'comp': i};
                        data.push(new_row);
                    }
                }

                // order for display
                data = data.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});

                // store curent extents
                if(j == run_index){
                    currentMaxY = d3.max(data, d=>d.y);
                    currentMinY = d3.min(data, d=>d.y);
                }

                // points
                all_lines.append("g").attr("id", "g"+j)
                .selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => xScale_chart(d.x))
                .attr("cy", d => yScale_chart(d.y))
                .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
                })
                .attr("filter", function(d){
                    if(d.index == run_index){
                    return "url(#specular)";
                    }
                })
                .attr("stroke", d => machine_data.components[d.comp].colour)
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", function(d, i){
                    if(run_index==d.index){
                        return 0.5;
                    }
                    return 0.5;
                })
                .attr("class",d => "point point" + d.comp + " circle"+d.index) // circle for scale change
                .attr("cursor", "pointer")
                .attr("fill-opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 1;
                })
                .attr("fill", function(d,k){
                    var miss = machine_data.components[d.comp].lcms_metrics[display_metric].missing;
                    if(miss.includes(d.index)){
                        return "var(--dark)";
                    }else{
                        if(run_index == d.index){
                            return machine_data.components[d.comp].colour;//'url(#circleGradLight'+d.comp+')'; //machine_data.components[d.comp].colour;
                        }
                        if(theme == "dark") {
                            return 'url(#circleGradLight'+d.comp+')';
                        }
                        return 'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                .on("mouseover", function(event, d){
                    // // machine_data.run_data[d.index].date_time
                    var tooltip = d3.select("#tooltip");
                    var miss = machine_data.components[d.comp].lcms_metrics[display_metric].missing;
                    if(miss.includes(d.index)){
                        var tooltipHTML = "<strong>" + machine_data.components[d.comp].component_name.replace("_", " ") + 
                                        "</strong><br>" + machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            "NO VALUE" + "</strong>";
                    } else{
                        var tooltipHTML = "<strong>" + machine_data.components[d.comp].component_name.replace("_", " ") + 
                                        "</strong><br>" + machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            Number.parseFloat(d.y).toFixed(3) + "</strong>";
                    }
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");

                    // highlight
                    d3.selectAll(".chartline").style("opacity", 0.1);
                    d3.selectAll(".point").style("opacity", function(f, i){
                        if(f.index == d.index){
                            return 1;
                        }
                        return 0.05;
                    });

                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                    d3.selectAll(".chartline").style("opacity", 1);
                    d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                    d3.selectAll(".point").style("opacity", 1);
                })
                .on("click", function(event, d){
                    // hide tooltip (else sticky)
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");

                    if(run_index == d.index){
                        comp_index = d.comp;
                        draw_chromatogram(true);
                        return;
                    }

                    // update run index
                    run_index = d.index;
                    
                    // move and redraw
                    updateMarker();

                    setTimeout(function(){
                        draw_line_chart(false);
                    }, 1000)
                    
                    // pressure profiles
                    if(pressure_type == "loading"){
                        update_pressure_profile_loading();
                        pressure_type = "loading"; // reset because the back panel gets updated too
                    }else{
                        update_pressure_profile_nano();
                        pressure_type = "nano"; // reset because the back panel gets updated too
                    }
                    
                    // top controls
                    controlUpdate("chart");
                }).raise(); 
            }
            
            // raise current run
            d3.select("#g"+run_index).raise();

            // right 'axis'
            svg
            .append("line")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .attr('stroke', function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            }) // needs stroke .. stroke v color?
            .style('font-size', '1.8vh')
            .attr("id", "rightAxis")
            .style("opacity", 0) //hiding atm
            .attr("x1", lineChartWidth)
            .attr("y1", 0)
            .attr("x2", lineChartWidth)
            .attr("y2", height);

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            //.style('fill-opacity', 0.5)
            .call(x_axis);
            

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis);
                
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".chartline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.select("#xAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.select("#marker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("rect").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.5);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statsMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            
            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateZoom(event) {
                zoom = true;
                
                // What are the selected boundaries?
                extent = event.selection;
                
                // If no selection just return
                if(!extent){
                    return;
                }else{
                    var x1 = xScale_chart.invert(extent[0][0]);
                    var x2 = xScale_chart.invert(extent[1][0]);
                    //radius = radiusScale(x2-x1);
                    //lineWidth = lineScale(x2-x1);
                    radius = base_radius;
                    lineWidth = base_line_width;
                   
                    xScale_chart.domain([xScale_chart.invert(extent[0][0]), xScale_chart.invert(extent[1][0])]);
                    yScale_chart.domain([yScale_chart.invert(extent[1][1]), yScale_chart.invert(extent[0][1])]);
                    all_lines.select(".brush").call(brush.move, null); // This removes the grey brush area 
                }
                
                reDrawChart();
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                // reset scales
                zoom = false;
                radius = base_radius;
                lineWidth = base_line_width;
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }
                yScale_chart.domain([y_min - offsetY, y_max + offsetY]);
                reDrawChart();
            });

            // used by update functions
            reDrawChart = function (){

                // axis and grid
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);

                // chart
                all_lines
                    .selectAll('.chartline')
                    .transition()
                    .duration(1000)
                    .attr("d", line);
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll('circle')
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_chart(d.y));
                    //.attr("stroke-width", lineWidth)
                    //.attr("r", radius);
                all_lines
                    .select("#marker")
                    .transition()
                    .duration(1000)
                    .attr("x1", xScale_chart(x_values_chart[run_index]))
                    .attr("x2", xScale_chart(x_values_chart[run_index]));
                    //.style("stroke-dasharray", ("3vh, 3vh, 3vh"))
                    //.attr("stroke-width", lineWidth);
                if(overlay){
                    all_lines
                        .select(".topoverlay")
                        .transition()
                        .duration(1000)
                        .attr("width", lineChartWidth)
                        .attr("height", function(){
                            // catch for negative heights
                            var check_height = yScale_chart(thresholds.threshold_high);
                            if(check_height < 0){
                                return 0;
                            }
                            return check_height;
                        })
                        .attr("x",0)
                        .attr("y",0);
                    all_lines
                        .select(".bottomoverlay")
                        .transition()
                        .duration(1000)
                        .attr("width", lineChartWidth)
                        .attr("height", function(){
                            // catch for negative heights
                            var check_height = height - yScale_chart(thresholds.threshold_low);
                            if(check_height < 0){
                                return 0;
                            }
                            return check_height;
                        })
                        .attr("x",0)
                        .attr("y",yScale_chart(thresholds.threshold_low));
                    all_lines
                        .select("#thresh_low")
                        .transition()
                        .duration(1000)
                        .attr("x1", xScale_chart(d3.min(x_values_chart)))
                        .attr("y1", yScale_chart(thresholds.threshold_low))
                        .attr("x2", xScale_chart(d3.max(x_values_chart)))
                        .attr("y2", yScale_chart(thresholds.threshold_low));
                        //.attr("stroke-width", lineWidth - 1);
                    all_lines
                        .select("#thresh_high")
                        .transition()
                        .duration(1000)
                        .attr("x1", xScale_chart(d3.min(x_values_chart)))
                        .attr("y1", yScale_chart(thresholds.threshold_high))
                        .attr("x2", xScale_chart(d3.max(x_values_chart)))
                        .attr("y2", yScale_chart(thresholds.threshold_high));
                        //.attr("stroke-width", lineWidth -1);
                }

                // store yScale/xScale
                for(let i in machine_data.lcms_metrics){
                    if(machine_data.lcms_metrics[i].display_name == display_metric){
                        machine_data.lcms_metrics[i].yScale = yScale_chart;  
                        //machine_data.lcms_metrics[i].xScale = xScale_chart;
                        machine_data.lcms_metrics[i].radius = radius;
                        machine_data.lcms_metrics[i].lineWidth = lineWidth;  
                        break;
                    }
                } 

            }
            
        }

        function draw_pressure_line(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot (NOTE: same as draw_line for x-axis and scale)
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;

            // store height for transition
            var height = plot_height - margin.top - margin.bottom;
            pressureHeight = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // y values and missing indexes
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var y_values = machine_data.pressure_metrics[i].values;
                    var missing = machine_data.pressure_metrics[i].missing;
                    var stats = machine_data.pressure_metrics[i].stats;
                    break;
                }
            };

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // radius and line-width scale for zoom (NOT USED)
            var minR = base_radius;
            var maxR = 3*base_radius;
            var minL = base_line_width;
            var maxL = 3*base_line_width;
            var lowX = machine_data.run_data[machine_data.run_data.length-1].date_time;
            var hiX = machine_data.run_data[0].date_time;
            var maxX = hiX - lowX;
            let radiusScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxR, minR]);
            let lineScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxL, minL]);

            var y_min = d3.min(y_values.slice(0, filter));
            var y_max = d3.max(y_values.slice(0, filter));

            // offsets and extents (allow for circles) 
            var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            // store/use yScale/xScale
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    // store and set yScale
                    if(machine_data.pressure_metrics[i].yScale == null){
                        yScale_pressure = d3.scaleLinear()
                        .domain([y_min - offsetY, y_max + offsetY])
                        .range([height, 0]);
                        machine_data.pressure_metrics[i].yScale = yScale_pressure;
                    }
                    else{
                        yScale_pressure = machine_data.pressure_metrics[i].yScale;
                    }
                    
                    // set radius (NOT STORING RESIZE NOW)
                    if(machine_data.pressure_metrics[i].radius !== null){
                        //radius = machine_data.pressure_metrics[i].radius;
                        radius = base_radius;
                    }
                    else{
                        radius = base_radius;
                    }
                    // set lineWidth
                    if(machine_data.pressure_metrics[i].lineWidth !== null){
                        //lineWidth = machine_data.pressure_metrics[i].lineWidth;
                        lineWidth = base_line_width;
                    }
                    else{
                        lineWidth = base_line_width;
                    }
                    break;
                }
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }
                
            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale_pressure)
            .tickSize(v_height_unit).tickSizeOuter(0);

            // ylabel
            var labelText = "BARS";
            if(display_metric == "Retention Time at Maximum Pressure"){
                labelText = "MINUTES";
            }

            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label pressureText")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(labelText);

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // handle too long name
            var metricDisplay = display_metric;
            if(metricDisplay == "Starting Backpressure (Average)"){
                metricDisplay = "Starting Backpressure";
            }
            else if(metricDisplay == "Starting Pressure (Median)"){
                metricDisplay = "Starting Pressure";
            }

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric pressureText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.pressure_metrics){
                        if(machine_data.pressure_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.pressure_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(metricDisplay.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = metricDisplay.toUpperCase();

            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip4") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // brushing
            var brush = d3.brush()                   
                .extent([[0,0], [lineChartWidth,height]])
                .on("end", updateZoom);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clip4)")
                .attr("id", "all_lines");
            
            // curved line
            line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_pressure(d.y)});

            // add brushing first (for events)
            all_lines
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // add vertical marker
           all_lines.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity" ,1)
            .on("mouseover", function(event, d){
                d3.selectAll(".point").style("opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 0.05;
                });
                d3.selectAll(".chartline").style("opacity", 0.1);
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".chartline").style("opacity", 1);
            });

            // convert to d3 friendly format
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }

            // getarray for stats (based on filter)
            var statsData = [];
            for(let i = filter-1; i>=0; i--){
                // stats data
                if(!(missing.includes(i))){
                    statsData.push(y_values[i]);
                }
            }

            // calculate stats
            statsArr = [{"name": "Mean", "value": calcAverage(statsData)}, 
                            {"name": "Median", "value": calcQuartile(statsData, 50)}, 
                            {"name": "Q1", "value": calcQuartile(statsData, 25)},
                            {"name": "Q3", "value": calcQuartile(statsData, 75)}];
            
            // sort to handle display offsets
            statsArr = statsArr.sort(function(a,b){ return parseFloat(a.value) - parseFloat(b.value);});

            // draw stats markers
            all_lines
            .selectAll("statsline")
            .data(statsArr)
            .enter()
            .append('line')
            .attr("class", "statsMarker")
            .attr("x1", 0)
            .attr("y1", function(d, i) {
                return yScale_pressure(d.value);
            })
            .attr("x2", 2*v_width_unit)
            .attr("y2", function(d, i) {
                return yScale_pressure(d.value);
            })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)"
            })
            .attr("stroke-opacity", 1)
            .attr("stroke-width", '0.4vh');

            // add stat name
            all_lines
            .selectAll("text")
            .data(statsArr)
            .enter()
            .append('text')
            .attr('class', 'statText')
            //.attr("filter", "url(#specular)")
            .attr("x", 2*v_width_unit)
            .attr("y", d => yScale_pressure(d.value))
            .attr("dy", function(d, i){
                if(i < 2){return 2*v_height_unit}
                return -v_height_unit;
            })
            .attr("dx", function(d, i){
                if(i % 2 == 0){return v_height_unit}
                return -2*v_height_unit;
            })
            .attr("opacity", 1)
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("text-anchor", "start")
            .style("letter-spacing", "0.3vh")
            .text(d => d.name.toUpperCase())
            .attr("font-size", "2.5vh")
            .on("mouseover", function(event, d){
                // highlight
                d3.selectAll(".statText").style("opacity", 0.05);
                d3.select(this).style("opacity",1);
                d3.selectAll(".statsMarker").style("stroke-opacity", function(e,i){
                    if(d.name == e.name){return 1;}
                    return 0.05;
                });
                d3.selectAll(".chartline").style("stroke-opacity", 0);
                

                // tooltip
                var tooltip = d3.select("#tooltip");
                var tooltipHTML = "<strong>" + d.name + "</strong></br>" + d.value.toFixed(2);
                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX+10) + 'px');
                tooltip.style('top', (event.pageY+10) + 'px');
                tooltip.style("visibility", "visible");
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".statText").style("opacity", 1);
                d3.selectAll(".statsMarker").style("stroke-opacity", 1);
                d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                d3.selectAll(".point").style("stroke-opacity", function(e, i){
                    if(run_index == e.index){
                        return 0.5;
                    }
                    return 0.5;
                });
                var tooltip = d3.select("#tooltip");
                tooltip.style('left', '0px');
                tooltip.style('top', '0px');
                d3.select("#tooltip").style("visibility", "hidden");
            })

            // line
            all_lines.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("class", "chartline") // used to redraw for zoom
            .attr("stroke", "lightskyblue")
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 0.3)
            .attr("d", line)
            .on("mouseover", function(event, d){
                // highlight
                //d3.select(this).style("stroke-opacity", 1);
                //d3.selectAll(".point").style("stroke-opacity", 1);
                d3.selectAll(".statText").style("opacity", 0.05);
                d3.selectAll(".statsMarker").style("stroke-opacity", 0.05);

            })
            .on("mouseout", function(event, d){
                d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                d3.selectAll(".point").style("stroke-opacity", function(e, i){
                    if(run_index == e.index){
                        return 0.5;
                    }
                    return 0.5;
                });
                d3.selectAll(".statText").style("opacity", 1);
                d3.selectAll(".statsMarker").style("stroke-opacity", 1);
            })

            // ADD points in loop so can raise
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                // points
                all_lines.append("g").attr("id", "g"+i)
                .selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => xScale_chart(d.x))
                .attr("cy", d => yScale_pressure(d.y))
                .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
                })
                .attr("x", function(d, i) {return xScale_chart(d.x)})
                .attr("y", function(d, i) {return yScale_pressure(d.y)})
                .attr("stroke", "lightskyblue")
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", function(d, i){
                    if(d.index == run_index){
                        return 0.5;
                    }
                    else{
                        return 0.5;
                    }
                })
                .attr("class","point circle"+i)
                .attr("fill-opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 1;
                })
                .attr("filter", "url(#specular)")
                .attr("fill", function(d,j){
                    if(missing.includes(j)){
                        return "var(--dark)";
                    }else{
                        return  "url(#chromFill)";
                    } 
                })
                .on("mouseover", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    if(missing.includes(d.index)){
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            "NO VALUE" + "</strong>";
                    } else{
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            Number.parseFloat(d.y).toFixed(3) + "</strong>";
                    }
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");

                    // highlight
                    //d3.select(".chartline").style("stroke-opacity", 1);
                    //d3.selectAll(".point").style("stroke-opacity", 1);
                })
                .on("mouseout", function(){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");

                    d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                    d3.selectAll(".point").style("stroke-opacity", function(d, i){
                        if(run_index == d.index){
                            return 0.5;
                        }
                        return 0.5;
                    });
                });
            }

            // raise current run
            d3.select("#g"+run_index).raise();

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            .call(x_axis);

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis);
            

            // transition by chart elements
            
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".chartline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".pressureText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statsMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            

            reDrawPressureChart = function(){
                // Update axis and line/point position etc
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);
        
                all_lines
                    .selectAll('.chartline')
                    .transition()
                    .duration(1000)
                    .attr("d", line);
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll('circle')
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_pressure(d.y));
                    //.attr("stroke-width", lineWidth)
                    //.attr("r", radius);
                all_lines
                    .select("#marker")
                    .transition()
                    .duration(1000)
                    .attr("x1", xScale_chart(x_values_chart[run_index]))
                    .attr("x2", xScale_chart(x_values_chart[run_index]));
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll(".statsMarker")
                    .data(statsArr)
                    .transition()
                    .duration(1000)
                    .attr("y1", function(d, i) {
                        return yScale_pressure(d.value);
                    })
                    .attr("y2", function(d, i) {
                        return yScale_pressure(d.value);
                    });
                all_lines   
                    .selectAll(".statText")
                    .data(statsArr)
                    .transition()
                    .duration(1000)
                    .attr("y", d => yScale_pressure(d.value))
                    .attr("dy", function(d, i){
                        if(i < 2){return 2*v_height_unit}
                        return -v_height_unit;
                    })
                    .attr("dx", function(d, i){
                        if(i % 2 == 0){return v_height_unit}
                        return -2*v_height_unit;
                    });

                // store yScale/xScale
                for(let i in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[i].display_name == display_metric){
                        machine_data.pressure_metrics[i].yScale = yScale_pressure;  
                        //machine_data.pressure_metrics[i].xScale = xScale_chart;
                        machine_data.pressure_metrics[i].radius = radius;
                        machine_data.pressure_metrics[i].lineWidth = lineWidth;  
                        break;
                    }
                }
            }

            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateZoom(event) {
                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    var x1 = xScale_chart.invert(extent[0][0]);
                    var x2 = xScale_chart.invert(extent[1][0]);
                    radius = radiusScale(x2-x1);
                    lineWidth = lineScale(x2-x1);

                    xScale_chart.domain([xScale_chart.invert(extent[0][0]), xScale_chart.invert(extent[1][0])])
                    yScale_pressure.domain([yScale_pressure.invert(extent[1][1]), yScale_pressure.invert(extent[0][1])])
                    all_lines.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                reDrawPressureChart();
                
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                radius = base_radius;
                lineWidth = base_line_width;
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }
                yScale_pressure.domain([y_min - offsetY, y_max + offsetY]);
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);
            
                reDrawPressureChart();
            });
        }

        function draw_ms2_line(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

             // set the dimensions and margins of the plot (NOTE: same as draw_line for x-axis and scale)
             var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            
            // store for transitions
            var height = plot_height - margin.top - margin.bottom;
            ms2Height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";

             /*** X VALUES ***/
             var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // y values and missing indexes
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name == display_metric){
                    var y_values = machine_data.ms2_metrics[i].values;
                    var metricColour = machine_data.ms2_metrics[i].colour;
                    var missing = machine_data.ms2_metrics[i].missing;
                    var stats = machine_data.ms2_metrics[i].stats;
                    var thresholds = machine_data.ms2_metrics[i].thresholds;
                    break;
                }
            }

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFillUpper = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradupper')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillUpper.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            gradFillUpper.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            var gradFillLower = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradlower')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillLower.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            gradFillLower.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // radius and line-width scale for zoom
            var minR = 3;
            var maxR = 8;
            var minL = 2;
            var maxL = 4;
            var lowX = machine_data.run_data[machine_data.run_data.length-1].date_time;
            var hiX = machine_data.run_data[0].date_time;
            var maxX = hiX - lowX;
            let radiusScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxR, minR]);
            let lineScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxL, minL]);

            
            // set y scale range to include IQR
            var maxY = d3.max(y_values.slice(0, filter));
            var minY = d3.min(y_values.slice(0, filter));

            //if(display_metric == "Precursor Mass Error"){
                //maxY = 6;
                //minY = -6;
            //}

            // offsets and extents (allow for circles) 
            var offsetY = (2*currentRadius/height)*(maxY-minY);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            // store/use yScale/xScale
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name == display_metric){
                    // store and set yScale
                    if(machine_data.ms2_metrics[i].yScale == null){
                        yScale_ms2 = d3.scaleLinear()
                        .domain([minY - offsetY, maxY + offsetY])
                        .range([height, 0]);
                        machine_data.ms2_metrics[i].yScale = yScale_ms2;
                    }
                    else{
                        yScale_ms2 = machine_data.ms2_metrics[i].yScale;
                    }
                    break;
                }
            }

             /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

             /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }

            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale_ms2)
            .tickSize(v_height_unit).tickSizeOuter(0);

            // set y-label
            if(display_metric == "Precursor Mass Error"){
                var y_label = "PPM";
            }
            else{
                var y_label = "";
            }

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label ms2Text")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(y_label);

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric ms2Text")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.ms2_metrics){
                        if(machine_data.ms2_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.ms2_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clipMS2") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // brushing
            var brush = d3.brush()                   
                .extent([[0,0], [lineChartWidth,height]])
                .on("end", updateZoom);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clipMS2)")
                .attr("id", "all_lines");
            
            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_ms2(d.y)});

            // rect underlay (threshold)
            if(display_metric == "Precursor Mass Error"){
                // bottom overlay
                all_lines.append("g")
                .append("rect")
                .attr("class", "bottomoverlay")
                .attr("width", lineChartWidth)
                .attr("height", function(){
                    // catch neg heights
                    var check_height = yScale_ms2(thresholds["threshold_low"]);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",yScale_ms2(thresholds["threshold_low"]))
                .style("opacity",0.5)
                .attr("fill", function(){
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                    //return 'url(#gradlower)';
                }); 
                

                // ...and line
                all_lines.append("line")
                .attr("id", "thresh_low_ppm")
                .attr("x1", 0) //xScale_chart(minX)
                .attr("y1", yScale_ms2(thresholds["threshold_low"]))
                .attr("x2",lineChartWidth) // xScale_chart(maxX)
                .attr("y2", yScale_ms2(thresholds["threshold_low"]))
                .attr("stroke", "white")
                .attr("stroke-width", lineWidth);

                // top overlay
                all_lines.append("g")
                    .append("rect")
                    .attr("class", "topoverlay")
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch neg heights
                        var check_height = yScale_ms2(thresholds["threshold_high"]);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",0)
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradupper)';
                    });

                // ...and line
                all_lines.append("line")
                .attr("id", "thresh_high_ppm")
                .attr("x1", 0) //xScale_chart(minX)
                .attr("y1", yScale_ms2(thresholds["threshold_high"]))
                .attr("x2", lineChartWidth) //xScale_chart(maxX)
                .attr("y2", yScale_ms2(thresholds["threshold_high"]))
                .attr("stroke", "white")
                .attr("stroke-width", lineWidth);
            }
            else{ // all other ms2 metrics
                all_lines.append("g")
                    .append("rect")
                    .attr("class", "ms2overlay")
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch when threshold is off display
                        var check_height = height - yScale_ms2(thresholds["lower_percentile"]);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",yScale_ms2(thresholds["lower_percentile"]))
                    .style("opacity",0.5)
                    .attr("fill", function(){
                    if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradlower)';
                    }); 
            }

            // add brushing first (before line and points)
            all_lines
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // add underlay threshold line
            if(display_metric != "Precursor Mass Error"){
                all_lines.append("line")
                .attr("id", "thresh_low")
                .attr("x1", 0) //xScale_chart(minX)
                .attr("y1", yScale_ms2(thresholds["lower_percentile"]))
                .attr("x2", lineChartWidth) //xScale_chart(maxX)
                .attr("y2", yScale_ms2(thresholds["lower_percentile"]))
                .attr("stroke", "white")
                .attr("stroke-width", lineWidth)
                .on("mouseover", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    var value = parseInt(thresholds["lower_percentile"]);
                    var tooltipHTML = "<strong>Current Threshold</strong></br>" + value;
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");

                })
                .on("mouseout", function(){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");
                }); 
            }

           // add vertical marker
           all_lines.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity" ,1);

            // convert to d3 friendly format
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }

            // line
            all_lines.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("class", "chartline") // used to redraw for zoom
            .attr("stroke", metricColour)
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 0.3)
            .attr("d", line);

            // points
            // ADD points in loop so can raise
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                all_lines.append("g").attr("id", "g"+i)
                .selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => xScale_chart(d.x))
                .attr("cy", d => yScale_ms2(d.y))
                .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
                })
                .attr("x", function(d, i) {return xScale_chart(d.x)})
                .attr("y", function(d, i) {return yScale_ms2(d.y)})
                .attr("stroke", metricColour)
                .attr("stroke-width", lineWidth/2)
                .attr("stoke-opacity", 0.5)
                .attr("class","point circle"+i)
                .attr("filter", "url(#specular)")
                .attr("fill", function(d,j){
                    if(missing.includes(j)){
                        return "var(--dark)";
                    }else{
                        return metricColour;
                    } 
                })
                .on("mouseover", function(event, d){
                    
                    var tooltip = d3.select("#tooltip");
                    if(missing.includes(d.index)){
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            "NO VALUE" + "</strong>";
                    } else{
                        if(display_metric == "Precursor Mass Error"){
                            var value = Number.parseFloat(d.y).toFixed(3);
                        }
                        else{
                            var value = parseInt(d.y);
                        }
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            value + "</strong>";
                    }
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");
                });
            }

            // raise current run
            d3.select("#g"+run_index).raise();

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            .call(x_axis); 

            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr('class', function(){
                        if(theme == "dark"){return "Axis axis-dark";}
                        return "Axis axis-light";
                    })
                .style('font-size', '1.6vh')
                .attr("id", "yAxisLine")
                .call(y_axis);

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".chartline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.select("#xAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.select("#marker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".ms2Text").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll("rect").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.5);

            }

            reDrawMS2Chart = function(){
                // Update axis and line/point position etc
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);
                all_lines
                    .selectAll('.chartline')
                    .transition()
                    .duration(1000)
                    .attr("d", line);
                    
                all_lines
                    .selectAll('circle')
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_ms2(d.y));
            
                all_lines
                    .select("#marker")
                    .transition()
                    .duration(1000)
                    .attr("x1", xScale_chart(x_values_chart[run_index]))
                    .attr("x2", xScale_chart(x_values_chart[run_index]));

                all_lines
                    .select(".ms2overlay")
                    .transition()
                    .duration(1000)
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        var check_height = height - yScale_ms2(thresholds["lower_percentile"]);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",yScale_ms2(thresholds["lower_percentile"]));
                all_lines
                    .select("#thresh_low")
                    .transition()
                    .duration(1000)
                    .attr("x1", 0)
                    .attr("y1", yScale_ms2(thresholds["lower_percentile"]))
                    .attr("x2", lineChartWidth)
                    .attr("y2", yScale_ms2(thresholds["lower_percentile"]));

                //ppm
                all_lines
                    .select(".bottomoverlay")
                    .transition()
                    .duration(1000)
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch neg heights
                        var check_height = yScale_ms2(thresholds["threshold_low"]);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",yScale_ms2(thresholds["threshold_low"]));
                all_lines
                    .select(".topoverlay")
                    .transition()
                    .duration(1000)
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        // catch neg heights
                        var check_height = yScale_ms2(thresholds["threshold_high"]);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",0);
                all_lines
                    .select("#thresh_low_ppm")
                    .transition()
                    .duration(1000)
                    .attr("x1", 0)
                    .attr("y1", yScale_ms2(thresholds["threshold_low"]))
                    .attr("x2", lineChartWidth)
                    .attr("y2", yScale_ms2(thresholds["threshold_low"]));
                    
                all_lines
                    .select("#thresh_high_ppm")
                    .transition()
                    .duration(1000)
                    .attr("x1",0)
                    .attr("y1", yScale_ms2(thresholds["threshold_high"]))
                    .attr("x2", lineChartWidth)
                    .attr("y2", yScale_ms2(thresholds["threshold_high"]));


                // store yScale/xScale
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name == display_metric){
                        machine_data.ms2_metrics[i].yScale = yScale_ms2;  
                        //machine_data.ms2_metrics[i].xScale = xScale_chart;
                        machine_data.ms2_metrics[i].radius = radius;
                        machine_data.ms2_metrics[i].lineWidth = lineWidth;  
                        break;
                    }
                }

            }

            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateZoom(event) {
                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    var x1 = xScale_chart.invert(extent[0][0]);
                    var x2 = xScale_chart.invert(extent[1][0]);
                    //radius = radiusScale(x2-x1);
                    //lineWidth = lineScale(x2-x1);

                    xScale_chart.domain([xScale_chart.invert(extent[0][0]), xScale_chart.invert(extent[1][0])])
                    yScale_ms2.domain([yScale_ms2.invert(extent[1][1]), yScale_ms2.invert(extent[0][1])])
                    all_lines.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                
                reDrawMS2Chart();
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                //radius = base_radius;
                //lineWidth = base_line_width;
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }
                yScale_ms2.domain([minY - offsetY, maxY + offsetY]);
                
                reDrawMS2Chart();
            });
        }

        function radioUpdate(event){

            // handle icon clicks
            var el = event.target;
            if(el.tagName == "SPAN"){
                el = event.target.parentElement;
            }

            // manually collapse from button (bootstrap method not working)
            if(el.getAttribute("type") == "button"){
                
                if(el.nextSibling.classList.contains("show")){
                    el.nextSibling.classList.remove("show");
                }
                else{
                    el.nextSibling.classList.add("show");
                }
                
                // update menu state
                if(el.innerText == "LC-MS METRICS"){
                    metric_menu_display = "lcms";
                    metric_type = "lcms";
                }else if(el.innerText == "MS2 METRICS"){
                    metric_menu_display = "ms2";
                    metric_type = "ms2";
                }else if(el.innerText == "LOADING PUMP"){
                    metric_menu_display = "loading";
                    metric_type = "pressure";
                }else if(el.innerText == "NANO PUMP"){
                    metric_menu_display = "nano";
                    metric_type = "pressure";
                }
                menu_state[metric_menu_display] = !menu_state[metric_menu_display];
                
            }
            
            // update display metric from radio
            if(event.target.getAttribute("type") == "radio"){ // only respond to input

                // disable/enable box plots for normalised
                display_metric = event.target.labels[0].innerText;

                if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                    document.getElementById("box").disabled = true;
                    document.getElementById("box").style.boxShadow = "";
                    document.getElementById("box").classList = "btn";
                }
                else{
                    document.getElementById("box").disabled = false;
                    document.getElementById("box").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("box").classList = "btn btn-custom";
                }

                // disable heat maps and box plots
                if(event.target.classList.contains("pressure")){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("heat").style.boxShadow = "";
                    document.getElementById("heat").classList = "btn";
                    document.getElementById("box").disabled = true;
                    document.getElementById("box").style.boxShadow = "";
                    document.getElementById("box").classList = "btn";
                    document.getElementById("stream").disabled = true;
                    document.getElementById("stream").style.boxShadow = "";
                    document.getElementById("stream").classList = "btn";
                    document.getElementById("parallel").disabled = true;
                    document.getElementById("parallel").style.boxShadow = "";
                    document.getElementById("parallel").classList = "btn";
                }
                else if(event.target.classList.contains("ms2")){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("heat").style.boxShadow = "";
                    document.getElementById("heat").classList = "btn";
                    document.getElementById("box").disabled = true;
                    document.getElementById("box").style.boxShadow = "";
                    document.getElementById("box").classList = "btn";
                    document.getElementById("stream").disabled = false;
                    document.getElementById("stream").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("stream").classList = "btn btn-custom";
                    document.getElementById("parallel").disabled = false;
                    document.getElementById("parallel").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("parallel").classList = "btn btn-custom";
                }
                else if(display_metric == "Retention Time" || display_metric == "Full Width Half Maximum"){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("heat").style.boxShadow = "";
                    document.getElementById("heat").classList = "btn";
                    document.getElementById("stream").disabled = false;
                    document.getElementById("stream").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("stream").classList = "btn btn-custom";
                    document.getElementById("parallel").disabled = false;
                    document.getElementById("parallel").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("parallel").classList = "btn btn-custom";
                }
                else{
                    document.getElementById("heat").disabled = false;
                    document.getElementById("heat").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("heat").classList = "btn btn-custom";
                    document.getElementById("stream").disabled = false;
                    document.getElementById("stream").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("stream").classList = "btn btn-custom";
                    document.getElementById("parallel").disabled = false;
                    document.getElementById("parallel").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("parallel").classList = "btn btn-custom";
                }

                if(display_metric == "Precursor Mass Error"){
                    document.getElementById("stream").disabled = true;
                    document.getElementById("stream").style.boxShadow = "";
                    document.getElementById("stream").classList = "btn";
                }

                // flip card for pressure metrics
                if(event.target.classList.contains("lp")){
                    autoflipcard("lp");
                }

                if(event.target.classList.contains("np")){
                    autoflipcard("np");
                }

                // set reset controls
                var chart_bottom = document.getElementById("chart_bottom");
                var chart_top = document.getElementById("chart_top");
                if(controls){
                    // add bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                }

                // re draw current chart
                if(chart_type == "line"){
                    if(event.target.classList.contains("pressure")){
                        metric_type = "pressure";
                        draw_pressure_line(true);
                    }
                    else if(event.target.classList.contains("ms2")){
                        metric_type = "ms2";
                        draw_ms2_line(true);
                    }
                    else{
                        metric_type = "lcms";
                        draw_line_chart(true);
                    }
                }
                else if(chart_type == "box"){
                    yScale_box = null;
                    draw_box_plot(true);
                    
                }
                else if(chart_type == "heat"){
                    draw_heat_map(true);
                }
                else if(chart_type == "stream"){
                    if(event.target.classList.contains("ms2")){
                        metric_type = "ms2";
                        draw_ms2_stream_graph(true);
                    }
                    else{
                        metric_type = "lcms";
                        draw_stream_graph(true);
                    }
                }
                else if(chart_type == "parallel"){
                    if(event.target.classList.contains("ms2")){
                        metric_type = "ms2";
                        draw_ms2_parallel_graph(true);
                    }
                    else{
                        metric_type = "lcms";
                        draw_parallel_graph(true);
                    }
                }

                create_components_menu(false);
            }  
        }

        function draw_pressure_density(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";
            
            if(transition){
                plot_area.style.opacity = 0;
                chart_header.innerHTML = display_metric;
            }

            // x values and missing indexes
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var x_values = machine_data.pressure_metrics[i].values;
                    var missing = machine_data.pressure_metrics[i].missing;
                    break;
                }
            };
            
            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 10, right: 30, bottom: chart_bottom.offsetHeight+35, left: 50};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // get x extents 
            var x_max = d3.max(x_values);
            var x_min = d3.min(x_values);
            var offset = 5;

            // x scale
            var xScale = d3.scaleLinear()
                .domain([x_min - offset, x_max + offset])
                .range([0, width]);
                
            // remove missing
            x_values = x_values.filter(function(value, i){
                        if(!missing.includes(i) && i<filter){
                            return value;
                        }
                    })

            // data points effects degree of smoothing
            var data_points = Math.ceil(x_values.length/2);

            // get kernel estimate data
            var h = silvermans(x_values);
            var kde = kernelDensityEstimator(kernelEpanechnikov(h), xScale.ticks(data_points));
            var density =  kde(x_values);
            
            // y extents
            var y_max = d3.max(density, function(d) {return d[1]});
            
            // y scale
            var yScale = d3.scaleLinear()
                    .domain([0 , y_max])
                    .range([height, 0]);
            
            // y-axis
            var y_axis = d3.axisLeft().scale(yScale)
            .tickSize(2).tickSizeOuter(0);
            
            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr("class", "axis-chart")
                .call(y_axis);

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("DENSITY");

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale(d[0])})
                                        .y(function(d, i) {return yScale(d[1])});

            // area under curve
            var area = d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale(d[0]);})
                        .y0(height)
                        .y1(function(d) { return yScale(d[1]);});

            // x-axis
            var x_axis = d3.axisBottom().scale(xScale)
            .tickSize(2).tickSizeOuter(0);
            
            // x-axis calls
            var x_axis_call = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "axis-chart")
                .call(x_axis);

            // x-label
            svg.append("text")
            .attr("class", "label")
            .attr("y", height +(margin.bottom/2))
            .attr("x",width/2)
            .style("text-anchor", "middle")
            .text("BARS");

            // grid x 
            var xAxisGrid = d3.axisBottom().scale(xScale)
            .tickSize(-height).tickFormat('').tickSizeOuter(0);

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);

            // plot the density distribution (area)
            svg.append("path")
                    .datum(density)
                    .attr("class", "densearea")
                    .attr("fill", "var(--teal)")
                    .attr("fill-opacity", 0.1)
                    .attr("stroke-width", "0")
                    .attr("pointer-events", "none")
                    .attr("d", area);
                
            // plot the density distribution (lines)
            svg.append("path")
                .datum(density)
                .attr("fill", "none")
                .attr("stroke", "var(--teal)")
                .attr("stroke-width", 1.5)
                .on("mouseover", function(event, d){ // highlight on hover

                    // text location boundaries
                    var x = event.layerX;
                    var y = event.layerY;
                    var anchor = "middle"; 
                    if(x >= width - 100){
                        x = width - 200;
                        anchor = "start";
                    };
                    if(x <= 150){
                        x = x + 150;
                    }
                    if(y >= height -100){
                        y = height - 100;
                    }

                    // highlight
                    d3.selectAll(".densearea").style("fill-opacity", 0.5);
                    
                    // add text
                    svg.append("text")
                    .attr("class", "hover-text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", "1em")
                    .attr("font-size", "1em")
                    .style("text-anchor", anchor)
                    .text(display_metric);
                })
                .on("mouseout", function(){
                    d3.selectAll(".densearea").style("fill-opacity", 0.1);
                    d3.select(".hover-text").remove();
                })
                .attr("d", line);

            if(transition){
                d3.select("#plot_chart").transition().duration(500).style("opacity", 1);
            }
        }

        function draw_ms2_density(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";
            
            if(transition){
                plot_area.style.opacity = 0;
                chart_header.innerHTML = display_metric;
            }

            // x values and missing indexes
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name == display_metric){
                    var x_values = machine_data.ms2_metrics[i].values;
                    var missing = machine_data.ms2_metrics[i].missing;
                    break;
                }
            };
            
            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 10, right: 30, bottom: chart_bottom.offsetHeight+35, left: 50};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // get x extents 
            var x_max = d3.max(x_values);
            var x_min = d3.min(x_values);
            var offset = 5;

            // x scale
            var xScale = d3.scaleLinear()
                .domain([x_min - offset, x_max + offset])
                .range([0, width]);
                
            // remove missing
            x_values = x_values.filter(function(value, i){
                        if(!missing.includes(i) && i<filter){
                            return value;
                        }
                    })

            // data points effects degree of smoothing
            var data_points = Math.ceil(x_values.length/2);

            // get kernel estimate data
            var h = silvermans(x_values);
            var kde = kernelDensityEstimator(kernelEpanechnikov(h), xScale.ticks(data_points));
            var density =  kde(x_values);
            
            // y extents
            var y_max = d3.max(density, function(d) {return d[1]});
            
            // y scale
            var yScale = d3.scaleLinear()
                    .domain([0 , y_max])
                    .range([height, 0]);
            
            // y-axis
            var y_axis = d3.axisLeft().scale(yScale)
            .tickSize(2).tickSizeOuter(0);
            
            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr("class", "axis-chart")
                .call(y_axis);

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("DENSITY");

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale(d[0])})
                                        .y(function(d, i) {return yScale(d[1])});

            // area under curve
            var area = d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale(d[0]);})
                        .y0(height)
                        .y1(function(d) { return yScale(d[1]);});

            // x-axis
            var x_axis = d3.axisBottom().scale(xScale)
            .tickSize(2).tickSizeOuter(0);
            
            // x-axis calls
            var x_axis_call = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "axis-chart")
                .call(x_axis);

            // set x-label
            if(display_metric == "Precursor Mass Error"){
                var x_label = "PPM";
            }
            else{
                var x_label = "COUNT";
            }

            // x-label
            svg.append("text")
            .attr("class", "label")
            .attr("y", height +(margin.bottom/2))
            .attr("x",width/2)
            .style("text-anchor", "middle")
            .text(x_label);

            // grid x 
            var xAxisGrid = d3.axisBottom().scale(xScale)
            .tickSize(-height).tickFormat('').tickSizeOuter(0);

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);

            // plot the density distribution (area)
            svg.append("path")
                    .datum(density)
                    .attr("class", "densearea")
                    .attr("fill", "var(--warning)")
                    .attr("fill-opacity", 0.1)
                    .attr("stroke-width", "0")
                    .attr("pointer-events", "none")
                    .attr("d", area);
                
            // plot the density distribution (lines)
            svg.append("path")
                .datum(density)
                .attr("fill", "none")
                .attr("stroke", "var(--warning)")
                .attr("stroke-width", 1.5)
                .on("mouseover", function(event, d){ // highlight on hover

                    // text location boundaries
                    var x = event.layerX;
                    var y = event.layerY;
                    var anchor = "middle"; 
                    if(x >= width - 100){
                        x = width - 200;
                        anchor = "start";
                    };
                    if(x <= 150){
                        x = x + 150;
                    }
                    if(y >= height -100){
                        y = height - 100;
                    }

                    // highlight
                    d3.selectAll(".densearea").style("fill-opacity", 0.5);
                    
                    // add text
                    svg.append("text")
                    .attr("class", "hover-text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", "1em")
                    .attr("font-size", "1em")
                    .style("text-anchor", anchor)
                    .text(display_metric);
                })
                .on("mouseout", function(){
                    d3.selectAll(".densearea").style("fill-opacity", 0.1);
                    d3.select(".hover-text").remove();
                })
                .attr("d", line);

            if(transition){
                d3.select("#plot_chart").transition().duration(500).style("opacity", 1);
            }
        }

        function draw_pressure_box(transition){ // not used
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            
            if(transition){
                plot_area.style.opacity = 0;
                chart_header.innerHTML = display_metric.toUpperCase();
            }

            // x values
            var run_values = machine_data.run_data
            var x_values = [];
            for(let run in run_values){
                x_values.push(run_values[run].date_time);
            }

            // y values and missing indexes
            var data= [];
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var new_obj = machine_data.pressure_metrics[i].stats;
                    new_obj["missing"] = machine_data.pressure_metrics[i].missing;
                    new_obj["current"] = machine_data.pressure_metrics[i].values[run_index];
                    data.push(new_obj);
                    break;
                }
            };

            // set the dimensions and margins of the plot
            var margin = {top: 10, right: 10, bottom: 20, left: 50};
            var width = plot_width - margin.left - margin.right;
            box_area_height = plot_height - margin.top - margin.bottom;
            
            // boxwidth
            var box_padding = 10;
            var box_width = width/4;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // x scale
            xScale_box = d3.scaleBand()
                .range([0, width])
                .domain([display_metric])
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale_box).tickValues([]).tickSizeOuter(0);

            // x-axis-call
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + box_area_height + ")")
            .attr("class", "axis-chart")
            .call(x_axis);

            // y-scale
            // set at outlier limit
            var IQR = data[0]["75_percent"] - data[0]["25_percent"];
            yScale_box = d3.scaleLinear()
                .domain([data[0]["25_percent"] - IQR , data[0]["75_percent"] + IQR])
                .range([box_area_height, 0]);
            
            // y-axis
            var y_axis = d3.axisLeft().scale(yScale_box)
            .tickSize(2).tickSizeOuter(0);

            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr("class", "axis-chart")
                .call(y_axis);
            
            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale_box).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (box_area_height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("BARS");

            // add the box
            svg
            .selectAll("boxes")
            .data(data)
            .enter()
            .append("rect")
                .attr("x", function(d){return(xScale_box(display_metric)- box_width/2)})
                .attr("y", function(d){return(yScale_box(d["75_percent"]))})
                .attr("height", function(d){return(yScale_box(d["25_percent"])-yScale_box(d["75_percent"]))})
                .attr("width", box_width)
                .attr("stroke", "var(--info)")
                .attr("stroke-width", "2px")
                .style("fill", "var(--info)")
                .style("fill-opacity", 0.5)
                .on("mouseover", function(event, d){
                    // tooltip
                    var tooltip = d3.select("#tooltip");
                    var tooltipHTML = "<strong>" + display_metric + "</strong><br>" +
                                    "<strong>Q1 </strong>" + d["25_percent"].toFixed(3) + "<br>" +
                                    "<strong>Q3 </strong>" + d["75_percent"].toFixed(3) + "<br>" +
                                    "<strong>Median </strong>" + d["50_percent"].toFixed(3) + "<br>" +
                                    "<strong>Mean </strong>" + d["mean"].toFixed(3);
                                        
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+30) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                });

            // median
            svg
            .selectAll("medianLines")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(display_metric)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
            .attr("y2", function(d){return(yScale_box(d["50_percent"]))})
            .attr("stroke", "white");

             // mean
             svg
            .selectAll("meanLines")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(display_metric)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["mean"]))})
            .attr("y2", function(d){return(yScale_box(d["mean"]))})
            .attr("stroke", "white")
            .style("stroke-dasharray", ("3, 3"));

            // current run
            svg
            .selectAll("currentRun")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", d => xScale_box(display_metric))
            .attr("cy", function(d){
                    // cap so does not go off chart
                    if(yScale_box(d.current) > box_area_height){
                        return box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    
                    return yScale_box(d.current)
                })
            .attr("r", box_radius)
            .attr("x", function(d, i) {return xScale_box(display_metric)})
            .attr("y", function(d){
                    // cap so does not go off chart
                    if(yScale_box(d.current) > box_area_height){
                        return  box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    
                    return yScale_box(d.current)
                })
            .attr("stroke", "var(--info)")
            .attr("stroke-width", 2)
            .attr("class","point")
            .attr("fill", function(d,j){
                var miss = d.missing;
                if(miss.includes(run_index)){
                    return "black";
                }
                else if(yScale_box(d.current) > box_area_height){
                        return  "var(--info)";
                    }
                else if(yScale_box(d.current)<0){
                    return "var(--info)";
                }
                else{
                    return "whitesmoke";
                }
            })
            .on("mouseover", function(event, d){ // tooltip on hover
                var tooltip = d3.select("#tooltip");
                var miss = d.missing;
                if(miss.includes(run_index)){
                    var tooltipHTML = "<strong>" + display_metric.replace("_", " ") + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        "NO VALUE" + "</strong>";
                } else{
                    var tooltipHTML = "<strong>" +  display_metric.replace("_", " ")  + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        Number.parseFloat(d.current).toFixed(3) + "</strong>";
                }
                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX+30) + 'px');
                tooltip.style('top', (event.pageY+10) + 'px');
                tooltip.style("visibility", "visible");
            })
            .on("mouseout", function(){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })

            // extender
            svg
            .selectAll("extenders")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric))})
            .attr("x2", function(d){return(xScale_box(display_metric))})
            .attr("y1", function(d){
                var y1;
                if(d.current >= d["75_percent"]){
                    y1 = yScale_box(d.current);
                }
                else if(d.current <= d["25_percent"]){
                    y1 = yScale_box(d["25_percent"]);
                }
                else{
                    y1 =  yScale_box(d.current);
                }

                // cap so does not go off chart
                if(y1 < 0){
                    return 0;
                }
                return y1;
            })
            .attr("y2", function(d){
                var y2;
                if(d.current >= d["75_percent"]){
                    y2 = yScale_box(d["75_percent"]);
                }
                else if(d.current <= d["25_percent"]){
                    y2 = yScale_box(d.current);
                }
                else{
                    y2 = yScale_box(d.current);
                }
                // cap so does not go off chart
                if(y2 > box_area_height){
                    return box_area_height;
                }
                return y2;
            })
            .attr("stroke", "var(--info)")
            .attr("stroke-width", 2)
            .attr("class", "extender");

            if(transition){
                d3.select("#plot_chart").transition().duration(500).style("opacity", 1);
            }
        }

        function getThresholds(){
            var thresholds = {};
            var threshold_metrics = ["Mass Error (ppm)", "Tailing", "Asymmetry", "Full Width Half Maximum", "Area (normalised)"]; // only displayable thresholds at the moment
            if(!threshold_metrics.includes(display_metric)){
                return thresholds;
            }

            // get threshold markers
            for(let i in machine_data["lcms_metrics"]){
                if(machine_data["lcms_metrics"][i].display_name == display_metric){
                   thresholds = machine_data["lcms_metrics"][i]["thresholds"];
                }
            };
            return thresholds;
        }

        // callback to rotate card
        function flipcard(el){

            // only if click from rotate icon
            if(!el.target.hasAttribute("data-rotate")){
                return;
            }
            
            let tile_inner = document.getElementById("profile_inner");
            let tile_back = tile_inner.childNodes[1];
            let tile_front = tile_inner.childNodes[0];
            let state = tile_inner.getAttribute("data-state");

            // leave duplicate code in "if" 
            if (state == "front"){
                // rotate
                tile_inner.style.transform = "rotateY(180deg)";
                setTimeout(function(){
                    // redraw shadows
                    //tile_back.style.boxShadow = "10px 10px 5px grey";

                    // reset button and tile state
                    tile_inner.setAttribute("data-state", "back");
                    pressure_type = "nano";
                    //el.target.setAttribute("data-tooltip","Flip to View Loading Pump");
                    
                }, 500);
            }
            else if (state == "back"){
                // rotate
                tile_inner.style.transform = "rotateY(360deg)";
                // redraw shadow (leave in 'if' as clicks sometimes catch the row not the tile)
                setTimeout(function(){
                    // redraw shadows
                    //tile_front.style.boxShadow = "10px 10px 5px grey";
                    // reset button
                    tile_inner.setAttribute("data-state", "front");
                    pressure_type = "loading";
                    //el.target.setAttribute("data-tooltip","Flip to View Nano Pump");
                }, 500);
            }
        }

        function setRunScale(){
            // greater is more recent
            // domain[0] is oldest (left of chart)
            // domain[1] is newest (right of chart)

            /* FIND DOMAIN FROM CURRENT SCALE */
            var rightDomain = xScale_chart.domain()[1];
            var leftDomain = xScale_chart.domain()[0];

            var runsMaxIndex = 0;
            var runsMinIndex = x_values_time.length - 1;

            // find runs max index (newest)
            // first one less than right domain
            for(let i = 0;  i < x_values_time.length; i++){
                if(x_values_time[i] < rightDomain){
                    runsMaxIndex = i;
                    break;
                }
            }
            // find runs min index (oldest)
            // first one greater than left domain in reverse
            for(let i = x_values_time.length-1;  i >= 0; i--){
                if(x_values_time[i] > leftDomain){
                    runsMinIndex = i;
                    break;
                }
            }

            // catch same or flipped (upside down logic and in run scale!!)
            if(runsMaxIndex >= runsMinIndex){
                runsMaxIndex = 0;
                runsMinIndex = x_values_time.length - 1;
            }

            /*** update scales, axis and x values ***/
            x_values_chart = x_values_runs;
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));

            // scale
            xScale_runs.domain([runsMinIndex+1+offsetX, runsMaxIndex+1-offsetX]);
            xScale_chart = xScale_runs;

            // axis
            x_axis_runs.scale(xScale_runs);
            x_axis = x_axis_runs;

            // x-axis transition
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);
        }

        function updateChangeScalePressure(){

            // get pressure data
            // y values 
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var y_values = machine_data.pressure_metrics[i].values;
                    break;
                }
            };

            // ADD points in loop so can raise
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                // swap data and transition
                d3.selectAll(".circle"+i)
                    .data(data)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_pressure(d.y));
            }

            /* get line, change data and re-draw */
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_pressure(d.y)});

            // convert to d3 friendly format
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }
                    
            d3.selectAll(".chartline")
                .datum(data)
                .transition()
                .duration(1000)
                .attr("d", line);
                

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_pressure_line(false);
            }, 1000);

        }

        function  updateChangeScale(){

            /* get all circles, change data and re-draw */
            var component_indexes = getComponentIndexes();
            for(let j = x_values_chart.length-1; j>=0; j--){
                var data = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                        // convert to d3 friendly format
                        
                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j, 'comp': i};
                        data.push(new_row);
                    }
                }

                // order for display
                data = data.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});
                //console.log(d3.selectAll(".circle"+j));

                // swap data and transition
                d3.selectAll(".circle"+j)
                    .data(data)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_chart(d.y));
            }

            /* get all lines, change data and re-draw */
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_chart(d.y)});

            // move line (per component)
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j < x_values_chart.length; j++){

                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }
                    
                    d3.selectAll(".chartline"+i)
                        .datum(data)
                        .transition()
                        .duration(1000)
                        .attr("d", line);
                }
            }

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_line_chart(false);
            }, 1000);

        }

        function updateChangeScaleMS2(){

            // y values
            for(let i in machine_data.ms2_metrics){
                if(machine_data.ms2_metrics[i].display_name == display_metric){
                    var y_values = machine_data.ms2_metrics[i].values;
                    break;
                }
            }

            // points
            for(let i = x_values_chart.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                // swap data and transition
                d3.selectAll(".circle"+i)
                    .data(data)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_ms2(d.y));
            }

            // data for line
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }

            // curve
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_ms2(d.y)});

            // line
            d3.selectAll(".chartline")
                .datum(data)
                .transition()
                .duration(1000)
                .attr("d", line);

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_ms2_line(false);
            }, 1000);


        }

        function lineChartFilterUpdate(){

            // allow for circles (on full view)
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
                xScale_chart.domain([minX, maxX]);
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
                xScale_chart.domain([maxX, minX]);
            }

            if(metric_type == "pressure"){
                /*pressure data update*/
                // y values and missing indexes
                for(let i in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[i].display_name == display_metric){
                        var y_values = machine_data.pressure_metrics[i].values;
                        var missing = machine_data.pressure_metrics[i].missing;
                        break;
                    }
                };

                // set y scale domain
                var maxY = d3.max(y_values.slice(0, filter));
                var minY = d3.min(y_values.slice(0, filter));
                var offsetY = (2*currentRadius/pressureHeight)*(maxY-minY);
                yScale_pressure.domain([minY - offsetY, maxY + offsetY]);
            }
            
            if(metric_type == "ms2"){
                // ms2 domain update (y values)
                for(let i in machine_data.ms2_metrics){
                    if(machine_data.ms2_metrics[i].display_name == display_metric){
                        var y_values = machine_data.ms2_metrics[i].values;
                        break;
                    }
                }

                // set y scale domain
                var maxY = d3.max(y_values.slice(0, filter));
                var minY = d3.min(y_values.slice(0, filter));
                var offsetY = (2*currentRadius/ms2Height)*(maxY-minY);
                yScale_ms2.domain([minY - offsetY, maxY + offsetY]);
            }

            if(metric_type == "pressure"){
                // getarray for stats (based on filter)
                var statsData = [];
                for(let i = filter-1; i>=0; i--){
                    // stats data
                    if(!(missing.includes(i))){
                        statsData.push(y_values[i]);
                    }
                }

                // calculate stats
                statsArr = [{"name": "Mean", "value": calcAverage(statsData)}, 
                                {"name": "Median", "value": calcQuartile(statsData, 50)}, 
                                {"name": "Q1", "value": calcQuartile(statsData, 25)},
                                {"name": "Q3", "value": calcQuartile(statsData, 75)}];
                
                // sort to handle display offsets
                statsArr = statsArr.sort(function(a,b){ return parseFloat(a.value) - parseFloat(b.value);});
            }

            // change domain and re-draw
            if(metric_type == "lcms"){
                reDrawChart();
            }else if(metric_type == "pressure"){
                reDrawPressureChart();
            }
            else if(metric_type == "ms2"){
                reDrawMS2Chart();
            }

        }

        function setTimeScale(){

            


            /* FIND DOMAIN FROM CURRENT SCALE */
            var rightDomain = xScale_chart.domain()[1];
            var leftDomain = xScale_chart.domain()[0];

            // get index for time values
            var timeMaxIndex = Math.floor(leftDomain) - 1;
            var timeMinIndex = Math.ceil(rightDomain) - 1;
    
            // catch same or flipped
            if(timeMaxIndex <= timeMinIndex){
                if(timeMaxIndex - 1 < filter){
                    timeMinIndex += 1;
                }
                else{
                    timeMinIndex = 0;
                    timeMaxIndex = filter - 1;
                }
            }

            // catch negative min
            if(timeMinIndex < 0){timeMinIndex = 0;}

            // catch too big max
            if(timeMaxIndex >= filter){timeMaxIndex = machine_data.run_data.length - 1;}
            
            /*** update scales, axis and x values ***/
            /** Warning upside down time logic **/
            x_values_chart = x_values_time;
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            var maxX = new Date(+x_values_chart[timeMinIndex] + offsetX); // + needed as hint else it will concatenate
            var minX = new Date(x_values_chart[timeMaxIndex] - offsetX); 
            
            // scale
            xScale_time.domain([minX, maxX]);
            xScale_chart = xScale_time;

            // axis
            x_axis_time.scale(xScale_time);
            x_axis = x_axis_time;

            // x-axis transition
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);
        }

        // function to rotate card to viewed pressure metric
        function autoflipcard(pump){

            let tile_inner = document.getElementById("profile_inner");
            let tile_back = tile_inner.childNodes[1];
            let tile_front = tile_inner.childNodes[0];
            let state = tile_inner.getAttribute("data-state");
            //var icon = tile_front.childNodes[1].childNodes[1].childNodes[0];

            // correct side just return
            if(pump == "lp"){
                if(state == "front"){
                    return;
                }
            }
            else{
                if(state == "back"){
                    return;
                } 
            }

            // remove shadow
            tile_front.style.boxShadow = "0px 0px 0px whitesmoke";
            tile_back.style.boxShadow = "0px 0px 0px whitesmoke";

            // leave duplicate code in "if" 
            if (state == "front"){
                // rotate
                tile_inner.style.transform = "rotateY(180deg)";
                setTimeout(function(){
                    // redraw shadows
                    tile_back.style.boxShadow = "0.5vh 0.5vh 0.5vh var(--gray)";

                    // reset button and tile state
                    tile_inner.setAttribute("data-state", "back");
                    pressure_type = "nano";
                    draw_pressure_profile(false);
                    //icon.setAttribute("data-tooltip","Flip to View Loading Pump");
                    
                }, 500);
            }
            else if (state == "back"){
                // rotate
                tile_inner.style.transform = "rotateY(360deg)";
                // redraw shadow (leave in 'if' as clicks sometimes catch the row not the tile)
                setTimeout(function(){
                    // redraw shadows
                    tile_front.style.boxShadow = "0.5vh 0.5vh 0.5vh var(--gray)";
                    // reset button
                    tile_inner.setAttribute("data-state", "front");
                    pressure_type = "loading";
                    draw_pressure_profile(false);
                    //icon.setAttribute("data-tooltip","Flip to View Nano Pump");
                }, 500);
            }
        }

    </script>
</head>