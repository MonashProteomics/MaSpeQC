<head>
    <title>MaSpeQC</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://kit.fontawesome.com/f77ac44772.js" crossorigin="anonymous"></script> <!--Font Awesome icons-->
    <script src="./javascripts/control.js"></script>
    <script src="./javascripts/forceGraph.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v6.js"></script> <!--D3-->
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script> <!--d3 force boundary add on-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="./stylesheets/style.css"  />
    <script type="text/javascript">

        /* machine_data object structure (after load)*/

        /*components (Array #COMPONENTS){
            component_name
            component_mode
            component_id
            colour
            chromatograms (Array #RUNS) {
                exp_rt
                intensities (Array #READINGS)
                rts (Array #READINGS)
                mz
            }
            lcms_metrics{
                metric_name{
                    values (Array #RUNS) 
                    missing (Array #MISSING)
                } 
            }
            stats{
                metric_name{
                    mean
                    std
                    min
                    max
                    25_percent
                    50_percent
                    75_percent
                }
            }
        }
        lcms_metrics (Array #METRICS){
            display_order
            display_name
            metric_id
            yScale
            xScale
            lineWidth
            radius
            thresholds{
                threshold_trigger
                threshold_low
                threshold_high
            }
        }
        machine_details{
            display_metric
            experiment
            machine_name
            machine_type
            }
        pressure_metrics (Array #METRICS){
            display_order
            display_name
            yScale
            xScale
            lineWidth
            radius
            values (Array #RUNS)
            missing (Array #MISSING)
            stats{
                mean
                std
                min
                max
                25_percent
                50_percent
                75_percent
            }
        }
        run_data (Array #RUNS){
            run_id
            date_time
            pressure_profile{
                intensities
                rts
            }
            summary{
                metric_name{
                    component (Array 1)
                }
            }
        }
        */

        /* FUNCTIONS 
        *EVENT document.onmouseover - handles the tooltips display 
        *EVENT document.onmouseout - handles tooltip removal 
        *EVENT document.onclick - handles page reload or change 
        *create_navbar_dropdown - adds machines to charts dropdown
        *diff_days - returns number of days between a data and current day
        *getTime - creates the time without seconds 
        create_layout - creates the grid layout
        create_pressure_profile - creates the pressure profile interface
        create_header_display - creates the header display and controls
        create_chromatogram - creates the chromatogram display interface
        create_components_menu - creates the components menu and check boxes
        create_metric_menu - creates the metric menu
        create_chart_area - creates the main chart display interface
        draw_pressure_profile - draws the pressure profile
            - updateChart - updates the chart for x-zoom
        draw_chromatogram - draws the chromatogram
            - updateChart - updates the chart for x-zoom
        draw_line_chart - draws the line chart for lcms metrics
            - updateZoom - updates the chart for xy-zoom
        draw_pressure_line - draws the line chart for pressure metrics
            - updateZoom - updates the chart for xy-zoom
        draw_box_plot - draws the box plots for lcms metrics 
            moveBoxes - transitions box chart
        draw_heat_map - draws the heat maps for lcms metrics
        draw_density_plot - draws the ridgeline chromatograms
        draw_parallel_graph - draws the lc-ms parallel chart
            update_parallel_graph
        draw_stream_graph - draws the lc-ms stream graph
            update_stream_graph
        draw_force_main - draws the force graph for metabolomics
        setTimeScale - handles change to time
        setRunScale - handels change to runs
            updateChangeScale - 
            updateChangeScaleStream -
            updateChangeScalePressure - 
        displayRuns - handles change of runs filter
            lineChartFilterUpdate
            streamChartFilterUpdate
        componentDraw - handles change of component re-draw
        controlsDraw - handles change of control state redraw
        getThresholds - returns the low and high threshold markers for display metric (if any)
        
       
        
        updateMarker - moves vertical line marker on line charts
        displayRuns - redraws charts after filter change
        EVENT controlUpdate - updates chromatogram, pressurre profile and header display (LR)
        EVENT controlDouble - updates chromatogram, pressurre profile and header display (double arrow)
        EVENT reSize - redraws charts on page resize
        EVENT clickSelectAll - handles click of select all
        EVENT updateChartType - changes between charts (line,box,heat)
        EVENT radioUpdate - changes between metrics from radio controls
        */

        // get machine data from controller
        let machine_data = <%-JSON.stringify(ejs_machine_data)%>;

        //
        
        // state variables
        let run_index = 0; 
        let comp_index = 0;
        let filter = 10;
        let display_metric = "Mass Error (ppm)";
        let chart_type = "force";
        let mainForce = true;
        let metric_type = "lcms";
        let metric_menu_display = "lcms";
        let menu_state = {"lcms": false, "pressure": false};
        let menu_show = false;
        let checked_components = {};
        let chromModal = false;
        let pressureModal = false;
        let menuModal = false;
        let theme = "light";
        let boxExpand = -1;
        let streamExpand = false;
        let offsetType = d3.stackOffsetNone;//d3.stackOffsetNone; //d3.stackOffsetSilhouette; //  
        let scaleType = "runs";
        let controls = true;
        let chromExpand = false;

        // global variables and function

        /* SCALE CHANGE */
        let xScale_chart = null; // set this to "runs" or "time"
        let xScale_runs = null;
        let xScale_time = null;
        let x_axis = null; // set this to "runs" or "time"
        let x_axis_runs = null;
        let x_axis_time = null;
        let x_values_chart = null; // set this to "runs" or "time"
        let x_values_runs = null;
        let x_values_time = null;

        /* STREAM EXPAND */
        let yScale_stream_expand = null;
        let yScale_stream_total = null;
        let yScale_stream = null; // set this to "total" or "expand"
        let y_axis_stream; // set this to "total" or "expand"
        let y_axis_stream_total;
        let y_axis_stream_expand;

        let y_axis_pressure = null;
        
        /* REST */
        let reDrawChart;
        let reDrawPressureChart;
        let chart_height;
        let header_height;
        let cell_height;
        let v_height_unit;
        let v_width_unit;
        let colourByKey;
        let stackKeys = [];
        let yScales = {}; // parallel scales
        let xScale_chrom = null;
        let xScale_pressure = null;
        let xScale_par = null;
        let yScale_chart = null;
        let yScale_pressure = null;
        let yScale_profile = null;
        let yScale_ridge = null;
        let yScale_box = null;
        let xScale_box = null;
        let box_area_height = null;
        let tooltipElem; // tooltip for interface
        let zoom = false;
        let lineChartWidth;
        let boxChartWidth;
        let pressureHeight;
        let profileHeight;
        let currentRadius; // biggest circle
        let base_radius;
        let radius; // min for line charts (scales on zoom)
        let base_line_width;
        let box_width;
        let lineWidth; // min for line charts (scales on zoom)
        let statsArr;
        let y_labels = {"Mass Error (ppm)": "Parts Per Million",
                        "Mass Error (mDa)": "Milli Dalton",
                        "Retention Time": "Minutes",
                        "Area (normalised)" : "Log Normalised (Median)",
                        "Height (normalised)": "Log Normalised (Median)",
                        "Full Width Half Maximum": "Seconds",
                        "Tailing": "Seconds",
                        "Asymmetry": "Seconds"} // check tailing and asymmetry
        let heat_ranges = {"Mass Error (ppm)": {low:-4, hi: 4},
                        "Mass Error (mDa)": {low:-2, hi: 2},
                        "Area (normalised)" : {low:-3, hi: 3},
                        "Height (normalised)": {low:-3, hi: 3},
                        "Tailing": {low:0, hi: 2},
                        "Asymmetry": {low:0, hi: 2}};

        let density_ranges = {
                        "Area (normalised)" : {low:-4, hi: 4},
                        "Height (normalised)": {low:-4, hi: 4},
                        "Tailing": {low:-1, hi: 4},
                        "Asymmetry": {low:-1, hi: 4},
                        "Full Width Half Maximum": {low:0, hi:50},
                        "Mass Error (mDa)": {low:-3, hi: 3}};
        const machine_types = {"agilent": "Agilent",  "bruker": "Bruker", "thermo": "Thermo Fisher", 
                        "sciex": "Sciex", "shimadzu": "Shimadzu", "waters": "Waters", "other": "Other", "none" : "None"};
        const metab_metric_names = {"mass_error_ppm_Neg": "Mass Error (ppm)",
                                    "mass_error_ppm_Pos": "Mass Error (ppm)",
                                    "rt": "Retention Time", "area_normalised": "Area (normalised)"};

        // obj convert to display names from summary
        let metrics_obj_metab = {
                    "mass_error_ppm_Neg" :"Mass Error (ppm)",
                    "mass_error_ppm_Pos" :"Mass Error (ppm))",
                    "rt": "Retention Time",
                    "area_normalised": "Area (normalised)"
                }

        // convert dates, pressure profile and summary
        for(let i in machine_data.run_data){
            // dates
            machine_data.run_data[i].date_time = new Date(machine_data.run_data[i].date_time);

            // summaries
            try{
                var summary = JSON.parse(machine_data.run_data[i].summary[0].summary);
                machine_data.run_data[i].summary = summary;
                }
                catch(e){ // undefined, no summary data (should always be!!)
                    machine_data.run_data[i].summary = false;
                    //console.log(e);
            }

            // pressure
            if(machine_data.machine_details.machine_type == "thermo"){ // pressure profile thermo only
                try{
                    var profile = JSON.parse(machine_data.run_data[i].pressure_profile[0][0].pressure_data);
                    machine_data.run_data[i].pressure_profile = profile;
                }
                catch(e){ // undefined, no pressure data
                    machine_data.run_data[i].pressure_profile = {};
                }
            }
        }
        
        // convert chromatograms
        for(let i in machine_data.components){
            for(let j in machine_data.components[i].chromatograms){
                try{
                    var new_chrom_data = JSON.parse(machine_data.components[i].chromatograms[j][0].chrom_data);
                    machine_data.components[i].chromatograms[j] = new_chrom_data;
                }
                catch{ // no chrom data
                    machine_data.components[i].chromatograms[j] = {};
                }
            }
        } 

        // convert chrom x-values and create d3 data (REMOVE with trans updates)
        for(let i in machine_data.components){
            for(let j in machine_data.components[i].chromatograms){
                var cgram = machine_data.components[i].chromatograms[j];

                // no chrom data
                if(Object.keys(cgram).length == 0){
                    machine_data.components[i].chromatograms[j] = []; 
                    continue;
                }

                // get values to plot (and store max)
                var y_values = cgram.intensities;
                var x_values_deltas = cgram.rts;

                // transform x values from deltas
                var last = 0;
                //var x_values = [];
                var data = [];
                for(let x in x_values_deltas){
                    let current = x_values_deltas[x] / 1000 + last;
                    //let new_row = {"x": (total + x_values_deltas[x])/60, "y": y_values[x]};
                    let new_row = {"x": current, "y": y_values[x]};
                    data.push(new_row);
                    last = current;
                }

                // store
                machine_data.components[i].chromatograms[j] = data;
            }
        }

        /* Impute Missing Values - LCMS*/
        // mda, ppm +- 1000
        // RT, FWHM 0
        // Area Height -100
        // Tailing, Asymmetry 0,1 (CHECK: 1??)
        // REFACTOR?: set missings to null in processing and catch 
        var impute_names = ["Mass Error (ppm)", "Mass Error (mDa)", "Area (normalised)", "Height (normalised)"];
        for(let i in machine_data.components){
            var metric_data = machine_data.components[i].lcms_metrics;
            // loop metrics
            for(let metric in metric_data){
                var missing_indexes = []; // add marker on chart
                // values in array
                for(let value in metric_data[metric]){
                    if(impute_names.includes(metric)){
                        if(metric_data[metric][value] <= -100 || metric_data[metric][value] >= 100){ 
                            if(value > 0){
                                machine_data.components[i].lcms_metrics[metric][value] = machine_data.components[i].lcms_metrics[metric][value - 1];
                                missing_indexes.push(parseInt(value));
                            }
                            else{ // if first then just set to zero
                                machine_data.components[i].lcms_metrics[metric][value] = 0;
                                missing_indexes.push(parseInt(value));
                            }
                        }
                    }
                    else{
                        if(metric_data[metric][value] == 0 || metric_data[metric][value] == 1){
                            if(value > 0){
                                machine_data.components[i].lcms_metrics[metric][value] = machine_data.components[i].lcms_metrics[metric][value - 1];
                                missing_indexes.push(parseInt(value));
    
                            }
                            else{ // if first then just set to zero
                                machine_data.components[i].lcms_metrics[metric][value] = 0;
                                missing_indexes.push(parseInt(value));
                            }
                        }
                    }  
                }
                // add new values and missing to machine_data obj
                var values = machine_data.components[i].lcms_metrics[metric];
                machine_data.components[i].lcms_metrics[metric] = {"values": values, "missing": missing_indexes}   
            }
        }

        /* Impute Missing Values - Pressure*/
        /* Possible nulls but may change in processing */
        if(machine_data.machine_details.machine_type == "thermo"){
            for(let i in machine_data.pressure_metrics){
                var missing_indexes = [];
                for(let value in machine_data.pressure_metrics[i].values){
                    var new_value = machine_data.pressure_metrics[i].values[value];
                    if(new_value == null){
                        if(value==0){ // if first just put to zero
                            machine_data.pressure_metrics[i].values[value] = 0
                            missing_indexes.push(parseInt(value));
                        }
                        else{
                            machine_data.pressure_metrics[i].values[value] = machine_data.pressure_metrics[i].values[value-1];
                            missing_indexes.push(parseInt(value));
                        }
                    }
                }
                machine_data.pressure_metrics[i]["missing"] = missing_indexes;
            }
        }

        if(machine_data.machine_details.machine_type == "thermo"){
        // catch mismatch of #RUNS to metric values (less MIPS in testing)
            for(let i in machine_data.pressure_metrics){
                var new_index = machine_data.pressure_metrics[i].values.length;
                while(machine_data.pressure_metrics[i].values.length != machine_data.run_data.length){
                    machine_data.pressure_metrics[i].values.push(0);
                    machine_data.pressure_metrics[i].missing.push(new_index);
                    new_index += 1;
                }
            }
        }

        // add yscale/xscale storage for zoom LCMS
        for(let i in machine_data.lcms_metrics){
            machine_data.lcms_metrics[i].yScale = null;
            //machine_data.lcms_metrics[i].xScale = null;
            machine_data.lcms_metrics[i].lineWidth = null;
            machine_data.lcms_metrics[i].radius = null;
        }

        if(machine_data.machine_details.machine_type == "thermo"){
            // add yscale/xscale storage for zoom PRESSURE
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].lineWidth = null;
                machine_data.pressure_metrics[i].radius = null;
            }
        }

        /*** DUMMY DATA **/
        /*
        var nextID = 20;
        var nextRT = 20;
        var nameNumber = 1;
        var cModes = ["N", "N", "P", "P", "P" ,"P", "P"] // 2neg, 5pos

        for(let k in cModes){
            var newComp = {"component_name": "Metabolite_"+nameNumber, 
                            "component_id": nextID,
                            "component_mode" : cModes[k],
                            "chromatograms": machine_data.components[nameNumber]["chromatograms"],
                            "stats": machine_data.components[nameNumber]["stats"],
                            "lcms_metrics": {"Mass Error (ppm)": {"values":[], "missing":[]},
                                            "Mass Error (mDa)": {"values":[], "missing":[]},
                                            "Area (normalised)": {"values":[], "missing":[]},
                                            "Height (normalised)": {"values":[], "missing":[]},
                                            "Retention Time": {"values":[], "missing":[]},
                                            "Tailing": {"values":[], "missing":[]},
                                            "Asymmetry": {"values":[], "missing":[]},
                                            "Full Width Half Maximum": {"values":[], "missing":[]}}
                        }
            var TestMetrics = ["Mass Error (ppm)", "Mass Error (mDa)", "Area (normalised)",
                            "Height (normalised)", "Retention Time", "Tailing", "Asymmetry", "Full Width Half Maximum"];
            
            for(let j in TestMetrics){
                var new_values= [];
                for(let i =0; i<machine_data.run_data.length; i++){
                    if(TestMetrics[j] == "Mass Error (ppm)" || TestMetrics[j] == "Mass Error (mDa)" || TestMetrics[j] == "Area (normalised)" || TestMetrics[j] == "Height (normalised)"){
                        var newSign = 1;
                        if(Math.random() > 0.5){
                            var newSign = -1;
                        }
                        new_values.push((Math.random() * 3)*newSign);
                    }
                    else if(TestMetrics[j] == "Retention Time"){
                        new_values.push(nextRT + (Math.random() * 1.5));
                    }
                    else if(TestMetrics[j] == "Tailing" || TestMetrics[j] == "Asymmetry"){
                        new_values.push(Math.random() * 2);
                    }
                    else if(TestMetrics[j] == "Full Width Half Maximum"){
                        new_values.push(Math.random() * 30);
                    }
                }
                newComp["lcms_metrics"][TestMetrics[j]]["values"] = new_values;
            }

            machine_data["components"].push(newComp);
            nextID += 1;
            nextRT += 2;
            nameNumber += 1;
        }
        */

        //*** colours (12 components max per mode.. set in config) **/

        // darkSet (DarkBlue, DarkMagenta, Darkgreen, DarkOrange ,HotPink)
        //          (DarkRed ,Gold, DarkSeaGreen, Dark Torqoiuse, Indigo)
        //          (DarkGray, SaddleBrown, DeepSkyBlue, DeepPink, IndianRed)

        // lightSet (LightSkyBlue, LightPink ,LightGreen, khaki, LightSalmon)
        //          (PaleVioletRed, PaleGoldenRod, LightCyan, PaleTorqoiuse, MediumPurple)
        //          (Gainsboro, SandyBrown, LightSteelBlue, MistyRose, LightCoral)

        // https://carto.com/carto-colors/
        var cartoPastel = ["#66C5CC","#F6CF71","#F89C74","#DCB0F2",
                        "#87C55F","#9EB9F3","#FE88B1","#C9DB74","#8BE0A4","#B497E7","#D3B484","#B3B3B3"];
        
        var cartoPrism = ["#5F4690","#1D6996","#38A6A5","#0F8554",
                        "#73AF48","#EDAD08","#E17C05","#CC503E","#94346E","#6F4070","#994E95","#666666"];
        
        var cartoBold = ["#7F3C8D","#11A579","#3969AC","#F2B701",
                        "#E73F74","#80BA5A","#E68310","#008695","#CF1C90","#f97b72","#4b4b8f","#A5AA99"];

        var cartoAntique = ["#855C75","#D9AF6B","#AF6458","#736F4C",
                            "#526A83","#625377","#68855C","#9C9C5E","#A06177","#8C785D","#467378","#7C7C7C"];

        var cartoSafe = ["#88CCEE","#CC6677","#DDCC77","#117733",
                        "#332288","#AA4499","#44AA99","#999933","#882255","#661100","#6699CC","#888888"];

        var cartoVivid = ["#E58606","#5D69B1","#52BCA3","#99C945",
                        "#CC61B0","#24796C","#DAA51B","#2F8AC4","#764E9F","#ED645A","#CC3A8E","#A5AA99"];

        var darkSet = ["#00008B", "#8B008B", "#006400", "#FF8C00", "#FF69B4",
                        "#8B0000", "#FFD700", "#8FBC8F", "#00CED1","#4B0082",
                        "#A9A9A9","#8B4513", "#00BFFF","#FF1493", "#CD5C5C"];
        var lightSet = ["#87CEFA", "#FFB6C1", "#90EE90", "#F0E68C", "#FFA07A",
                        "#DB7093", "#EEE8AA", "#E0FFFF", "#AFEEEE", "#9370DB",
                        "#DCDCDC", "#F4A460", "#B0C4DE", "#FFE4E1", "#F08080"];

        // https://upload.wikimedia.org/wikipedia/commons/9/96/Farbkreis_mit_CMYK-Werten.png
        var colourWheelDark = ["#0066FF", "#0019FF", "#3300FF", "#9900FF", "#FF0000",
                                "#FF1933", "#FF5900", "#FF9900", "#FFFF00", "#FFFF00",
                                "#00FF19", "#00FF99"];

        var colourWheelLight = ["#B3D9FF", "#8C99FF", "#BFB3FF", "#E6CCFF", "#FFBFD9",
                                "#FFCCCC", "#FFD9CC", "#FFE6CC", "#FFFFCC", "#E6FFCC",
                                "#BFFFCC", "#BFFFE6"];

        // deepskyblue, blue, darkviolet ,deeppink, red, orange
        // gold, chocolate, greenyellow, limegreen, lightseagreen, cyan
        var darkSet2 = ["#00BFFF", "#0000FF", "#9400D3", "#FF1493", "#FF0000", "#FFA500",
                        "#FFD700", "#D2691E", "#ADFF2F", "#32CD32", "#20B2AA", "#00FFFF"];

        // powderblue. steelblue. plum, pink, indianred, lightsalmon
        // darkkhaki, goldenrod, mediumseagreen, palegreen, darkseagreen, pale torqouise
        var lightSet2 = ["#B0E0E6","#4682B4", "#DDA0DD", "#FFC0CB", "#CD5C5C", "#FFA07A",
                        "#BDB76B","#DAA520", "#3CB371", "#98FB98", "#8FBC8F", "#AFEEEE"];

        // old colours
        var neg_colours = d3.schemeCategory10; // 10 colours
        var pos_colours = d3.schemeDark2; // 8 colours
        var extra_colours = d3.schemeAccent; // 8 colours
        var extra_colours2 = d3.schemePaired; // 8 colours
        var extra_colours3 = d3.schemeSet3; // 8 colours
        var lightSet3 = d3.schemeTableau10;
        lightSet3.push(extra_colours3[0]);
        lightSet3.push(extra_colours3[11]);
        extra_colours2[10] = lightSet2[6]; // swap out pale yellows (dont work with light)
        extra_colours3[1] = lightSet2[7];

        // add 7 extras pos (15 allowed) CNANGE to 12
        for(let i = extra_colours.length - 1; i> extra_colours.length - 8; i--){
            pos_colours.push(extra_colours[i]);
        }

        // add 5 extras neg (15 allowed)
        for(let i = extra_colours2.length - 1; i> extra_colours2.length - 6; i--){
            neg_colours.push(extra_colours2[i]);
        }

        var n_index = 0;
        var p_index = 0;
        for(let i in machine_data.components){
            if(machine_data.components[i].component_mode == "P"){
                machine_data.components[i]["colour"] = cartoPastel[p_index];
                p_index +=1;
            }
            else if(machine_data.components[i].component_mode == "N"){
                machine_data.components[i]["colour"] = cartoPrism[n_index];
                n_index +=1;
            }
        }


        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

            console.log(machine_data);

            // set layout variables
            var navHeight = document.getElementById("navcontainer").clientHeight;
            chart_height = parseInt((window.innerHeight-navHeight)*2/3)/16; // in rem at 16
            header_height = parseInt((window.innerHeight-navHeight)*1/3)/16;
            v_height_unit = window.innerHeight/100;
            v_width_unit = window.innerWidth/100;

            // set chart element sizes
            base_radius = 3*v_height_unit/5;
            radius = base_radius; // min for line charts 
            currentRadius = radius*2;
            base_line_width = base_radius/2;
            lineWidth = base_line_width; // min for line charts 

            // update home tooltip
            var home = document.getElementById("home");
            home.setAttribute("data-tooltip", "Click for Summary Page");

            
            // create a global tooltip for charts
            let tooltip = d3.select("body") 
                .append("div")
                .attr("class", "configTooltip")
                .attr("id", "tooltip")
                .style("visibility", "hidden");

            // create a draggable tooltip (chrom)
            d3.select("body") 
                .append("div")
                .attr("class", "dragTooltip")
                .attr("id", "chromTool")
                .style("visibility", "hidden");

            dragElement(document.getElementById("chromTool"));

            // create a draggable tooltip (pressure))
            d3.select("body") 
                .append("div")
                .attr("class", "dragTooltip")
                .attr("id", "pressureTool")
                .style("visibility", "hidden");

            dragElement(document.getElementById("pressureTool"));
            
            
            create_layout();
            create_header_display();
            create_navbar_dropdown();
            create_chromatogram();

            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                create_pressure_profile();
            }
            
            // create checked components look up (initial all neg)
            for(let i=0; i<machine_data.components.length; i++){
                if(machine_data.components[i].component_mode == "N"){
                    checked_components[machine_data.components[i].component_name] = true;
                }
                else{
                    checked_components[machine_data.components[i].component_name] = false;
                }
            }
            
            // create a draggable menu
            d3.select("body") 
                .append("div")
                .attr("id", "menu")
                .attr("class", "dragMenu")
                .style("width", "25vw")
                .style("visibility", "hidden");

            // make draggable
            dragElement(document.getElementById("menu"));
            document.getElementById("menu").style.display = "block";
            
            create_components_menu(true);
            create_chart_area();
            create_metric_menu(true); // needs display 

             // set controls hide/show
             var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");

            if(controls){
                chart_top.style.display = "block";
                chart_bottom.style.display = "block";
            } else{
                chart_top.style.display = "none";
                chart_bottom.style.display = "none";
            }

            // draw initial chart
            draw_force_main(false);
            
            // check theme radios
            if(theme == "dark"){
                document.getElementById("darkRadio").checked = true;
                document.getElementById("lightRadio").checked = false;

            }
            else{
                document.getElementById("darkRadio").checked = false;
                document.getElementById("lightRadio").checked = true;
            }

            // disable buttons based on display metric from summary
            if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                document.getElementById("box").disabled = true;
            }
            else if(display_metric == "Retention Time"){
                document.getElementById("heat").disabled = true;
            }
            else if(display_metric == "Full Width Half Maximum"){
                document.getElementById("heat").disabled = true;
            }

        }, false);
        
        function create_layout(){
            // get grid
            var grid = document.getElementById("grid");

            // create firt row
            var first_row = document.createElement("div");
            first_row.className = "row";
            //first_row.style.height = header_height + "rem";

            // chromatogram
            var new_col_1 = document.createElement("div");
            new_col_1.className = "col-sm-3 chart-cell";
            new_col_1.style.height = header_height + "rem"; 
            new_col_1.id = "cgram";
            first_row.append(new_col_1);

            // header display area
            var new_col_2 = document.createElement("div");
            new_col_2.className = "col-sm-6 chart-cell";
            new_col_2.style.height = header_height + "rem"; // may need to add to other cols
            new_col_2.id = "header";
            first_row.append(new_col_2);

            // pressure profile
            var new_col_3 = document.createElement("div");
            new_col_3.className = "col-sm-3 chart-cell";
            new_col_3.style.height = header_height + "rem";
            new_col_3.id = "pressure";
            first_row.append(new_col_3);

            // second row
            var second_row = document.createElement("div");
            second_row.className = "row";
            second_row.style.height = chart_height + "rem";

            // components
            var new2_col_1 = document.createElement("div");
            new2_col_1.className = "col-sm-3 chart-cell";
            new2_col_1.style.height = chart_height + "rem";
            new2_col_1.id = "components";
            second_row.append(new2_col_1);

            // chart area
            var new2_col_2 = document.createElement("div");
            new2_col_2.className = "col-sm-9 chart-cell";
            new2_col_2.style.height = chart_height + "rem";
            new2_col_2.id = "chart";
            second_row.append(new2_col_2);

            // menu
            //var new2_col_3 = document.createElement("div");
            //new2_col_3.className = "col-sm-3 chart-cell";
            //new2_col_3.style.height = chart_height + "rem";
            //new2_col_3.id = "menu";
            //second_row.append(new2_col_3);

            // add rows to grid
            grid.append(first_row);
            grid.append(second_row);
        }

        function create_pressure_profile(){
            // get container
            var profile_div = document.getElementById("pressure");

            // div for content (add flip tile for proteomics: 2 pumps)
            var profile_inner = document.createElement("div");
            profile_inner.style.position = "absolute";
            profile_inner.style.left = "0%";
            profile_inner.style.top = "2.5%"; 
            profile_inner.style.width = "92.5%";
            profile_inner.style.height = "95%";
            profile_inner.style.borderTopLeftRadius = "0em";
            profile_inner.style.borderBottomLeftRadius = "0em";
            //profile_inner.style.backgroundColor = "var(--dark)";
            if(theme == "dark"){profile_inner.className = "darkTheme Theme";}
            else{profile_inner.className = "lightTheme Theme";}
            //profile_inner.style.boxShadow = "1vh 1vh 0.5vh var(--gray)";
            profile_inner.style.fontSize = "2vh";
            profile_inner.style.opacity = 0;
            //profile_inner.style.overflow = "hidden";
            profile_inner.id = "profile_inner";
            
            // header
            var profile_header = document.createElement("p");
            profile_header.innerHTML = "PRESSURE PROFILE";
            profile_header.style.backgroundColor = "var(--dark)";
            profile_header.style.color = "var(--white)";
            profile_header.className = "text-center";
            profile_header.style.fontSize = "1.8vh";
            profile_header.style.fontWeight = 700;
            //profile_header.style.height = "9%";
            profile_header.id = "profile_header";

            // pump header
            var profile_pump_header = document.createElement("p");
            profile_pump_header.innerHTML = "Main Pump";
            //profile_pump_header.style.backgroundColor = "lightgray";
            if(theme == "dark"){profile_pump_header.className = "text-center headerDarkTheme Theme";}
            else{profile_pump_header.className = "text-center headerLightTheme Theme";}
            //profile_pump_header.style.fontWeight = "bold";
            //profile_pump_header.className = "text-center";
            //profile_pump_header.style.fontSize = "0.6em";
            profile_pump_header.style.height = "9%";
            profile_pump_header.id = "profile_pump_header";

            // append headers and inner 
            profile_inner.append(profile_header);
            profile_inner.append(profile_pump_header);

            // plot area 
            var plot_area = document.createElement("div");
            plot_area.id = "plot_pressure";
            plot_area.style.width = "100%";
            plot_area.style.height = "82%";
            plot_area.style.opacity = 0;

            // put on overlay if not thermo
            if(machine_data.machine_details.machine_type != "thermo"){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Pressure Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                new_display.id = "pressure_overlay";
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_pressure").transition(t).style("opacity", 0.5);

            }
            profile_inner.append(plot_area);
            profile_div.append(profile_inner);

            // draw the profile for thermo machines
            if(machine_data.machine_details.machine_type == "thermo"){ 
                draw_pressure_profile(false);
            }

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#profile_inner").transition(t).style("opacity", 1);

        }

        function create_chromatogram(){
            // get container
            var cgram_div = document.getElementById("cgram");

            // div for content
            var cgram_inner = document.createElement("div");
            cgram_inner.style.position = "absolute";
            cgram_inner.style.left = "2.5%";
            cgram_inner.style.top = "2.5%"; 
            cgram_inner.style.width = "97.5%";
            cgram_inner.style.height = "95%";
            //cgram_inner.style.backgroundColor = "var(--dark)";
            if(theme == "dark"){cgram_inner.className = "darkTheme Theme";}
            else{cgram_inner.className = "lightTheme Theme";}
            cgram_inner.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            cgram_inner.style.borderTopRightRadius = "0em";
            cgram_inner.style.borderBottomRightRadius = "0em";
            cgram_inner.style.fontSize = "2vh";
            cgram_inner.style.opacity = 0;
            //cgram_inner.style.overflow = "hidden";
            cgram_inner.id = "cgram_inner";

            // cgram header
            var cgram_header = document.createElement("p");
            cgram_header.innerHTML = "CHROMATOGRAM";
            cgram_header.style.backgroundColor = "var(--dark)";
            cgram_header.style.color = "var(--white)";
            cgram_header.className = "text-center";
            cgram_header.style.fontSize = "1.8vh";
            cgram_header.style.fontWeight = 700;
            //cgram_header.style.height = "9%";
            cgram_header.id = "cgram_header";

            // cgram metric header
            var cgram_metric_header = document.createElement("p");
            if(theme == "dark"){cgram_metric_header.className = "text-center headerDarkTheme Theme";}
            else{cgram_metric_header.className = "text-center headerLightTheme Theme";}
            cgram_metric_header.id = "cgram_metric_header";

            // plot area 
            var plot_area = document.createElement("div");
            plot_area.id = "plot_cgram";
            plot_area.style.width = "100%";
            plot_area.style.height = "82%";
            plot_area.style.opacity = 0;
            
            cgram_inner.append(cgram_header);
            cgram_inner.append(cgram_metric_header);
            cgram_inner.append(plot_area);
            cgram_div.append(cgram_inner);

            // draw
            draw_chromatogram(false);

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#cgram_inner").transition(t).style("opacity", 1);
        }

        

        function create_components_menu(transition){
            // get container
            var comp_menu_div = document.getElementById("components");

             // remove any elements
             while (comp_menu_div.firstChild) {
                comp_menu_div.removeChild(comp_menu_div.firstChild);
            }

            // div for content
            var comp_menu_inner = document.createElement("div");
            comp_menu_inner.style.position = "absolute";
            comp_menu_inner.style.left = "2.5%";
            comp_menu_inner.style.top = "2.5%"; 
            comp_menu_inner.style.width = "97.5%";
            //comp_menu_inner.style.height = "95%";
            comp_menu_inner.style.fontSize = "1.6vh";
            comp_menu_inner.style.opacity = 0;
            comp_menu_inner.id = "comp_menu_inner";

            // add check boxes and labels

            // mode arrays (make global?)
            var positive = [];
            var negative = [];
            for(let i=0; i<machine_data.components.length; i++){
                var new_comp ={"component_name": machine_data.components[i].component_name,
                                    "colour": machine_data.components[i].colour,
                                    "c_index": i}
                if(machine_data.components[i].component_mode == "P"){
                    positive.push(new_comp);
                }
                else if(machine_data.components[i].component_mode == "N"){
                    negative.push(new_comp);
                }
            }

            // get thresholds (all)
            var thresh_metrics = {};
            if(metric_type == "lcms"){
                var thresh_metrics = machine_data.run_data[run_index].summary;
            }
            
            // get thresholds (display metric)
            var thresh_comp = {};
            for(let t in thresh_metrics){
                if(metab_metric_names[t] == display_metric){
                    thresh_comp = thresh_metrics[t];
                }
            }
            
            /* menu left (positive) */
            var menu_left_div = document.createElement("div");
            menu_left_div.style.position = "absolute";
            menu_left_div.style.width = "50%";
            //menu_left_div.style.height = "100%";
            menu_left_div.style.borderTopRightRadius = "0em";
            menu_left_div.style.borderBottomRightRadius = "0em";
            menu_left_div.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            menu_left_div.style.top = 0;
            menu_left_div.style.left = 0;
            menu_left_div.id = "compMenuLeft";
            //menu_left_div.className = "text-center lightTheme";
            //menu_left_div.style.paddingLeft = "1em";
            //menu_left_div.style.backgroundColor = "whitesmoke";
            //menu_left_div.style.overflow = "auto";
            if(theme == "dark"){menu_left_div.className = "text-center darkTheme Theme";}
            else{menu_left_div.className = "text-center lightTheme Theme";}

            // title
            var new_pos_title = document.createElement("p");
            //new_pos_title.style.fontSize = "1vw";
            new_pos_title.style.color = "white";
            new_pos_title.style.backgroundColor = "var(--dark)";
            new_pos_title.className = "menuBorder2 text-center";
            new_pos_title.style.width = "95%";
            new_pos_title.style.fontWeight = 700;
            new_pos_title.innerHTML = "POSITIVE METABOLITES";
            menu_left_div.append(new_pos_title);

            // append to DOM before SVG menu
            comp_menu_inner.append(menu_left_div);
            comp_menu_div.append(comp_menu_inner);

            createSVGMenu(menu_left_div.id, positive, "positive", thresh_comp);

            // add select all
            var new_label = document.createElement("label");
            new_label.className = "container control text-center";
            new_label.id = "pos_sa";
            new_label.setAttribute("data-c-index", -1);
            new_label.innerHTML = "SELECT ALL";
            new_label.addEventListener("click", clickSelectAll);
            new_label.style.borderRadius = "1em";
            new_label.style.width = "90%";
            new_label.style.padding = "0.1em";
            new_label.style.marginLeft = "auto";
            new_label.style.marginRight = "auto";
            new_label.style.backgroundColor = "var(--dark)";
            new_label.style.color = "var(--white)";
            //new_label.style.borderTop = "0.2em solid var(--info)";
            //new_label.style.borderRight = "0.2em solid var(--info)";
            new_label.style.border = "0.2em solid var(--info)";
            var new_label_right = new_label.cloneNode(true); //clone for right
            new_label_right.addEventListener("click", clickSelectAll);
            new_label_right.id = "neg_sa";
            menu_left_div.append(new_label);
            
            /* menu right (negative) */
            var menu_right_div = document.createElement("div");
            menu_right_div.style.position = "absolute";
            menu_right_div.style.borderTopLeftRadius = "0em";
            menu_right_div.style.borderTopRightRadius = "0em";
            menu_right_div.style.borderBottomRightRadius = "0em";
            menu_right_div.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            menu_right_div.style.width = "50%";
            //menu_right_div.style.height = "100%";
            menu_right_div.style.top = 0;
            menu_right_div.style.right = 0;
            menu_right_div.id = "compMenuRight";
            //menu_right_div.className = "text-center lightTheme";
            //menu_right_div.style.paddingLeft = "1em";
            //menu_right_div.style.overflow = "auto";
            if(theme == "dark"){menu_right_div.className = "text-center darkTheme Theme";}
            else{menu_right_div.className = "text-center lightTheme Theme";}

            // title
            var new_neg_title = document.createElement("p");
            //new_neg_title.style.fontSize = "1vw";
            new_neg_title.style.color = "var(--white)";
            new_neg_title.style.backgroundColor = "var(--dark)";
            new_neg_title.style.width = "95%";
            new_neg_title.style.fontWeight = 700;
            new_neg_title.className = "menuBorder2 text-center";
            new_neg_title.innerHTML = "NEGATIVE METABOLITES";
            menu_right_div.append(new_neg_title);

            // append to DOM before SVG menu
            comp_menu_inner.append(menu_right_div);
            createSVGMenu(menu_right_div.id, negative, "negative", thresh_comp);

            // add select all
            menu_right_div.append(new_label_right);

            // update checked components
            d3.selectAll(".menuCircle")
            .style("fill", function(d, i){
                if(checked_components[d.component_name]){
                    return d.colour;//"url(#circleGradLight"+d.c_index+")";
                }
                else{
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                }
            });

            // transition on load
            var t = d3.transition().duration(1500);
            if(transition){
                d3.select("#comp_menu_inner").transition(t).style("opacity", 1);
            }
            else{
                d3.select("#comp_menu_inner").style("opacity", 1);
            }

            // transition new threshold icons
            d3.selectAll(".new_icon").transition(t).duration(500).style("opacity", 1);
        }

        function test_move_chromatogram(){
             // get chromatogram data (comp, run)
             var cgram = machine_data.components[comp_index].chromatograms[run_index];

             // get values to plot
            var y_values = cgram.intensities;
            var x_values_deltas = cgram.rts;
        
            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }

            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // store old x_values (superKeys)
            // draw and get path
            // interpolate for new Ys
            // get current x-domain

        }

        function draw_chromatogram(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_cgram");
            var cgram_header = document.getElementById("cgram_header");
            var cgram_inner = document.getElementById("cgram_inner");
            var cgram_metric_header = document.getElementById("cgram_metric_header");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot
            var margin = {top: v_height_unit, right: 0, bottom: 4*v_height_unit, left: 4*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // set metric header
            cgram_metric_header.innerHTML = machine_data.components[comp_index].component_name;

            // get chromatogram data (comp, run)
            var cgram = machine_data.components[comp_index].chromatograms[run_index];
            //console.log(cgram);

            // no cgram overlay
            if(cgram.length == 0){
                // remove any elements in plot area
                while (plot_area.firstChild) {
                    plot_area.removeChild(plot_area.firstChild);
                }
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Chromatogram Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_cgram").transition(t).style("opacity", 0.5);
                // update chrom tool
                if(chromModal){
                    d3.select("#chromTool").html(createToolHTML());
                    document.getElementById("chromClose").addEventListener("click", closeChromModal);
                    addWarningIcon();
                }
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
                plot_area.style.opacity = 1;
            }

            var maxY = d3.max(cgram, (d) => d.y);

            // y-scale
            var yScale = d3.scaleLinear()
            .domain([0, maxY + maxY/10])
            .range([height, 0]);

            // x scale
            /*
            if(xScale_chrom == null){
                xScale_chrom = d3.scaleLinear()
                .domain(d3.extent(cgram, function(d) { return d.x; }))
                .range([0, width]);
            }
            */

            // x scale
            var currentRT = machine_data.components[comp_index]["lcms_metrics"]["Retention Time"]["values"][run_index];
            xScale_chrom = d3.scaleLinear()
            .domain([currentRT - 1, currentRT + 1])
            .range([0, width]);

            // area under curve
            var area = d3.area().curve(d3.curveLinear)
                        .x(function(d) {return xScale_chrom(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale(d.y);});

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // margins

            // append the svg object to the plot area
            var svg = d3.select("#plot_cgram")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFill = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'chromFill')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFill.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '50%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'skyblue')
            .style('stop-opacity', 1);

            // background
            svg.
            append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("id", "backChrom")
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // x-scale
           
            // y-scale
          
            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale_chrom).tickSize(v_height_unit/2).ticks(5).tickSizeOuter(0);

            // grid x 
            var xAxisGrid = d3.axisBottom().scale(xScale_chrom)
            .tickSize(-height).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);

            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale)
            .tickSize(v_height_unit/2).tickSizeOuter(0).tickFormat(function(d){
                return (d/1000) + " K";
            });

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid y call
            svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("text-anchor", "middle")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("MINUTES");

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("INTENSITY");
            
            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip2") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // Add brushing
            var brush = d3.brushX()                   
                .extent([[0,0], [width,height]]) 
                .on("end", updateChart);
            
            // Create the line variable: both the line and the brush take place
            var line = svg.append('g')
            .attr("clip-path", "url(#clip2)");

            // Add the brushing
            line
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // plot the density distribution (area)
            line.append("path")
                .datum(cgram)
                .attr("fill", "url(#chromFill)") //url(#chromFill)
                .attr("fill-opacity", 1)
                .attr("stroke-width", lineWidth/4)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                }) 
                .attr("stroke-opacity", 0.7)
                .attr("class", "chromArea")
                .attr("cursor", "pointer")
                //.attr("filter", "url(#specular)")
                .attr("d", area)
                .on("mouseover", function(event){
                    
                    // return if modal mode
                    if(chromModal){return;}
                    
                    var tooltip = d3.select("#chromTool");

                    // display tooltip
                    tooltip.html(createToolHTML());
                    addWarningIcon();
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    if(chromModal){return;}
                    d3.select("#chromTool").style("visibility", "hidden");
                })
                .on("click", function(event, d){

                    var tooltip = d3.select("#chromTool");
                    // close if open
                    if(chromModal){
                        closeChromModal();
                        return;
                    }

                    // display tooltip
                    chromModal = true;
                    tooltip.html(createToolHTML());
                    document.getElementById("chromClose").addEventListener("click", closeChromModal);
                    addWarningIcon();
                    tooltip.style('left', (event.pageX) + 'px');
                    tooltip.style('top', (event.pageY) + 'px');
                    tooltip.style("visibility", "visible");
                });

            // y-axis calls
            svg.append("g")
                .call(y_axis)
                //.style('stroke-width', '0.4vh')
                .style('font-size', '1.2vh')
                .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + (height) + ")") 
            .call(x_axis)
            //.style('stroke-width', '0.4vh')
            .style('font-size', '1.2vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            function closeChromModal(){
                var tooltip = d3.select("#chromTool");
                tooltip.style("visibility", "hidden");
                chromModal = false;
            }

            function addWarningIcon(){
                
                // all metrics
                var metrics = machine_data.components[comp_index].lcms_metrics;
                
                // get thresholds (all)
                var thresh_metrics = machine_data.run_data[run_index].summary;
                
                // get thresholds (display metric)
                var thresh_comp = {};
                for(let t in thresh_metrics){
                    thresh_comp = thresh_metrics[t];
                }

                // convert for look-up
                thresh_metrics = Object.keys(thresh_metrics).map(key => metab_metric_names[key]);

                // add breach marker
                var preID = 0;
                for(let metric in metrics){
                    if(thresh_metrics.includes(metric)){
                        if(machine_data.components[comp_index].component_name in thresh_comp){
                            
                            var new_marker = document.createElement("span");
                            new_marker.style.padding = 0;
                            new_marker.className = "fas fa-exclamation-triangle text-danger new_icon";
                            document.getElementById("chromPre"+preID).append(new_marker);
                        }
                    }
                    preID += 1;
                }
            }

            function createToolHTML(){

                // get component details
                var comp_name = machine_data.components[comp_index].component_name;
                var comp_colour = machine_data.components[comp_index].colour;
                var metrics = machine_data.components[comp_index].lcms_metrics;

                if(!(checked_components[comp_name])){
                    var fill_colour = "var(--dark)";
                }
                else{
                    var fill_colour = comp_colour; //'url(#circleGradLight' + comp_index + ')';
                }

                // create tooltip content (circle)
                var tooltipHTML = "<svg width=" + 4*currentRadius + " height=" + 4*currentRadius + ">";
                tooltipHTML += "<circle r=" + currentRadius + " cx=" + 2*currentRadius + " cy=" + 2*currentRadius +
                                " filter = 'url(#specular)'" + " fill=" + fill_colour + " stroke=" + fill_colour +  " stroke-opacity='0.5' stroke-width=" + lineWidth/2 + "></svg>"
                
                // create tooltip content (metrics)
                var preID = 0;
                for(let metric in metrics){
                    var missing = metrics[metric].missing;
                    if(missing.includes(run_index)){
                        var value = "NO VALUE";
                    }
                    else{
                        var value = metrics[metric].values[run_index].toFixed(2);
                    }

                    var new_html = "<pre id=chromPre" + preID +  "><strong> " + metric + " " + "</strong><i>" + value + "</i></pre>";
                        tooltipHTML += new_html;

                    preID += 1;
                }

                // add close button
                if(chromModal){
                    var spanHTML = "<span id='chromClose' class='fas fa-window-close closeButton'></span>";
                    tooltipHTML += spanHTML;
                }
                return "<strong>" + comp_name + "</strong></br>" + tooltipHTML;
            }

            
            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateChart(event) {

                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    xScale_chrom.domain([xScale_chrom.invert(extent[0]), xScale_chrom.invert(extent[1])])
                    line.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                
                // Update axis and line position
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.chromArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area);
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                xScale_chrom.domain([d3.min(cgram, d=>d.x), d3.max(cgram, d=>d.x)])
                x_axis_call.transition().duration(1000).call(x_axis)
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.chromArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area);
            });
           
            // add transition
            if(transition){
                d3.select("#plot_cgram").style("opacity", 0).transition().duration(1000).style("opacity", 1);
            }

            // update chrom tool
            if(chromModal){
                d3.select("#chromTool").html(createToolHTML());
                document.getElementById("chromClose").addEventListener("click", closeChromModal);
                addWarningIcon();
            }
        }

        function update_pressure_profile(){
            var profile = machine_data.run_data[run_index].pressure_profile;
            if(Object.keys(profile).length == 0){
                draw_pressure_profile(true);
                return;
            }
            // get values to plot
            var y_values = profile.intensities;
            var x_values_deltas = profile.rts;

            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }

            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // y scale and axis
            yScale_profile.domain([0, d3.max(y_values) + d3.max(y_values)/10]);
            y_axis_pressure.scale(yScale_profile);
            d3.select("#pressureY").transition().duration(1000).call(y_axis_pressure);

            // area under curve
            var area = d3.area().curve(d3.curveMonotoneX)
                    .x(function(d) {return xScale_pressure(d.x);})
                    .y0(profileHeight)
                    .y1(function(d) { return yScale_profile(d.y);});
            
            d3.selectAll(".pressureArea")
            .datum(data)
            .transition().duration(1000)
            .attr('d', area);

        }

        function draw_pressure_profile(transition){
            
            // get width and height of plot area
            var plot_area = document.getElementById("plot_pressure");
            plot_area.style.opacity = 1; // not resetting after overlay
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;
            
        
            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // no profiles overlay
            var profile = machine_data.run_data[run_index].pressure_profile;
            if(Object.keys(profile).length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "No Pressure Data";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                new_display.style.opacity = 1;
                new_display.id = "pressure_overlay";
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_pressure").transition(t).style("opacity", 0.5);
                // update pressure tool
                if(pressureModal){
                    d3.select("#pressureTool").html(createToolHTMLPressure());
                    document.getElementById("pressureClose").addEventListener("click", closePressureModal);
                }
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
                plot_area.style.opacity = 1;
            }

            // get values to plot
            var y_values = profile.intensities;
            var x_values_deltas = profile.rts;

            // transform x values from deltas
            var total = 0;
            var x_values = [];
            for(let x in x_values_deltas){
                x_values.push((total + x_values_deltas[x])/60)
                total = total + x_values_deltas[x];
            }

            // convert to d3 friendly format
            var data = [];
            for(let i = 0; i<y_values.length; i++){
                let new_row = {'x': x_values[i], 'y': y_values[i]}
                data.push(new_row);
            }

            // set the dimensions and margins of the plot
            var margin = {top: v_height_unit, right: v_height_unit, bottom: 4*v_height_unit, left: 3*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            profileHeight = plot_height - margin.top - margin.bottom; // store for trans

            // append the svg object to the plot area
            var svg = d3.select("#plot_pressure")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFill = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'pressureFill')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFill.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '50%')
            .style('stop-color', 'var(--info)')
            .style('stop-opacity', 1);

            gradFill.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'skyblue')
            .style('stop-opacity', 1);


            // background
            svg.
            append("rect")
                .attr("id", "backPressure")
                .attr("width", width)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // x scale
            if(xScale_pressure == null){
                xScale_pressure = d3.scaleLinear()
                .domain([0, d3.max(x_values)])
                .range([0, width]);
            }
           
            // y-scale
            // d3.max(y_values) + d3.max(y_values)/10
            yScale_profile = d3.scaleLinear()
            .domain([0, d3.max(y_values) + d3.max(y_values)/10])
            .range([height, 0]);
          
            // x-axis function
            var x_axis = d3.axisBottom().ticks(5)
            .scale(xScale_pressure).tickSize(v_height_unit/2).tickSizeOuter(0);
                

            // grid x 
            // https://stackoverflow.com/questions/13669239/remove-end-ticks-from-d3-js-axis
            
            var xAxisGrid = d3.axisBottom().scale(xScale_pressure)
            .tickSize(-height).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid call x
            
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);
            

            // y-axis
            y_axis_pressure = d3.axisLeft().ticks(5).scale(yScale_profile).tickSize(v_height_unit/2);
                                

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale_profile).tickValues([40,80,120]).
            tickSize(-width).tickFormat('').ticks(5).tickSizeOuter(0);

            // grid y call
            svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);
                
            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom)
                .text("MINUTES");

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("BARS");

            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // Add brushing
            var brush = d3.brushX()                   
                .extent([[0,0], [width,height]]) 
                .on("end", updateChart);

            // Create the line variable:  both the line and the brush take place
            var line = svg.append('g')
            .attr("clip-path", "url(#clip)");

            // area under curve
            var area = d3.area().curve(d3.curveLinear)
                        .x(function(d) {return xScale_pressure(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale_profile(d.y);});

            // Add the brushing
            line
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // plot the density distribution (area)
            line.append("path")
                .datum(data)
                .attr("fill", "url(#pressureFill)")
                .attr("fill-opacity", 1)
                .attr("stroke-width", lineWidth/4)
                .attr("stroke", function(){
                    if(theme == 'dark'){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke-opacity", 1)
                .attr("class", "pressureArea")
                .style("cursor","pointer")
                //.attr("filter", "url(#specular)")
                .on("mouseover", function(event){
                    
                    // return if modal mode
                    if(pressureModal){return;}
                    
                    var tooltip = d3.select("#pressureTool");

                    // display tooltip
                    tooltip.html(createToolHTMLPressure());
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    if(pressureModal){return;}
                    d3.select("#pressureTool").style("visibility", "hidden");
                })
                .on("click", function(event, d){

                    var tooltip = d3.select("#pressureTool");
                    // close if open
                    if(pressureModal){
                        closePressureModal();
                        return;
                    }

                    // display tooltip
                    pressureModal = true;
                    tooltip.html(createToolHTMLPressure());
                    document.getElementById("pressureClose").addEventListener("click", closePressureModal);
                    tooltip.style('left', (event.pageX-30*v_width_unit) + 'px');
                    tooltip.style('top', (event.pageY + 10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .attr("d", area);

            // y-axis calls
            svg.append("g")
                .call(y_axis_pressure)
                //.style('stroke-width', '0.4vh')
                .style('font-size', '1.2vh')
                .attr('id', 'pressureY')
                .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });

            // x-axis call
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + (height) + ")")
            .call(x_axis)
            //.style('stroke-width', '0.4vh')
            .style('font-size', '1.2vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                });
        
        function closePressureModal(){
                var tooltip = d3.select("#pressureTool");
                tooltip.style("visibility", "hidden");
                pressureModal = false;
        }

        function createToolHTMLPressure(){

            var metrics = machine_data.pressure_metrics;

            // create tooltip content (metrics)
            var tooltipHTML = "";
            for(let metric in metrics){
                var missing = metrics[metric].missing;
                if(missing.includes(run_index)){
                    var value = "NO VALUE";
                }
                else{
                    var value = metrics[metric].values[run_index].toFixed(2);
                }

                var new_html = "<pre><strong> " + metrics[metric]["display_name"] + " " + "</strong><i>" + value + "</i></pre>";
                    tooltipHTML += new_html;
            }

            // add close button
            if(pressureModal){
                var spanHTML = "<span id='pressureClose' class='fas fa-window-close closeButton'></span>";
                tooltipHTML += spanHTML;
            }
            return "<strong>" + "MAIN PUMP" + "</strong></br>" + tooltipHTML;
        }
            
            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateChart(event) {

                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    xScale_pressure.domain([xScale_pressure.invert(extent[0]), xScale_pressure.invert(extent[1])])
                    line.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                
                // Update axis and line position
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.pressureArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area);
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                xScale_pressure.domain([d3.min(x_values), d3.max(x_values)]);
                x_axis_call.transition().duration(1000).call(x_axis);
                x_axis_grid_call.transition().duration(1000).call(xAxisGrid);
                line
                    .select('.pressureArea')
                    .transition()
                    .duration(1000)
                    .attr("d", area)
            });

            // update pressure tool
            if(pressureModal){
                d3.select("#pressureTool").html(createToolHTMLPressure());
                document.getElementById("pressureClose").addEventListener("click", closePressureModal);
            }
           
            // add transition
            if(transition){
                svg.style("opacity", 0).transition().duration(1000).style("opacity", 1);
            }
        }

        function changeControls(){
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var fromMain = false;

            // clicked from force nav
            if(mainForce){
                //mainForce = false;
                fromMain = true;
                // set reset controls
                if(controls){
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                    controls = false;
                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                    controls = true;
                }

                
                // set radios for line chart (enable all) and check radio
                var radios = document.getElementsByName("radioOptions");
                for(let i = 0; i<radios.length; i++){
                    //radios[i].disabled = false;
                    var radio_name = radios[i].labels[0].innerText;
                    if(radio_name == display_metric){
                        radios[i].checked = true;
                    }
                }

                draw_force_main(true);
                
            }
 
            
            if(!fromMain){
                // swap control state
                if(controls){
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                    controls = false;
                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                    controls = true;
                }
                controlsDraw();
            }
        }

        function create_header_display(){
            var header_container = document.getElementById("header");
            
            // div for content
            var header_inner = document.createElement("div");
            header_inner.style.position = "absolute";
            header_inner.style.left = "0%";
            header_inner.style.top = "2.5%"; 
            header_inner.style.width = "100%";
            header_inner.style.height = "95%";
            header_inner.style.opacity = 0;
            header_inner.style.borderRadius = "0em";
            header_inner.style.borderTop = "1.5vh solid white";
            header_inner.style.borderBottom = "1.5vh solid white";
            header_inner.style.backgroundColor = "var(--dark)";
            header_inner.style.color = "white";
            header_inner.className = "chartBorder";
            //header_inner.style.boxShadow = "1vh 1vh 0.5vh var(--gray)";
            header_inner.style.fontSize = "2.1vh";
            header_inner.id = "header_inner";
            //header_inner.style.overflow = "auto";

            // div for name and dropdown
            var instrument_div = document.createElement("div");
            instrument_div.className = "text-center";

            // machine name
            var new_machine_name = document.createElement("p");
            new_machine_name.style.fontSize = "1.5em";
            new_machine_name.style.fontWeight = "bold";
            new_machine_name.style.display = "inline-block";
            //new_machine_name.style.color = "var(--dark)";
            new_machine_name.innerHTML = machine_data.machine_details.machine_name;
            new_machine_name.className = "text-center";

            // instrument menu
            var menu_drop_div = document.createElement("div");
            menu_drop_div.setAttribute("aria-labelledby", "navbarDropdown");
            menu_drop_div.className = "dropdown-menu";
            menu_drop_div.id = "navbar-machines";
            
            var new_link = document.createElement("a");
            new_link.id = "navbarDropdown";
            new_link.className = "nav-link menu";
            new_link.style.display = "inline-block";
            new_link.style.marginLeft = "1em";
            new_link.setAttribute("data-toggle", "dropdown");
            new_link.setAttribute("href", "#");
            new_link.setAttribute("role", "button");
            new_link.setAttribute("aria-haspopup", "true");
            new_link.setAttribute("aria-expanded", "false");

            var new_icon_menu = document.createElement("span");
            new_icon_menu.className = "fas fa-angle-down";
            new_icon_menu.style.color = "whitesmoke";

            new_link.append(new_icon_menu);
            instrument_div.append(new_machine_name);
            instrument_div.append(new_link);
            instrument_div.append(menu_drop_div);

            // machine type
            var new_machine_type = document.createElement("p");
            new_machine_type.style.fontSize = "0.7em";
            new_machine_type.style.fontStyle = "italic";
            //new_machine_type.style.color = "var(--dark)";
            new_machine_type.innerHTML = machine_types[machine_data.machine_details.machine_type];
            new_machine_type.className = "text-center";

            // experiment
            let new_experiment = document.createElement("p");
            new_experiment.style.fontSize = "1em";
            new_experiment.innerHTML = machine_data.machine_details.experiment.toUpperCase();
            // add border to metab machines
            //new_experiment.style.backgroundColor = "lightgray";
            //new_experiment.style.color = "var(--dark)"
            new_experiment.style.width = "50%";
            //new_experiment.style.border = "0.3em double var(--dark)";
            new_experiment.style.marginRight = "auto";
            new_experiment.style.marginLeft = "auto";
            new_experiment.className = "text-center";
            
            // icon
            try{
                var summary_size = Object.keys(machine_data["run_data"][0].summary).length;}
            catch{
                var summary_size = 0;
            }
            let new_icon = document.createElement("span");
            //new_icon.style.margin = "0px";
            new_icon.style.padding = "0px";
            new_icon.style.fontSize = "1.5em";
            new_icon.id = "icon";
            new_icon.style.marginRight = "auto";
            new_icon.style.marginLeft = "auto";

            if(summary_size > 0){
                    new_icon.className = "fas fa-exclamation-triangle text-danger text-center";
                }
                else{
                    new_icon.className = "fas fa-check text-success text-center";
            }

            // icon div (for centering)
            var new_icon_div = document.createElement("div");
            new_icon_div.className = "text-center";
            new_icon_div.append(new_icon);
            
            // container for time duration and controls
            var new_container = document.createElement("div");
            new_container.style.width = "60%";
            new_container.style.marginRight = "auto";
            new_container.style.marginLeft = "auto";

            // left control
            var left_control = document.createElement("span");
            left_control.className = "fas fa-chevron-circle-left control";
            left_control.style.padding = "0px";
            left_control.style.float = "left";
            left_control.style.color = "white";
            left_control.id = "left-control";

            // button for left control
            var left_button = document.createElement("button");
            left_button.className = "btn";
            left_button.style.padding = "0px";
            left_button.style.fontSize = "1.5em";
            left_button.style.paddingLeft = "0.5em";
            left_button.style.float = "left";
            left_button.addEventListener("click", controlUpdate);
            left_button.append(left_control);

            // right control
            var right_control = document.createElement("span");
            right_control.className = "fas fa-chevron-circle-right";
            right_control.style.padding = "0px";
            right_control.style.float = "right";
            right_control.style.color = "white";
            right_control.id = "right-control";

            // button for right control
            var right_button = document.createElement("button");
            right_button.className = "btn";
            right_button.style.padding = "0px";
            right_button.style.fontSize = "1.5em";
            right_button.style.marginRight = "0.5em";
            right_button.style.float = "right";
            right_button.setAttribute("disabled", true); // add class outline class when enable
            right_button.addEventListener("click", controlUpdate);
            right_button.append(right_control);

            // add double arrow for latest
            var new_double = document.createElement("span");
            new_double.className = "fas fa-angle-double-right";
            new_double.style.padding = "0px";
            new_double.style.float = "right";
            new_double.style.display = "none";
            new_double.style.color = "white";
            new_double.id = "double";

            // button for double arrow
            var double_button = document.createElement("button");
            double_button.className = "btn";
            double_button.style.padding = "0px";
            double_button.style.fontSize = "1.5em";
            double_button.style.float = "right";
            double_button.addEventListener("click", controlDouble);
            double_button.append(new_double);

            // days since
            var new_date = machine_data.run_data[0].date_time;
            var days_since = diff_days(new_date);
            var new_duration = document.createElement("p");
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            new_duration.className = "text-center";
            new_duration.style.display = "inline_block";
            new_duration.style.fontWeight = "bold";
            new_duration.innerHTML = display_str;
            new_duration.id = "duration";

            // add to container
            //new_container.append(left_button);
            //new_container.append(double_button);
            //new_container.append(right_button);
            new_container.append(new_duration);

            // container for date and controls
            var new_container_date = document.createElement("div");
            new_container_date.style.width = "60%";
            new_container_date.style.marginRight = "auto";
            new_container_date.style.marginLeft = "auto";

            // date
            var new_date_tag = document.createElement("p");
            new_date_tag.innerHTML = new_date.toDateString();
            new_date_tag.className = "text-center";
            new_date_tag.style.width = "50%";
            new_date_tag.style.marginLeft = "auto";
            new_date_tag.style.marginRight = "auto";
            new_date_tag.style.borderTop = "0.3vh solid var(--white)";
            new_date_tag.style.borderBottom = "0.3vh solid var(--white)";
            new_date_tag.id = "date";

            new_container_date.append(left_button);
            new_container_date.append(double_button);
            new_container_date.append(right_button);
            new_container_date.append(new_date_tag);

            // time
            var new_time_tag = document.createElement("p");
            new_time_tag.style.fontSize = "1em";
            new_time_tag.className = "text-center";
            new_time_tag.innerHTML = get_time(new_date);
            new_time_tag.id = "time";

            // metric menu (OLD)
            var new_menu = document.createElement("span");
            new_menu.className = "fa fa-bars menuButton";
            new_menu.style.opacity = 0.8;
            new_menu.addEventListener("click", showMenu);

            // hide controls button (OLD)
            var new_nav = document.createElement("span");
            new_nav.className = "fa fa-cogs leftBottomMenuButton";
            new_nav.style.opacity = 0.8;
            new_nav.addEventListener("click", function(){changeControls();});

            // force nav (OLD)
            var new_bottom_nav = document.createElement("span");
            new_bottom_nav.className = "fa fa-sitemap leftMenuButton";
            new_bottom_nav.style.opacity = 0.8;
            new_bottom_nav.addEventListener("click", function(){
                mainForce = true;
                draw_force_main();});

            // add to DOM
            //header_inner.append(new_machine_name);
            header_inner.append(instrument_div);
            header_inner.append(new_experiment);
            header_inner.append(new_machine_type);
            header_inner.append(new_icon_div);
            header_inner.append(new_container);
            header_inner.append(new_container_date);
            //header_inner.append(new_date_tag);
            header_inner.append(new_time_tag);
            //header_inner.append(new_menu);
            //header_inner.append(new_nav);
            //header_inner.append(new_bottom_nav);
            header_container.append(header_inner);

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#header_inner").transition(t).style("opacity", 1);
  
        }

        

        function controlUpdate(el){
            
            // get all elements
            var icon = document.getElementById("icon");
            var left_control = document.getElementById("left-control"); //the icons
            var right_control = document.getElementById("right-control");
            var duration = document.getElementById("duration");
            var date = document.getElementById("date");
            var time = document.getElementById("time");
            var left_button = left_control.parentElement;
            var right_button = right_control.parentElement;
            var display_container = right_button.parentElement;
            var double_control = document.getElementById("double");
            var double_button = double_control.parentElement;

            if(el != "chart"){
                // run_index
                if(el.currentTarget.firstChild.id == "left-control"){
                    run_index += 1;
                }
                else if(el.currentTarget.firstChild.id == "right-control"){
                    run_index -= 1;
                }
            }

            // update elements
            
            // days since
            var new_date = machine_data.run_data[run_index].date_time;
            var days_since = diff_days(new_date);
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            duration.innerHTML = display_str;

            
            // icon
            try{
				var summary_size = Object.keys(machine_data["run_data"][run_index].summary).length;}
			catch{
				var summary_size = 0;
			}
			if(summary_size > 0){
					icon.className = "fas fa-exclamation-triangle text-danger text-center";
				}
				else{
					icon.className = "fas fa-check text-success text-center";
			}
        
            // date
            date.innerHTML = new_date.toDateString();

            // time
            time.innerHTML = get_time(new_date);

            // controls

            // end left
            if(run_index == (machine_data["run_data"].length - 1)){
                left_control.classList.remove("control");
                left_button.setAttribute("disabled", true);
            }
            
            // end right
            if(run_index == 0){
                right_control.classList.remove("control");
                right_button.setAttribute("disabled", true);
            }

            // in between
            if(run_index > 0 && run_index < (machine_data["run_data"].length-1)){
                left_button.removeAttribute("disabled");
                right_button.removeAttribute("disabled");
                if(!right_control.classList.contains("control")){
                    right_control.classList.add("control");
                }
                if(!left_control.classList.contains("control")){
                    left_control.classList.add("control");
                }
            }

            // double arrow
            if(run_index > 1){
                double_control.style.display = "inline";
                double_control.classList.add("control");
            }
            else{
                double_control.style.display = "none";  
                double_control.classList.remove("control");
            }

            // update plots
            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                //update_pressure_profile();
                //setTimeout(function(){
                    draw_pressure_profile(true);
                //}, 1000)
            }
            draw_chromatogram(true);
            
            // update for charts
            if(mainForce){
                // update sim and restart
                var graph = getGraph(forceWidth, forceHeight);
                simulation.force("link").links(graph.links);
                simulation.alpha(0.1).alphaDecay(0.05).restart();
                
                // update circle fill and value (for tween)
                d3.selectAll(".nodes")
                .transition().duration(500)
                .attr("fill", function(d){

                    if(d.nodeType == 2){
                        //if(theme == "dark"){return "var(--dark)"}
                        //return "white" ;
                        return "url(#middleCircleFill)";
                    }

                    // update value (in the data)
                    var thisNode = graph.nodes.filter(j => j.metricName == d.metricName && j.name == d.name);
                    d.actualValue = thisNode[0].actualValue;

                    var miss = machine_data.components[d.cIndex].lcms_metrics[d.metricName].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                

                // update warning icons
                d3.selectAll('.icons').transition().duration(500)
                .style("opacity", function(d,i){

                    // only comp nodes
                    if(d.nodeType == 2){
                        return 0;
                    }

                    // get thresholds (all)
                    var thresh_metrics = {};
                    if(metric_type == "lcms"){
                        var thresh_metrics = machine_data.run_data[run_index].summary;
                    }

                    // get thresholds per metric
                    var thresh_comp = {};
                    for(let t in thresh_metrics){
                        if(metab_metric_names[t] == d.metricName){
                            thresh_comp = thresh_metrics[t];
                        }
                    }

                    // show
                    if(d.name in thresh_comp){
                        return 1
                    }
                    return 0;
                    });

                // update averages
                d3.selectAll(".averages").filter(e => e.nodeType == 2)
                .transition().duration(800)
                .tween('updateAverages', function(d) {
                    
                    var self = this; // no this in d3 v4 in tween

                    // determine new total
                    var newTotal = 0;
                    var metricNodes = graph.nodes.filter(j => j.metricName == d.metricName && j.nodeType != 2);
                    var count = metricNodes.length; 
                    for(let node in metricNodes){
                        newTotal += metricNodes[node].value;
                    }
                    var newCurrent = (newTotal/count).toFixed(2);
                    

                    // Create an interpolator function
                    let i = d3.interpolate(parseFloat(d.current), parseFloat(newCurrent));

                    // update current
                    d.current = newCurrent;
                    
                    return function(t) {
                        let newAverage = i(t);
                    
                        d3.select(self)
                        .text(newAverage.toFixed(2));
                        
                    };
                });
                
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    moveBoxes(false); // move
                    setTimeout(function(){
                        moveBoxes(true);// then sort
                    },500);
                }
                else if(metric_type == "pressure"){
                    updatePressureCircles();
                }
            } // update for heat maps
            else if(chart_type == "heat"){
                updateHeatMarker();
                if(run_index >= filter){ // marker off screen
                    d3.select("#heatMarker").style("opacity", 0);
                }
                else{
                    d3.select("#heatMarker").style("opacity", 1);
                }
            } // update line chart marker
            else if(chart_type == "line"){
                updateMarker();
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_line_chart(false);
                    }
                    else{
                        draw_pressure_line(false);
                    }
                }, 1000);
            }
            else if(chart_type == "stream"){
                updateMarker();
                setTimeout(function(){
                    draw_stream_graph(false);
                }, 1000);
            }
            else if(chart_type == "density"){
                draw_density_plots(true);
            }
            else if(chart_type == "parallel"){
                update_parallel_graph();
                setTimeout(function(){
                    draw_parallel_graph(false);
                }, 1000);
            }
            

            // update menus
            create_metric_menu(false);
            create_components_menu(false);
        }

        function updateHeatMarker(){
            var marker = d3.select("#heatMarker");

            marker
            .transition()
            .duration(500)
            .attr("y1", cell_height*run_index + cell_height/2)
            .attr("y2", cell_height*run_index + cell_height/2);
        }

        function updateMarker(){
            var marker = d3.select("#marker");

            // move marker
            marker
            .transition()
            .duration(1000)
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("x2", xScale_chart(x_values_chart[run_index]));

            // update points
            d3.selectAll(".point")
            .transition()
            .duration(1000)
            .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
            });

            // raise current run
            d3.selectAll("#g"+run_index).raise()
            .transition()
            .duration(1000);
            
        }

        function updatePressureCircles(){
            var circles = d3.selectAll("circle");
            var lines = d3.selectAll(".extender");

            // y values and missing indexes
            var data= [];
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var new_obj = machine_data.pressure_metrics[i].stats;
                    new_obj["missing"] = machine_data.pressure_metrics[i].missing;
                    new_obj["current"] = machine_data.pressure_metrics[i].values[run_index];
                    data.push(new_obj);
                    break;
                }
            };

            // move circles
            circles
                .data(data)
                .transition()
                .duration(1000)
                .attr("cx", d => xScale_box(display_metric))
                .attr("cy", function(d){
                    // cap so does not go off chart
                    if(yScale_box(d.current) > box_area_height){
                        return  box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    
                    return yScale_box(d.current)
                })
                .attr("fill", function(d,j){
                    var miss = d.missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }
                    else if(yScale_box(d.current) > box_area_height){
                            return  "var(--info)";
                        }
                    else if(yScale_box(d.current)<0){
                        return "var(--info)";
                    }
                    else{
                        return "whitesmoke";
                    }
                });
            
            // move extenders
            lines
                .data(data)
                .transition()
                .duration(1000)
                .attr("y1", function(d){
                    var y1;
                    if(d.current >= d["75_percent"]){
                        y1 = yScale_box(d.current);
                    }
                    else if(d.current <= d["25_percent"]){
                        y1 = yScale_box(d["25_percent"]);
                    }
                    else{
                        y1 =  yScale_box(d.current);
                    }

                    // cap so does not go off chart
                    if(y1 < 0){
                        return 0;
                    }
                    return y1;
                })
                .attr("y2", function(d){
                    var y2;
                    if(d.current >= d["75_percent"]){
                        y2 = yScale_box(d["75_percent"]);
                    }
                    else if(d.current <= d["25_percent"]){
                        y2 = yScale_box(d.current);
                    }
                    else{
                        y2 = yScale_box(d.current);
                    }
                    // cap so does not go off chart
                    if(y2 > box_area_height){
                        return box_area_height;
                    }
                    return y2;
                });

        }

        function moveBoxes(sort){
            
                // get indexes of checked components
                var component_indexes = getComponentIndexes();

                var all_boxes = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_obj = {};
                        new_obj["mean"] = machine_data.components[i].stats[display_metric].mean;
                        new_obj["std"] = machine_data.components[i].stats[display_metric].std;
                        new_obj["min"] = machine_data.components[i].stats[display_metric].min;
                        new_obj["25_percent"] = machine_data.components[i].stats[display_metric]["25_percent"];
                        new_obj["50_percent"] = machine_data.components[i].stats[display_metric]["50_percent"];
                        new_obj["75_percent"] = machine_data.components[i].stats[display_metric]["75_percent"];
                        new_obj["max"] = machine_data.components[i].stats[display_metric].max;
                        new_obj["name"] = machine_data.components[i].component_name;
                        new_obj["current"] = machine_data.components[i].lcms_metrics[display_metric].values[run_index];
                        new_obj["missing"] = machine_data.components[i].lcms_metrics[display_metric].missing;
                        new_obj["colour"] = machine_data.components[i].colour;
                        new_obj["index"] = parseInt(i);
                        all_boxes.push(new_obj);
                    }
                }

                /*
                // sort by median
                all_boxes = all_boxes.sort(function(a, b) {
                return a["50_percent"] > b["50_percent"] ? -1 : 1;
                });
            
                // sort polarity (pos first)
                all_boxes = all_boxes.sort(function(a, b){
                    return a["mode"] < b["mode"]? -1 : 1;}
                    ) ;
                */

                if(sort){
                    // sort by current
                    all_boxes = all_boxes.sort(function(a, b) {
                    return a["current"] > b["current"] ? -1 : 1;
                    });

                    // names for x scale
                    var names = all_boxes.map(function(obj){
                        return obj.name;
                    });

                    // update xScale
                    xScale_box.domain(names);
                }
              
                // move boxes
                d3.selectAll(".box")
                .transition()
                .duration(1000)
                .attr('x', function(d, i){
                    return xScale_box(d.name) - box_width/2;
                })
                .attr("y", function(d){return(yScale_box(d["75_percent"]))})
                .attr("height", function(d){return(yScale_box(d["25_percent"])-yScale_box(d["75_percent"]))})
                .attr("width", box_width);
                
                
                // move circles
                d3.selectAll(".point")
                .transition()
                .duration(1000)
                .attr("cx", function(d, i){
                    return xScale_box(d.name);
                })
                .attr("cy", function(d){
                    var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                    return yScale_box(newY);
                })
                .attr("fill", function(d,j){
                    var miss = all_boxes.filter(e => e.name == d.name)[0].missing;
                    var circColor = all_boxes.filter(e => e.name == d.name)[0].colour;
                    var c_index = all_boxes.filter(e => e.name == d.name)[0].index;

                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }
                    else{
                        return circColor; //'url(#circleGradLight'+c_index+')'; 
                    }
                });

                // move medians 
                d3.selectAll(".boxline")
                .transition()
                .duration(1000)
                .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
                .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
                .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
                .attr("y2", function(d){return(yScale_box(d["50_percent"]))});

                // move extenders
                d3.selectAll(".extender")
                .transition()
                .duration(1000)
                .attr("y1", function(d){
                    var y1;
                    var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                    if(newY >= d["75_percent"]){
                        y1 = yScale_box(newY);
                    }
                    else if(newY <= d["25_percent"]){
                        y1 = yScale_box(d["25_percent"]);
                    }
                    else{
                        y1 =  yScale_box(newY);
                    }
                    
                    // cap so does not go off chart
                    /*
                    if(y1 < 0){
                        return 0;
                    }
                    */
                    return y1;
                })
                .attr("y2", function(d){
                    var y2;
                    var newY = all_boxes.filter(e => e.name == d.name)[0].current;
                    if(newY >= d["75_percent"]){
                        y2 = yScale_box(d["75_percent"]);
                    }
                    else if(d.current <= d["25_percent"]){
                        y2 = yScale_box(newY);
                    }
                    else{
                        y2 = yScale_box(newY);
                    }
                    /*
                    // cap so does not go off chart
                    if(y2 > box_area_height){
                        return box_area_height;
                    }
                    */
                    return y2;
                })
                .attr("x1", function(d){return(xScale_box(d.name))})
                .attr("x2", function(d){return(xScale_box(d.name))})

                // update threshold markers
                var thresholds = getThresholds();
                if(Object.keys(thresholds).length > 0){
            
                    d3.select("#thresh_high")
                    .transition()
                    .duration(1000)
                    .attr("y1", yScale_box(thresholds.threshold_high))
                    .attr("y2", yScale_box(thresholds.threshold_high));

                    d3.select("#thresh_low")
                    .transition()
                    .duration(1000)
                    .attr("y1", yScale_box(thresholds.threshold_low))
                    .attr("y2", yScale_box(thresholds.threshold_low));

                    d3.select(".topoverlay")
                    .transition()
                    .duration(1000)
                    .attr("height", function(){
                        var check_height = yScale_box(thresholds.threshold_high);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;
                    })
                    .attr("x",0)
                    .attr("y",0);
                    
                    d3.select(".bottomoverlay")
                    .transition()
                    .duration(1000)
                    .attr("height", function(){
                        var check_height = yScale_box.range()[0] - yScale_box(thresholds.threshold_low);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;

                    })
                    .attr("x",0)
                    .attr("y",yScale_box(thresholds.threshold_low));
                    
                }
                
                // update optimal marker
                if(display_metric == "Mass Error (ppm)" || display_metric == "Mass Error (mDa)"){
                    var marker = 0;
                }
                else{
                    var marker = 1;
                }

                d3.select("#optimal_marker")
                .transition()
                .duration(1000)
                .attr("x1", 0)
                .attr("y1", yScale_box(marker))
                .attr("x2", boxChartWidth)
                .attr("y2", yScale_box(marker))
        }

        function controlDouble(el){
            // get all elements
            var icon = document.getElementById("icon");
            var left_control = document.getElementById("left-control"); //the icons
            var right_control = document.getElementById("right-control");
            var duration = document.getElementById("duration");
            var date = document.getElementById("date");
            var time = document.getElementById("time");
            var left_button = left_control.parentElement;
            var right_button = right_control.parentElement;
            var display_container = right_button.parentElement;
            var double_control = document.getElementById("double");
            var double_button = double_control.parentElement;

            // set run_index
            run_index = 0;

            // update elements
            
            // days since
            var new_date = machine_data.run_data[run_index].date_time;
            var days_since = diff_days(new_date);
            let display_str;
            if(days_since == 0){
                display_str = "Today";
            }
            else if(days_since == 1){
                display_str = "Yesterday";
            }
            else{
                display_str = days_since.toString() + " days ago";
            }
            duration.innerHTML = display_str;

           // icon
			try{
				var summary_size = Object.keys(machine_data["run_data"][run_index].summary).length;}
			catch{
				var summary_size = 0;
			}
            
            if(summary_size > 0){
                    icon.className = "fas fa-exclamation-triangle text-danger text-center";
                }
                else{
                    icon.className = "fas fa-check text-success text-center";
            }

            // date
            date.innerHTML = new_date.toDateString();

            // time
            time.innerHTML = get_time(new_date);

            // controls
            right_control.classList.remove("control");
            right_button.setAttribute("disabled", true);
            double_control.style.display = "none";  
            double_control.classList.remove("control");
            left_button.removeAttribute("disabled");

            // update plots
            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                //update_pressure_profile();
                //setTimeout(function(){
                    draw_pressure_profile(true);
                //}, 1000);
            }
            draw_chromatogram(true);
            
            if(mainForce){
                // update sim and restart
                var graph = getGraph(forceWidth, forceHeight);
                simulation.force("link").links(graph.links);
                simulation.alpha(0.1).alphaDecay(0.05).restart();

                // update circle fill and value
                d3.selectAll(".nodes").transition().duration(500)
                .attr("fill", function(d){

                    if(d.nodeType == 2){
                        //if(theme == "dark"){return "var(--dark)"}
                        //return "white" ;
                        return "url(#middleCircleFill)";
                    }

                     // update value (in the data)
                     var thisNode = graph.nodes.filter(j => j.metricName == d.metricName && j.name == d.name);
                     d.actualValue = thisNode[0].actualValue;

                    var miss = machine_data.components[d.cIndex].lcms_metrics[d.metricName].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })

                // update warning icons
                d3.selectAll('.icons')
                .style("opacity", function(d,i){

                    // only comp nodes
                    if(d.nodeType == 2){
                        return 0;
                    }

                    // get thresholds (all)
                    var thresh_metrics = {};
                    if(metric_type == "lcms"){
                        var thresh_metrics = machine_data.run_data[run_index].summary;
                    }

                    // get thresholds per metric
                    var thresh_comp = {};
                    for(let t in thresh_metrics){
                        if(metab_metric_names[t] == d.metricName){
                            thresh_comp = thresh_metrics[t];
                        }
                    }

                    // show
                    if(d.name in thresh_comp){
                        return 1
                    }
                    return 0;
                    });

                    // update averages
                    d3.selectAll(".averages").filter(e => e.nodeType == 2)
                    .transition().duration(800)
                    .tween('updateAverages', function(d) {
                        
                        var self = this; // no this in d3 v4 in tween

                        // determine new total
                        var newTotal = 0;
                        var metricNodes = graph.nodes.filter(j => j.metricName == d.metricName && j.nodeType != 2);
                        var count = metricNodes.length; 
                        for(let node in metricNodes){
                            newTotal += metricNodes[node].value;
                        }
                        var newCurrent = (newTotal/count).toFixed(2);
                        

                        // Create an interpolator function
                        let i = d3.interpolate(parseFloat(d.current), parseFloat(newCurrent));

                        // update current
                        d.current = newCurrent;
                        
                        return function(t) {
                            let newAverage = i(t);
                        
                            d3.select(self)
                            .text(newAverage.toFixed(2));
                            
                        };
                    });
                
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    moveBoxes(); // move
                    setTimeout(function(){
                        moveBoxes(true);// then sort
                    },500);
                }
                else if(metric_type == "pressure"){
                    updatePressureCircles();
                }
            }
            else if(chart_type == "heat"){
                updateHeatMarker();
                if(run_index >= filter){ // marker off screen
                    d3.select("#heatMarker").style("opacity", 0);
                }
                else{
                    d3.select("#heatMarker").style("opacity", 1);
                }
            }
            else if(chart_type == "line"){
                updateMarker();
                setTimeout(function(){
                    if(metric_type == "lcms"){
                        draw_line_chart(false);
                    }
                    else{
                        draw_pressure_line(false);
                    }
                }, 1000);
            }
            else if(chart_type == "stream"){
                updateMarker();
                setTimeout(function(){
                    draw_stream_graph(false);
                }, 1000);
            }
            else if(chart_type == "density"){
                draw_density_plots(true);
            }
            else if(chart_type == "parallel"){
                update_parallel_graph();
                setTimeout(function(){
                    draw_parallel_graph(false);
                }, 1000);
            }


            // update menus
            create_metric_menu(false);
            create_components_menu(false);
        }

        // resize re-draw svg
        function reSize(){
            xScale_chrom = null;
            xScale_pressure = null;
            xScale_chart = null; 
            xScale_runs = null;
            xScale_time = null;
            xScale_par = null;

            v_height_unit = window.innerHeight/100;
            v_width_unit = window.innerWidth/100;

            // re-set chart element sizes
            base_radius = 3*v_height_unit/5;
            radius = base_radius; // min for line charts 
            currentRadius = radius*2;
            base_line_width = base_radius/2;
            lineWidth = base_line_width; // min for line charts 

            if(machine_data["machine_details"]["machine_type"] == "thermo"){
                draw_pressure_profile(false);
            }
            draw_chromatogram(false);

            // set metric scales to null if pressure
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].radius = null;
                machine_data.pressure_metrics[i].lineWidth = null;
            }

             // set metric scales to null if lcms
             for(let i in machine_data.lcms_metrics){
                machine_data.lcms_metrics[i].yScale = null;
                //machine_data.lcms_metrics[i].xScale = null;
                machine_data.lcms_metrics[i].radius = null;
                machine_data.lcms_metrics[i].lineWidth = null;
            }

            if(mainForce){
                draw_force_main(false);
            }
            else if(chart_type == "line"){
                if(metric_type == "lcms"){
                    draw_line_chart(true);
                }
                else if(metric_type == "pressure"){
                    draw_pressure_line(false);
                }   
            }
            else if(chart_type == "box"){
                if(metric_type == "lcms"){
                    draw_box_plot(false);
                }
                else if(metric_type == "pressure"){
                    draw_pressure_box(false);
                }
            }
            else if(chart_type == "heat"){
                draw_heat_map(false);
            }
            else if(chart_type == "stream"){
                draw_stream_graph(false);
            }
            else if(chart_type == "parallel"){
                draw_parallel_graph(false);
            }
            else if(chart_type == "density"){
                draw_density_plots(false);
            }
        }

        function controlsDraw(){

            // reset yscales
            yScale_chart = null;
            yScale_pressure = null;

            for(let i in machine_data.lcms_metrics){
                machine_data.lcms_metrics[i].yScale = null;
            }
            
            for(let i in machine_data.pressure_metrics){
                machine_data.pressure_metrics[i].yScale = null;
            }

            if(metric_type == "lcms"){
                // redraw charts after removing controls
                
                if(chart_type == "line"){
                    draw_line_chart(true);
                }
                else if(chart_type == "box"){
                    yScale_box = null;
                    draw_box_plot(true);
                }
                else if(chart_type == "heat"){
                    draw_heat_map(true);
                }
                else if(chart_type == "density"){
                    draw_density_plots(true);
                }
                else if(chart_type == "stream"){
                    draw_stream_graph(true);
                }
                else if(chart_type == "parallel"){
                    draw_parallel_graph(true);
                }
            }
            else{
                draw_pressure_line(true);
            }
        }

        function componentDraw(){

            if(mainForce){
                    var graph = getGraph(forceWidth, forceHeight);
                    //reStartSim(graph);
                    draw_force_main(false);
                    return;
                    //draw_force_main(false);
            }

            if(metric_type == "lcms"){
                // redraw charts after component change
                if(!zoom){
                    yScale_chart = null;
                }
                if(chart_type == "line"){
                    draw_line_chart(false);
                }
                else if(chart_type == "box"){
                    yScale_box = null;
                    draw_box_plot(false);
                }
                else if(chart_type == "heat"){
                    draw_heat_map(false);
                }
                else if(chart_type == "density"){
                    draw_density_plots(false);
                }
                else if(chart_type == "parallel"){
                    draw_parallel_graph(false);
                }
                
            }
        }

        function clickSelectAll(event){
            if(event.target.id == "neg_sa"){
                d3.selectAll(".negative").transition().duration(300)
                .style("fill", function(d, i){
                    // update data structures and change fill
                    checked_components[d.component_name] = true;
                    if(!(stackKeys.includes(d.component_name))){
                        stackKeys.push(d.component_name);
                    }
                    return d.colour; //"url(#circleGradLight"+d.c_index+")";
                })

                d3.selectAll(".positive").transition().duration(300)
                .style("fill", function(d, i){
                    // update data structures and change fill
                    checked_components[d.component_name] = false;
                    stackKeys = stackKeys.filter(e => e != d.component_name);
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                })
            }
            else if(event.target.id == "pos_sa"){
                d3.selectAll(".positive").transition().duration(300)
                .style("fill", function(d, i){
                    // update data structures and change fill
                    checked_components[d.component_name] = true;
                    if(!(stackKeys.includes(d.component_name))){
                        stackKeys.push(d.component_name);
                    }
                    return d.colour; //"url(#circleGradLight"+d.c_index+")";
                })

                d3.selectAll(".negative").transition().duration(300)
                .style("fill", function(d, i){
                    // update data structures and change fill
                    checked_components[d.component_name] = false;
                    stackKeys = stackKeys.filter(e => e != d.component_name);
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                })
            }
            if(chart_type == "stream" && !mainForce){update_stream_graph(false);}
            componentDraw();
            
        }
        
        // on click components menu (OLD now SVG, see above click function)
        function clickComponent(event){
            
            // handle normal behaviour
            if(event.target.hasAttribute("type")){

                if(metric_type == "lcms"){
                    var streamCheck = false; // managing messy logic
                    if(!zoom){
                        yScale_chart = null;
                    }

                    if(chart_type == "line"){
                        draw_line_chart(false);
                    }
                    else if(chart_type == "box"){
                        draw_box_plot(false);
                    }
                    else if(chart_type == "heat"){
                        draw_heat_map(false);
                    }
                    else if(chart_type == "density"){
                        draw_density_plots(true);
                    }
                    else if(chart_type == "stream"){
                        // stream stack (leave updates like this for nice transitions)
                        if(stackKeys.includes(event.target.labels[0].innerText)){
                            update_stream_graph(false);
                            stackKeys = stackKeys.filter(d => d != event.target.labels[0].innerText);
                        }
                        else{
                            stackKeys.push(event.target.labels[0].innerText);
                            update_stream_graph(false);
                        } 
                        streamCheck = true;
                        
                    } 
                }

                // update stream stack
                if(!streamCheck){
                    if(stackKeys.includes(event.target.labels[0].innerText)){
                        stackKeys = stackKeys.filter(d => d != event.target.labels[0].innerText);
                    }
                    else{
                        stackKeys.push(event.target.labels[0].innerText);
                    }     
                }
                
                // change background color and store state (complicated as not svg)
                var data_index = parseInt(event.target.parentNode.getAttribute("data-c-index"));
                if(checked_components[event.target.labels[0].innerText]){
                    event.target.nextSibling.style.backgroundColor = "white";
                    //event.target.nextSibling.style.borderColor = machine_data.components[data_index].colour + '80';
                }
                else{
                    event.target.nextSibling.style.backgroundColor = machine_data.components[data_index].colour;
                    //event.target.nextSibling.style.borderColor = "rgba(255, 255, 255, 0.5)";
                }
                
                checked_components[event.target.labels[0].innerText] = !checked_components[event.target.labels[0].innerText];
                draw_chromatogram(false); // re-draw to update tool
                return;
            }

            if(event.target.hasAttribute("data-c-index")){
                // update chromatogram or select one
                var data_index = parseInt(event.target.getAttribute("data-c-index"));
                if(data_index != -1){
                    comp_index = data_index; // update comp index
                    // select one
                    if(window.event.shiftKey){ 
                        // reset stream stack
                        stackKeys = [];
                        var neg_checks = document.getElementsByName("negative");
                        var pos_checks = document.getElementsByName("positive");
                        for(let i =0; i<neg_checks.length; i++){
                            var c_index = neg_checks[i].parentNode.getAttribute("data-c-index");
                            if(neg_checks[i].labels[0].getAttribute("data-c-index") == data_index){
                                neg_checks[i].checked = true;
                                checked_components[neg_checks[i].labels[0].innerText] = true;
                                stackKeys.push(neg_checks[i].labels[0].innerText);
                                neg_checks[i].nextSibling.style.backgroundColor = machine_data.components[c_index].colour;
                                //neg_checks[i].nextSibling.style.borderColor = "rgba(255, 255, 255, 0.5)";
                            }
                            else{
                                neg_checks[i].checked = false;
                                checked_components[neg_checks[i].labels[0].innerText] = false;
                                neg_checks[i].nextSibling.style.backgroundColor = "white";
                                //neg_checks[i].nextSibling.style.borderColor = machine_data.components[c_index].colour + '80';
                            }
                        }

                        for(let i =0; i<pos_checks.length; i++){
                            var c_index = pos_checks[i].parentNode.getAttribute("data-c-index");
                            if(pos_checks[i].labels[0].getAttribute("data-c-index") == data_index){
                                pos_checks[i].checked = true;
                                checked_components[pos_checks[i].labels[0].innerText] = true;
                                stackKeys.push(pos_checks[i].labels[0].innerText);
                                pos_checks[i].nextSibling.style.backgroundColor = machine_data.components[c_index].colour;
                                //pos_checks[i].nextSibling.style.borderColor = "rgba(255, 255, 255, 0.5)";
                            }
                            else{
                                pos_checks[i].checked = false;
                                checked_components[pos_checks[i].labels[0].innerText] = false;
                                pos_checks[i].nextSibling.style.backgroundColor = "white";
                                //pos_checks[i].nextSibling.style.borderColor = machine_data.components[c_index].colour + '80';
                            }
                        }
                        if(metric_type == "lcms"){
                            // redraw line charts
                            if(!zoom){
                                yScale_chart = null;
                            }
                            if(chart_type == "line"){
                                draw_line_chart(false);
                            }
                            else if(chart_type == "box"){
                                yScale_box = null;
                                draw_box_plot(false);
                            }
                            else if(chart_type == "heat"){
                                draw_heat_map(false);
                            }
                            else if(chart_type == "density"){
                                draw_density_plots(true);
                            }
                            else if(chart_type == "stream"){
                                update_stream_graph(true);
                            }
                        }
                        draw_chromatogram(true);
                    }// change chromatogram
                    else{ 
                        xScale_chrom = null;
                        draw_chromatogram(true);
                    }
                    event.preventDefault(); // don't change checkbox
                }
                else{ // select all
                    if(event.target.id == "neg_sa"){
                        var neg_checks = document.getElementsByName("negative");
                        for(let i =0; i<neg_checks.length; i++){
                            var c_index = neg_checks[i].parentNode.getAttribute("data-c-index");
                            neg_checks[i].checked = true;
                            checked_components[neg_checks[i].labels[0].innerText] = true;
                            neg_checks[i].nextSibling.style.backgroundColor = machine_data.components[c_index].colour;
                            //neg_checks[i].nextSibling.style.borderColor = "rgba(255, 255, 255, 0.5)";
                            // stream stack
                            if(!(stackKeys.includes(neg_checks[i].labels[0].innerText))){
                                stackKeys.push(neg_checks[i].labels[0].innerText);
                            }
                        }

                        if(metric_type == "lcms"){
                            // redraw line charts
                            if(!zoom){
                                yScale_chart = null;
                            }
                            if(chart_type == "line"){
                                draw_line_chart(false);
                            }
                            else if(chart_type == "box"){
                                yScale_box = null;
                                draw_box_plot(false);
                            }
                            else if(chart_type == "heat"){
                                draw_heat_map(false);
                            }
                            else if(chart_type == "density"){
                                draw_density_plots(true);
                            }
                            else if(chart_type == "stream"){
                                update_stream_graph(false);
                            }
                        }
                    }
                    else if(event.target.id == "pos_sa"){
                        var pos_checks = document.getElementsByName("positive");
                        for(let i =0; i<pos_checks.length; i++){
                            var c_index = pos_checks[i].parentNode.getAttribute("data-c-index");
                            pos_checks[i].checked = true;
                            checked_components[pos_checks[i].labels[0].innerText] = true;
                            pos_checks[i].nextSibling.style.backgroundColor = machine_data.components[c_index].colour;
                            //pos_checks[i].nextSibling.style.borderColor = "rgba(255, 255, 255, 0.5)";
                            // stream stack
                            if(!(stackKeys.includes(pos_checks[i].labels[0].innerText))){
                                stackKeys.push(pos_checks[i].labels[0].innerText);
                            }
                        }

                        if(metric_type == "lcms"){
                            // redraw line charts
                            if(!zoom){
                                yScale_chart = null;
                            }
                            if(chart_type == "line"){
                                draw_line_chart(false);
                            }
                            else if(chart_type == "box"){
                                yScale_box = null;
                                draw_box_plot(false);
                            }
                            else if(chart_type == "heat"){
                                draw_heat_map(false);
                            }
                            else if(chart_type == "density"){
                                draw_density_plots(true);
                            }
                            else if(chart_type == "stream"){
                                update_stream_graph(false);
                            }
                        }
                    }

                    draw_chromatogram(false); // re-draw to update tool
                    
                    // add and remove click outline
                    event.target.style.outline = "0.3em ridge var(--dark)";
                    setTimeout(function(){
                        event.target.style.outline = "";
                    }, 10);
                }
            }
        }

        function changeScale(el){

            // only for line and stream
            let chart_types_check = ["line", "stream"];
            if(!(chart_types_check.includes(chart_type))){
                return;
            }

            // change buttons
            var buttons = document.getElementsByName("scale-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            el.target.style.backgroundColor = "white";
            el.target.style.borderColor = "var(--dark)";
            el.target.style.color = "var(--dark)";


            // update line charts
            if(el.target.id == "runsScale"){
                if(scaleType == "runs"){
                    return;
                }
                setRunScale();
                if(metric_type == "lcms"){
                    if(chart_type == "line"){
                        updateChangeScale();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStream();
                    }
                }
                else{
                    if(chart_type == "line"){
                        updateChangeScalePressure();
                    } 
                }
                scaleType = "runs";
            }
            else{
                if(scaleType == "time"){
                    return;
                }
                setTimeScale();
                if(metric_type == "lcms"){
                    if(chart_type == "line"){
                        updateChangeScale();
                    }
                    else if(chart_type == "stream"){
                        updateChangeScaleStream();
                    }
                }
                else{
                    if(chart_type == "line"){
                        updateChangeScalePressure();
                    }
                }
                scaleType = "time";
            }
        }

        function displayRuns(el){

            // only for line and stream
            let chart_types_check = ["line", "stream", "heat"];
            if(!(chart_types_check.includes(chart_type))){
                return;
            }
            
            // change filter
            var new_filter = el.target.innerHTML;
            if(new_filter == "All"){
                filter = machine_data.run_data.length;
            }
            else{
                filter = parseInt(el.target.innerHTML);
            }

            if(filter > machine_data.run_data.length){
                filter = machine_data.run_data.length;
            }
            
            
            // change buttons
            var buttons = document.getElementsByName("run-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            el.target.style.backgroundColor = "white";
            el.target.style.borderColor = "var(--dark)";
            el.target.style.color = "var(--dark)";

            //xScale_chart = null;

            // reset scales
            for(let i in machine_data.lcms_metrics){
                //machine_data.lcms_metrics[i].xScale = null;
                machine_data.lcms_metrics[i].yScale = null;
            }

            for(let i in machine_data.pressure_metrics){
                //machine_data.pressure_metrics[i].xScale = null;
                machine_data.pressure_metrics[i].yScale = null;
            }
            

            // redraw lc-ms
            if(metric_type == "lcms"){
                // redraw line charts
                //if(!zoom){
                    //yScale_chart = null;
               // }
                if(chart_type == "line"){
                    lineChartFilterUpdate();
                    setTimeout(function(){
                        draw_line_chart(false);
                    }, 1000);
                    
                }
                else if(chart_type == "heat"){
                    draw_heat_map(false);
                }
                else if(chart_type == "stream"){
                    streamChartFilterUpdate();
                    setTimeout(function(){
                        draw_stream_graph(false);
                    }, 1000);
                }
                
            }
            else{ // redraw pressure
                if(chart_type == "line"){
                    lineChartFilterUpdate();
                    setTimeout(function(){
                        draw_pressure_line(false);
                    }, 1000);
                }
            }
        }


        function create_chart_area(){

            // get container
            var chart_div = document.getElementById("chart");

            // div for content
            var chart_inner = document.createElement("div");
            chart_inner.style.position = "absolute";
            chart_inner.style.left = "0%";
            chart_inner.style.top = "2.5%"; 
            chart_inner.style.width = "97.5%";
            chart_inner.style.height = "95%";
            //chart_inner.style.backgroundColor = "var(--dark)";
            //chart_inner.style.borderRight = "0vh solid var(--dark)";
            chart_inner.style.borderTopLeftRadius = "0em";
            //chart_inner.style.borderBottomLeftRadius = "0em";
            chart_inner.style.boxShadow = "-0.5vh 0.5vh 0.5vh var(--gray)";
            if(theme == "dark"){chart_inner.className = "darkTheme Theme";}
            else{chart_inner.className = "lightTheme Theme";}
            //chart_inner.style.boxShadow = "1vh 1vh 0.5vh var(--gray)";
            chart_inner.style.fontSize = "2vh";
            chart_inner.style.opacity = 0;
            chart_inner.style.overflow = "none";
            chart_inner.id = "chart_inner";

            /**** scale/runs buttons ****/
            // container div
            var new_top_div = document.createElement("div");
            new_top_div.style.height = "8%";
            new_top_div.className = "text-center";
            new_top_div.style.position = "absolute";
            new_top_div.style.left = 0;
            new_top_div.style.top = 0;
            new_top_div.style.display = "block";
            //if(theme == "dark"){new_top_div.style.backgroundColor = "var(--dark)";}
            //else{new_top_div.style.backgroundColor = "lightsmoke"}
            new_top_div.style.backgroundColor = "var(--dark)";
            //new_top_div.style.backgroundColor = "var(--dark)";
            new_top_div.style.width = "100%";
            new_top_div.id = "chart_top";

            // button group
            var button_group = document.createElement("div");
            button_group.className = "btn-group";
            button_group.style.width = "100%";
            button_group.style.height = "100%";

            // buttons

            // METRIC NAME
            var chart_metric_name = document.createElement("p");
            chart_metric_name.id = "chartHeader";
            chart_metric_name.innerHTML = display_metric.toUpperCase();
            chart_metric_name.style.color = "aliceblue";
            chart_metric_name.style.fontWeight = "bold";
            chart_metric_name.style.padding = "0.2em";
            chart_metric_name.style.fontSize = "1.2vw";
            chart_metric_name.style.opacity = 1;
            chart_metric_name.style.letterSpacing = "0.5vh";
            //chart_metric_name.style.marginLeft = "5vh";
            //chart_metric_name.className = "text-center";

            // MENU icon
            var new_menu = document.createElement("span");
            new_menu.className = "fa fa-bars";
            //new_menu.style.opacity = 0.8;
            new_menu.style.color = "white";
            new_menu.style.cursor = "pointer";
            new_menu.style.marginRight = "3vw";
            new_menu.style.padding = "0.5em";
            new_menu.style.fontSize = "1.2vw";
            new_menu.style.opacity = 0.8;
            new_menu.id = "metric_menu";
            new_menu.setAttribute("data-tooltip", "Click for Metric Menu")
            new_menu.addEventListener("click", showMenu);

            // TIME SCALE
            if(scaleType == "time"){
                var new_button = ButtonOnChart("TIME SCALE", "scale-buttons", changeScale);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
            }
            else{
                var new_button = ButtonOffChart("TIME SCALE", "scale-buttons", changeScale);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
            }
            new_button.id = "timeScale";
            new_button.style.width = "5vw";
            new_button.style.marginLeft = "1vw";
            button_group.append(new_button);

            // RUNS SCALE
            if(scaleType == "runs"){
                var new_button = ButtonOnChart("RUNS SCALE", "scale-buttons", changeScale);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
            }
            else{
                var new_button = ButtonOffChart("RUNS SCALE", "scale-buttons", changeScale);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
            }
            new_button.id = "runsScale";
            new_button.style.width = "5vw";
            new_button.style.marginRight = "3vw";
            button_group.append(new_button);

            button_group.append(chart_metric_name);
            button_group.append(new_menu);

            /*  number of runs */
            var new_button = ButtonOnChart("10", "run-buttons", displayRuns);
            new_button.disabled = true;
            new_button.style.boxShadow = "";
            new_button.classList = "btn";
            button_group.append(new_button);

            /*  number of runs */
            var new_button = ButtonOffChart("20", "run-buttons", displayRuns);
            new_button.disabled = true;
            new_button.style.boxShadow = "";
            new_button.classList = "btn";
            button_group.append(new_button);

            /*  number of runs */
            var new_button = ButtonOffChart("30", "run-buttons", displayRuns);
            new_button.disabled = true;
            new_button.style.boxShadow = "";
            new_button.classList = "btn";
            button_group.append(new_button);

            /*  number of runs */
            var new_button = ButtonOffChart("40", "run-buttons", displayRuns);
            new_button.disabled = true;
            new_button.style.boxShadow = "";
            new_button.classList = "btn";
            button_group.append(new_button);

            /*  number of runs */
            if(machine_data.run_data.length > 50){
                var new_button = ButtonOffChart("50", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);
            }

            /*  number of runs */
            if(machine_data.run_data.length > 100){
                var new_button = ButtonOffChart("100", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);
            }

            /*  number of runs */
            if(machine_data.run_data.length > 150){
                var new_button = ButtonOffChart("150", "run-buttons", displayRuns);
                new_button.disabled = true;
                new_button.style.boxShadow = "";
                new_button.classList = "btn";
                button_group.append(new_button);
            }

            /*  number of runs */
            var new_button = ButtonOffChart("All", "run-buttons", displayRuns);
            new_button.marginRight = "5vw";
            new_button.disabled = true;
            new_button.style.boxShadow = "";
            new_button.classList = "btn";
            button_group.append(new_button);

            new_top_div.append(button_group);

            /* chart type buttons */
            // container div
            var new_bottom_div = document.createElement("div");
            new_bottom_div.style.height = "8%";
            new_bottom_div.style.position = "absolute";
            new_bottom_div.style.left = 0;
            new_bottom_div.style.bottom = 0;
            new_bottom_div.style.display = "block";
            if(theme == "dark"){new_bottom_div.class = "headerDarkTheme Theme";}
            else{new_bottom_div.class = "headerLightTheme Theme";}
            new_bottom_div.style.width = "100%";
            new_bottom_div.id = "chart_bottom";

            // button group
            var button_group = document.createElement("div");
            button_group.className = "btn-group";
            button_group.style.width = "100%";
            button_group.style.height = "100%";
			//button_group.style.fontSize = "0.7rem";

            // buttons
            //force
            var new_button = ButtonOnChart("SUMMARY", "chart-buttons", updateChartType);
            new_button.id = "force";
            //new_button.style.width = "5vw";
            new_button.style.marginLeft = "3vw";
            button_group.append(new_button);

            //line
            var new_button = ButtonOffChart("LINE CHARTS", "chart-buttons", updateChartType);
            new_button.id = "line";
            //new_button.style.width = "5vw";
            //new_button.style.marginLeft = "6vw";
            button_group.append(new_button);

            // stream
            var new_button = ButtonOffChart("STREAM GRAPH", "chart-buttons", updateChartType);
            new_button.id = "stream";
            //new_button.style.width = "5vw";
            button_group.append(new_button);

            // parallel
            var new_button = ButtonOffChart("PARALLEL GRAPH", "chart-buttons", updateChartType);
            new_button.id = "parallel";
            //new_button.style.width = "5vw";
            button_group.append(new_button);

            //heat
            var new_button = ButtonOffChart("HEAT MAP", "chart-buttons", updateChartType);
            new_button.id = "heat";
            //new_button.style.width = "5vw";
            button_group.append(new_button);

            // box
            var new_button = ButtonOffChart("BOX PLOTS", "chart-buttons", updateChartType);
            new_button.id = "box";
            //new_button.style.width = "5vw";
            button_group.append(new_button);

            //density
            var new_button = ButtonOffChart("RIDGE LINES", "chart-buttons", updateChartType);
            new_button.id = "density";
            //new_button.style.width = "5vw";
            new_button.style.marginRight = "3vw";
            button_group.append(new_button);

            new_bottom_div.append(button_group);

            // plot area 
            var plot_area = document.createElement("div");
            plot_area.id = "plot_chart";
            plot_area.style.width = "100%";
            plot_area.style.height = "100%";
            plot_area.style.opacity = 0;

            chart_inner.append(new_top_div);
            chart_inner.append(plot_area);
            chart_inner.append(new_bottom_div);
            chart_div.append(chart_inner);

            // transition on load
            var t = d3.transition().duration(1500);
            d3.select("#chart_inner").transition(t).style("opacity", 1);
        }

        function updateChartType(event){

            // change background and update state
            var buttons = document.getElementsByName("chart-buttons");
            for(let i =0; i<buttons.length; i++){
                buttons[i].style.backgroundColor = "var(--dark)";
                buttons[i].style.color = "white";
                buttons[i].style.borderColor = "var(--info)";
            }
            event.target.style.backgroundColor = "white";
            event.target.style.borderColor = "var(--dark)";
            event.target.style.color = "var(--dark)";
            chart_type = event.target.id;

            // radios
            var radios = document.getElementsByName("radioOptions");
            var scale_buttons = document.getElementsByName("scale-buttons");
            var run_buttons = document.getElementsByName("run-buttons");

            // default disable scale buttons (enable below for LINE and STREAM)
            for(let i = 0; i<scale_buttons.length; i++){
                    scale_buttons[i].disabled = true;
                    scale_buttons[i].style.boxShadow = "";
                    scale_buttons[i].classList = "btn";
            }

            // default disable run buttons (enable below for LINE and STREAM and HEAT)
            for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = true;
                    run_buttons[i].style.boxShadow = "";
                    run_buttons[i].classList = "btn";
            }

            // force graph (sumamry)
            if(chart_type == "force"){
                mainForce = true;
                draw_force_main(true);

                // enable all
                for(let i = 0; i<radios.length; i++){
                    radios[i].disabled = false;
                }

                return;
            }
            else{
                mainForce = false;
            }

            // draw chart
            if(chart_type == "line"){
                // enable line charts for normalised
                for(let i = 0; i<radios.length; i++){
                    radios[i].disabled = false;
                }
                if(metric_type == "lcms"){
                    draw_line_chart(true);
                }
                else{
                    draw_pressure_line(true);
                }
                
                // enable scale buttons
                for(let i = 0; i<scale_buttons.length; i++){
                    scale_buttons[i].disabled = false;
                    scale_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    scale_buttons[i].classList = "btn btn-custom";
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }
            }
            else if(chart_type == "parallel"){
                // disable pressure metrics 
                for(let i = 0; i<radios.length; i++){
                    if(radios[i].classList.contains("pressure")){
                            radios[i].disabled = true;
                        }
                }
                draw_parallel_graph(true);
            }
            else if(chart_type == "box"){
                // disable box plots for normalised
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    if(radio_name == "Area (normalised)" || radio_name == "Height (normalised)"){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }

                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                }
                if(metric_type == "lcms"){
                    yScale_box = null;
                    draw_box_plot(true);
                } 
                //displayMenu.style.display = "none";
            }
            else if(chart_type == "heat"){
               
                // disable heat maps 
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else if(radio_name == "Retention Time" || radio_name == "Full Width Half Maximum"){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }

                draw_heat_map(true);
            }
            else if(chart_type == "density"){
                // enable all 
                //for(let i = 0; i<radios.length; i++){
                    //var radio_name = radios[i].labels[0].innerText;
                    //radios[i].disabled = false;
                    
                //}
                draw_density_plots(true);
            }
            else if(chart_type == "stream"){
                for(let i = 0; i<radios.length; i++){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else{
                        radios[i].disabled = false;
                    }
                    
                }

                // enable scale buttons
                for(let i = 0; i<scale_buttons.length; i++){
                        scale_buttons[i].disabled = false;
                        scale_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                        scale_buttons[i].classList = "btn btn-custom";
                }

                // enable run buttons
                for(let i = 0; i<run_buttons.length; i++){
                    run_buttons[i].disabled = false;
                    run_buttons[i].style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    run_buttons[i].classList = "btn btn-custom";
                }

                if(metric_type == "lcms"){
                    draw_stream_graph(true);
                }
            }
        }

        function draw_stream_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot (same as draw line and pressure)
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            
            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // reset from zero components
            plot_area.style.opacity = 1;

            // get indexes of checked components
            var component_indexes = getComponentIndexes();
    
            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View the Stream Graph";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // circle gradient fills (have to use names as streams change and use key)
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + machine_data.components[parseInt(component_indexes[i])].component_name)
                //.attr('x1', '0%')
                //.attr('y1', '100%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                
                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour + '80')
                .style('stop-opacity', 1);
                

                //gradFill.append('stop')
                //.attr('offset', '100%')
                //.style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                //.style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('radialGradient')
                .attr('id', 'circleGradLightRad' + component_indexes[i])
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // define a clipPath: everything out of this area won't be drawn (else draws in margin)
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipStream") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // add the clip path
            var all_streams = svg.append('g')
                .attr("clip-path", "url(#clipStream)");

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // offsets and extents (allow for circles) 
            //var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }

            // loop for d3 stacked data
            var d3_data = [];
            var y_max = -Infinity;
            var y_min = Infinity; // just using zero
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                    }
                }
                d3_data.push(new_row);
            }

            // names (create stack on first draw)
            if(stackKeys.length == 0){
                // negative
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        if(machine_data.components[i].component_mode == "N"){
                            stackKeys.push(machine_data.components[i].component_name);
                        }
                    }
                }

                // positive
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        if(machine_data.components[i].component_mode == "P"){
                            stackKeys.push(machine_data.components[i].component_name);
                        }
                    }
                }
            }

            // colours
            colourByKey = {};
            for(let i in machine_data.components){
                colourByKey[machine_data.components[i].component_name] = machine_data.components[i].colour;
            }

            /* Y scales and axes */
            yScale_stream_expand = d3.scaleLinear()
                .domain([1, 0]) 
                .range([height, 0]);

            yScale_stream_total = d3.scaleLinear()
                .domain([y_max, 0]) 
                .range([height, 0]);

            // y scale dual scales
            if(streamExpand){
                yScale_stream = yScale_stream_expand;
            }
            else{
                yScale_stream = yScale_stream_total;
            }

            /** y-axis based on state**/
            y_axis_stream_total = d3.axisLeft().ticks(5).scale(yScale_stream_total)
            .tickSize(v_height_unit).tickSizeOuter(0);

            y_axis_stream_expand = d3.axisLeft().ticks(5).scale(yScale_stream_expand)
            .tickSize(v_height_unit).tickSizeOuter(0).tickFormat(i => parseInt(i*100) + "%");

            if(streamExpand){
                y_axis_stream = y_axis_stream_expand;
            }
            else{
                y_axis_stream = y_axis_stream_total;
            }

            // handle single component in expand (reset to no offset)
            if(streamExpand && component_indexes.length == 1){
                // reset y domain and axis
                yScale_stream = yScale_stream_total;
                y_axis_stream = y_axis_stream_total;

                // change stack
                offsetType = d3.stackOffsetNone;

                streamExpand = false;
            }

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // plot the streams
            all_streams
            .selectAll("layers")
            .data(stack)
            .enter()
            .append("path")
            .attr("class", "streams")
            .style("fill", function(d) {
                return  'url(#circleGradLight' + d.key +')'; //colourByKey[d.key];
            })
            .style("fill-opacity", 1)
            .style("stroke", function(d) {return colourByKey[d.key];})//colourByKey[d.key]
            .style("stroke-opacity", 0.5)
            .style("stroke-width", lineWidth)
            .on("mouseover", function(event, d){
                // text location boundaries
                var x = event.layerX;
                var y = event.layerY;
                var anchor = "middle"; 
                if(x >= lineChartWidth -100){
                    x = lineChartWidth - 200;
                    anchor = "start";
                };
                if(x <= 150){
                    x = x + 150;
                }
                if(y >= height -100){
                    y = height - 100;
                }
                
                // add text (name)
                all_streams.append("text")
                .attr("class", "hover-text")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", "1em")
                .attr("font-size", "1em")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .style("text-anchor", anchor)
                //.style("text-shadow", "0.1vh 0.1vh gray")
                .text(d.key);


                // highlight
                d3.selectAll(".streams").style("opacity", function(e){
                    if(e.key == d.key){return 1;}
                    return 0.1;
                });
                
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".streams").style("opacity", 1);
                d3.selectAll(".hover-text").remove();
            })
            .attr("d", area);

            // add vertical marker
           all_streams.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 1)
            .attr("cursor", "pointer")
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .on("mouseover", function(event){

                // overlays to highlight
                if(run_index < filter){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return xScale_chart(x_values_chart[run_index+1]);
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                if(run_index !=0){
                    all_streams.append("rect")
                    .attr("class", "streamHighlight")
                    .attr("x", xScale_chart(x_values_chart[run_index-1]))
                    .attr("y", 0)
                    .attr("height", height)
                    .attr("width", function(d,i){
                        return lineChartWidth;
                    })
                    .attr("fill", "var(--dark)")
                    .attr("fill-opacity", 0.9);
                }

                // tooltip for switch modes
                var tooltip = d3.select("#tooltip");
                if(streamExpand){
                    var tool_text = "Click for Stacked Mode";
                }else{
                    var tool_text = "Click for 100% Mode";
                }
                tooltip.html(tool_text);
                tooltip.style('left', (event.pageX + 10) + 'px');
                tooltip.style('top', (event.pageY + 10) + 'px');
                tooltip.style("visibility", "visible");


                
            })
            .on("mouseout", function(event){
                d3.selectAll(".streamHighlight").remove();
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){

                if(stackKeys.length == 1){return;}
                // CLOSE
                if(streamExpand){
                    // reset y domain and axis
                    yScale_stream = yScale_stream_total;
                    y_axis_stream = y_axis_stream_total;
                    d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

                    // change stack
                    offsetType = d3.stackOffsetNone;
                    stackedData = d3.stack()
                        .offset(offsetType)
                        .order(d3.stackOrderNone)
                        .keys(stackKeys);

                    stack = stackedData(d3_data);

                    // redraw
                    d3.selectAll(".streams")
                    .data(stack)
                    .transition().duration(1000)
                    .attr("d", area);

                    streamExpand = false;
                    return;
                }

                // EXPAND
                // set y domain
                yScale_stream = yScale_stream_expand;
                y_axis_stream = y_axis_stream_expand;
                d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

                // change stack
                offsetType = d3.stackOffsetExpand;
                stackedData = d3.stack()
                    .offset(offsetType)
                    .order(d3.stackOrderNone)
                    .keys(stackKeys);

                stack = stackedData(d3_data);

                // redraw
                d3.selectAll(".streams")
                .data(stack)
                .transition().duration(1000)
                .attr("d", area);

                streamExpand = true;
                
            });

        
            // ylabel left (units)

            // add ABS. to metric names
            var abs_metrics = ["Mass Error (ppm)", "Mass Error (mDa)", "Area (normalised)", "Height (normalised)"];
            if(abs_metrics.includes(display_metric)){
                var displayText = y_labels[display_metric].toUpperCase() + " (Abs.)";
            }
            else{
                var displayText = y_labels[display_metric].toUpperCase(); 
            }

            svg.append("text")
            .attr("class", "label lineText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(displayText);

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis_stream);
                
            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            //.style('fill-opacity', 0.5)
            .call(x_axis);

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".streams").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }

            // double click reset chart(removed for exapand mode)
            /*
            svg.on("dblclick",function(){
                // set scale
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }

                // x-axis
                x_axis_call.transition().duration(1000).call(x_axis);

                // streams
                d3.selectAll(".streams")
                .transition().duration(1000)
                .attr("d", area);
                
                // marker
                d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));
            });
            */

        }

        function draw_density_plots(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;
            var legend_height = plot_height/10; 

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }


            // get indexes of checked components
            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Ridge Line";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 12*v_height_unit, 
                          right: 4*v_width_unit + currentRadius, 
                          bottom: chart_bottom.offsetHeight+6*v_height_unit, 
                          left: 4*v_width_unit};

            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'ridgeFill')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', "var(--info)")
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', 'var(--info)')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'skyblue')
                .style('stop-opacity', 1);

            // define a clipPath: everything out of this area won't be drawn (else draws in margin)
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipRidge") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width - currentRadius*4)
                .attr("height", height + 2*margin.top)
                .attr("x",-margin.left/2)
                .attr("y", - margin.top);

            // add the clip path
            var all_ridges = svg.append('g')
                .attr("clip-path", "url(#clipRidge)");

            //** CHROM dAta **/
            var ridgeData = [];
            var ridgeNames = [];
            var xMax = 22; 
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var new_chrom = {"key": machine_data.components[i]["component_name"],
                                    "rt": machine_data.components[i]["lcms_metrics"]["Retention Time"].values[run_index],
                                    "colour": machine_data.components[i]["colour"],
                                    "data": machine_data.components[i].chromatograms[run_index]};
                    
                    //  Y scale for values (per chromatogram)
                    new_chrom["scale"] = d3.scaleLinear()
                        .domain([0, 3.5*d3.max(new_chrom.data, d=>d.y)])
                        .range([height, 0]);

                    // set bigger if one
                    if(component_indexes.length == 1){
                        new_chrom["scale"].domain([0, 0.8*d3.max(new_chrom.data, d=>d.y)])
                    }

                    ridgeData.push(new_chrom);
                }
            }

            // sort by retention time
            ridgeData = ridgeData.sort(function(a, b) {
                    return a["rt"] > b["rt"] ? -1 : 1;
            });
            ridgeNames = ridgeData.map(d => d.key);

            //  Y scale for names
            var yScale_names = d3.scaleBand()
                .domain(ridgeNames)
                .range([0, height])
                .paddingInner(1);

            // X scale
            var xScale = d3.scaleLinear()
                .domain([0, xMax])
                .range([ 0, width]);

            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale)
            .tickSize(v_height_unit/2).ticks(5).tickSizeOuter(0);
            
            
            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text("CHROMATOGRAMS");

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "CHROMATOGRAMS";

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "90%")
            .attr("y", "-5%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // xlabel
            svg.append("text")
                .attr("class", "label")
                .attr("text-anchor", "middle")
                .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("stroke", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
                .attr("x", width / 2)
                .attr("y", height + margin.bottom/3)
                .text("MINUTES");
                
            // curved line
            var line = d3.line().curve(d3.curveLinear)
                                    .x(function(d, i) {return xScale(d.x)})
                                        .y(function(d, i) {return yScale_ridge(d.y)});

            // area under curve
            var area = d3.area().curve(d3.curveLinear)
                        .x(function(d) {return xScale(d.x);})
                        .y0(height)
                        .y1(function(d) { return yScale_ridge(d.y);});

            // draw the ridges
            for(let i in ridgeData){ 
                // set yscale (or leave)
                if(!chromExpand){
                    yScale_ridge = ridgeData[i].scale;
                }
                if(yScale_ridge == null){
                    yScale_ridge = ridgeData[i].scale;
                }

                // handle single component
                var translateY = yScale_names(ridgeData[i].key)-height;
                if(component_indexes.length == 1){
                    var translateY = 0;
                }

                all_ridges.append("path")
                    .attr("id", "ridge"+i)
                    .attr("class", "ridge")
                    .attr("fill", function(d){
                        return "url('#ridgeFill')";
                        //return ridgeData[i].colour;
                    })
                    .attr("fill-opacity", 1)
                    .attr("stroke", function(){
                        if(theme == "dark"){return "white"}
                        return "var(--dark)";
                        //return ridgeData[i].colour;
                    })
                    .attr("stroke-width", lineWidth/4)
                    .attr("transform", function(d){return("translate(0," + translateY +")" )})
                    .datum(ridgeData[i].data)
                    .attr("d", area)
                    //.attr("filter", "url(#diffuse)")
                    .attr("cursor", "pointer")
                    .on("mouseover", function(event){
                        // set tooltip
                        if(!(chromExpand)){
                            var chrom_text = "Click to Scale to Peak";
                        }
                        else{
                            var chrom_text = "Click to Normalise Peaks";
                        }
                        var tooltip = d3.select("#tooltip");
                        tooltip.html(chrom_text);
                        tooltip.style('left', (event.pageX + 10) + 'px');
                        tooltip.style('top', (event.pageY + 10) + 'px');
                        tooltip.style("visibility", "visible");

                    })
                    .on("mouseout", function(event){
                        var tooltip = d3.select("#tooltip");
                        tooltip.style("visibility", "hidden");
                    })
                    .on("click", function(event, d){
                        // reset
                        if(chromExpand){
                            for(let j in ridgeData){ 
                                yScale_ridge = ridgeData[j].scale;
                                d3.select("#ridge"+j)
                                .transition().duration(1000)
                                .attr("d", area);
                            }
                            chromExpand = false;
                        } // expand
                        else{
                            // set yScale to clicked chrom
                            yScale_ridge = ridgeData[i].scale;
                            d3.selectAll(".ridge")
                            .transition().duration(1000)
                            .attr("d", area);
                            chromExpand = true;
                        }
                    });
                
                // add comp circles
                svg
                    .append("circle")
                    .attr("cx", width - currentRadius)
                    .attr("cy", yScale_names(ridgeData[i].key) - currentRadius)
                    .attr("r", currentRadius)
                    .attr("fill", function(d){ 
                        return ridgeData[i].colour;//"url(#circleGradLight"+d.c_index+")";
                    })
                    .attr("stroke", function(d){
                        return ridgeData[i].colour; //"url(#circleGradLight"+d.c_index+")";
                    })
                    .attr("filter", "url(#specular)")
                    .attr("stroke-opacity", 0.5)
                    .attr("stroke-width", lineWidth/2)
                    .attr("class", "point")
                    .on("mouseover", function(event, d){
                        d3.selectAll(".ridge").style("opacity", 0.05);
                        d3.select("#ridge"+i).style("opacity", 1);

                        // add name
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", 2*v_width_unit)
                        .attr("y", yScale_names(ridgeData[i].key))
                        .attr("dy", "1em")
                        .attr("font-size", "1.5em")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .style("text-shadow", "0.1vh 0.1vh gray")
                        .text(ridgeData[i].key);
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".ridge").style("opacity", 1);
                        d3.selectAll(".hover-text").remove();
                    });
                
            }

             // create x-axis 
             var x_axis_call = all_ridges.append("g")
            .attr("transform", "translate(0," + (height) + ")") 
            .call(x_axis)
            //.style('stroke-width', '0.4vh')
            .style('font-size', '1.8vh')
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis xAxis axis-light";
                });

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".ridge").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select(".xAxis").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

            }
        }

        function draw_heat_map(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            
            plot_area.style.opacity = 1;
                
            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Heat Map";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + 2*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight+2*v_height_unit, 
                          left: 2*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // create data range for legend ... see FIT5120 project for better implementation
            var heat_range = heat_ranges[display_metric].hi - heat_ranges[display_metric].low;
            var step = heat_range/5000; // granularity of legend
            var interval = heat_ranges[display_metric].low - step;
            var legend_data = [interval];
        
            while(interval < heat_ranges[display_metric].hi){
                new_interval = interval + step;
                interval = parseFloat(new_interval.toFixed(4));
                legend_data.push(interval);
            }

            // rect width and scale for legend
            var rect_width = width/legend_data.length; // for last drawn
            var legend_height = 2*v_height_unit;
            var legendScale = d3.scaleLinear()
            .domain([heat_ranges[display_metric].low - step, heat_ranges[display_metric].hi + step])
            .range([0, width]);

            // create colour scale
            var colourScale = d3.scaleSequential()
                .interpolator(d3.interpolateRdBu)
                .domain([heat_ranges[display_metric].low - step, heat_ranges[display_metric].hi + step])

            // legend
            svg
            .selectAll("legend")
            .data(legend_data)
            .enter()
            .append("rect")
            .attr("x", (d) => Math.floor(legendScale(d)))
            .attr("y", 0)
            .attr("height", legend_height)
            .attr("width", function(d,i){
                if(i==legend_data.length-1){
                    return rect_width;
                }
                return Math.floor(legendScale(legend_data[i+1]))-Math.floor(legendScale(d));
            })
            .attr("fill", (d) => colourScale(d));

            // legend axis label 
            var legend_axis = d3.axisBottom().scale(legendScale).tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // add legend axis
            svg.append("g")
            .attr("transform", "translate(0," + legend_height + ")")
            .attr("id", "legendAxis")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .call(legend_axis)
            .style('font-size', '1.6vh');

            // legend label
            svg.append("text")
            .attr("class", "label-heat")
            .attr("y", legend_height/2 + legend_height/4)
            .attr("x",width / 2)
            .style("text-anchor", "middle")
            .style('font-size', '1.6vh')
            .attr("stroke", function(){
                    //if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("fill", function(){
                    //if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .text(y_labels[display_metric].toUpperCase());

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "93%")
            .attr("y", "5%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // x values
            var run_values = machine_data.run_data
            var x_values = [];
            for(let run in run_values){
                if(run < filter){
                    if(run < 40){ // cap heat maps to 40
                        x_values.push(run_values[run].date_time);
                    }
                }
                else{
                    break;
                }
            }

            // set cell height
            var height_pad = 0;//v_height_unit/2;
            cell_height = (height - 2*currentRadius - 2*v_height_unit - legend_height - margin.bottom- height_pad*(x_values.length-1))/(x_values.length+1);

            // heat column width
            var map_width = width - 4*v_width_unit; // space for marker (match to scale)
            var heat_padding = 0;
            if(component_indexes.length > 3){
                var heat_width = (map_width - (heat_padding*(component_indexes.length)+ heat_padding))/component_indexes.length;
            }
            else{
                var heat_width = width/4;
            }

            // heat maps container
            var translateY = 4*legend_height;
            var heat_maps = svg.append("g")
            .attr("transform", "translate(0," + translateY + ")");

            // x scale names
            var names = [];
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    names.push({"name": machine_data.components[i].component_name,
                                "mode": machine_data.components[i].component_mode});
                }
            }
            
            // sort by mode and name to match menu order
            names.sort((a, b) => a["name"] > b["name"]);
            names.sort((a, b) => a["mode"] < b["mode"]);
            names = names.map(function(entry){
                return entry.name;
            })

            // x scale
            var xScale_heat = d3.scaleBand()
                .range([2*v_width_unit, width-2*v_width_unit])
                .domain(names)
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // add horizontal marker
            heat_maps.append("line")
                .attr("id", "heatMarker")
                .attr("x1", 0)
                .attr("y1", cell_height*run_index + cell_height/2)
                .attr("x2", width)
                .attr("y2", cell_height*run_index + cell_height/2)
                .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
                .attr("stroke-width", lineWidth)
                .attr("stroke-opacity" ,1)
                .attr("stroke", function(){
                    if(theme == "dark"){return "white"}
                    return "var(--dark)";
                })
                .attr("opacity", function(){
                    if(run_index < filter){
                        return 1;
                    }
                    else{
                        return 0;
                    }
                });
            
            
            // draw columns of heat map
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j<filter; j++){ 
                        // handle less than 40 runs
                        if(j >= machine_data.run_data.length){break;}
                        if(j >= 40){break;}
                        let new_row = {'x': x_values[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }

                    // draw heat map column
                    heat_maps
                    .selectAll("heatmap")
                    .data(data)
                    .enter()
                    .append("rect")
                    //.attr("rx", 1)
                    //.attr("ry", 1)
                    .attr("x", function(d){return(xScale_heat(machine_data.components[i].component_name)- heat_width/2)})
                    .attr("y", function(d,i){
                        return Math.floor(cell_height*i) + i*height_pad;
                    })
                    .attr("height", function(d,i){
                        return Math.floor(cell_height);
                    })
                    .attr("width", function(d,i){
                        return Math.floor(heat_width);
                    })
                    .attr("class", function(d,j){
                        return "heat heat" + i + " hover" + j;
                    })
                    .attr("stroke-width", function(d,j){
                        return base_line_width;
                    })
                    .attr("stroke", function(d, j){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            return "var(--dark)";
                        }
                        else{
                            return colourScale(d.y);
                        }
                    })
                    .attr("fill", function(d){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            return "var(--dark)";
                        }
                        else{
                            return colourScale(d.y);
                        }
                    })
                    .on("mouseover", function(event, d){
                        
                        var tooltip = d3.select("#tooltip");
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        if(miss.includes(d.index)){
                            var tooltipHTML = "<strong>" + machine_data.components[i].component_name.replace("_", " ") + 
                                            "</strong><br>" + d.x.toDateString() + "<br>" +
                                                get_time(d.x) +  "<br><strong>" +
                                                "NO VALUE" + "</strong>";
                        } else{
                            var tooltipHTML = "<strong>" + machine_data.components[i].component_name.replace("_", " ") + 
                                            "</strong><br>" + d.x.toDateString() + "<br>" +
                                                get_time(d.x) +  "<br><strong>" +
                                                Number.parseFloat(d.y).toFixed(3) + "</strong>";
                        }
                        tooltip.html(tooltipHTML);
                        tooltip.style('left', (event.pageX+10) + 'px');
                        tooltip.style('top', (event.pageY+10) + 'px');
                        tooltip.style("visibility", "visible");
                        // highlights
                        //d3.select(this).attr("stroke", "var(--dark)");
                        //d3.selectAll(".heat").style("opacity", 0.5);
                        //d3.select(this).style("opacity", 1);

                        if(d.index == run_index){
                            d3.selectAll(".heat").style("opacity", 0.1);
                            d3.selectAll(".hover"+run_index).style("opacity", 1);
                        }
                            
                        
                    })
                    .on("mouseout", function(event, d){
                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;
                        var tooltip = d3.select("#tooltip");
                        tooltip.style('left', '0px');
                        tooltip.style('top', '0px');
                        tooltip.style("visibility", "hidden");
                        // de-highlight
                        d3.selectAll(".heat").style("opacity",1);
                    });

                    // add component marker
                    heat_maps
                    .append("circle")
                    .attr("x", xScale_heat(machine_data.components[i].component_name))
                    .attr("y", function(d,i){
                        return (cell_height+height_pad)*(x_values.length) + 2*v_height_unit;
                    })
                    .attr("cx", xScale_heat(machine_data.components[i].component_name))
                    .attr("cy", function(d,i){
                        return (cell_height+height_pad)*(x_values.length) + 2*v_height_unit;
                    })
                    .attr("r", currentRadius)
                    .attr("filter", "url(#specular)")
                    .attr("fill", machine_data.components[i].colour)
                    .attr("stroke", machine_data.components[i].colour)
                    .attr("stroke-width", lineWidth/2)
                    .attr("stroke-opacity", 0.5)
                    .attr("cursor", "pointer")
                    .attr("class", "heat heat" + i)
                    .on("mouseover", function(event, d){
                        var tooltip = d3.select("#tooltip");
                        var tooltipHTML = machine_data.components[i].component_name.replace("_"," ");                   
                        tooltip.html(tooltipHTML);
                        tooltip.style('left', (event.pageX + 30) + 'px');
                        tooltip.style('top', (event.pageY-50) + 'px');
                        tooltip.style("visibility", "visible");

                        d3.selectAll(".heat").style("opacity", 0.1);
                        d3.selectAll(".heat" + i).style("opacity", 1);
                    })
                    .on("mouseout", function(event, d){
                        var tooltip = d3.select("#tooltip");
                        tooltip.style('left', '0px');
                        tooltip.style('top', '0px');
                        tooltip.style("visibility", "hidden");
                        d3.selectAll(".heat").style("opacity", 1);
                    })
                    .on("click", function(event, d){
                        comp_index = i;
                        draw_chromatogram(true);
                    });

                }
            }

            if(transition){
                d3.selectAll(".heat").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#heatMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll("rect").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".label-heat").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll("#legendAxis").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

            }
        }

        function create_metric_menu(transition){
            
            // get container
            var metric_menu_div = document.getElementById("menu");

            // remove any elements
            while (metric_menu_div.firstChild) {
                metric_menu_div.removeChild(metric_menu_div.firstChild);
            }

            // div for content
            var metric_menu_inner = document.createElement("div");
            metric_menu_inner.style.position = "absolute";
            metric_menu_inner.style.left = "2.5%";
            metric_menu_inner.style.top = "2.5%"; 
            metric_menu_inner.style.width = "95%";
            //metric_menu_inner.style.height = "95%";
            metric_menu_inner.style.fontSize = "2vh";
            metric_menu_inner.style.opacity = 0;
            metric_menu_inner.style.cursor = "move";
            metric_menu_inner.id = "metric_menu_inner";
            metric_menu_inner.style.backgroundColor = "white";
            metric_menu_inner.style.border = "1.5vh solid white";
            metric_menu_inner.className = "text-center";
            metric_menu_inner.addEventListener("click", radioUpdate);

            // DIV for Collapse Menu
            var collapse_div1 = document.createElement("div");
            collapse_div1.id = "radios1";
            collapse_div1.className = "collapse collapseDiv text-center";
            collapse_div1.setAttribute("data-parent", "#metric_menu_inner");
            collapse_div1.style.left = 0;
            collapse_div1.style.top = 0;
            //collapse_div1.style.backgroundColor = "var(--dark)";
            collapse_div1.style.width = "100%";

            // top div
            //var new_top_div = document.createElement("div");
            //new_top_div.style.height = "8%";
            //new_top_div.className = "text-center";
            //new_top_div.style.left = 0;
            //new_top_div.style.top = 0;
            //new_top_div.style.backgroundColor = "var(--dark)";
            //new_top_div.style.width = "100%";
            //metric_menu_inner.append(new_top_div);

            // LC-MS title
            var new_title = document.createElement("button");
            new_title.style.fontSize = "2vh";
            new_title.style.letterSpacing = "0.4vh";
            new_title.style.fontWeight = 700;
            new_title.style.color = "var(--white)";
            new_title.style.marginBottom = "1em";
            new_title.style.padding = "0em";
            new_title.style.backgroundColor = "var(--dark)";
            new_title.className = "text-center btn btn-block";
            //var new_title = ButtonOffChart("LC-MS METRICS", "metricMenuDrop", function(){});
            //new_title.setAttribute("data-toggle", "collapse");
            //new_title.setAttribute("data-target", "radios1");
            //new_title.className = "btn btn-block btn-custom";
            new_title.setAttribute("type", "button");
            new_title.innerHTML = "LC-MS METRICS";

            // add drop down caret
            var new_caret = document.createElement("span");
            new_caret.style.padding = 0;
            new_caret.style.position = "absolute";
            new_caret.style.right = "1em";
            //new_caret.style.top = 0;
            //new_caret.style.fontSize = "1.5em";
            new_caret.className = "fas fa-caret-down";
            new_title.append(new_caret);
            //new_top_div.append(new_title);
            metric_menu_inner.append(new_title);

            /* radio buttons for metrics*/
            for(let i in machine_data.lcms_metrics){

                // get threshold metrics
                try{
                    var breach_metrics = Object.keys(machine_data.run_data[run_index].summary);
                    breach_metrics = breach_metrics.map(function(metric){
                        return metrics_obj_metab[metric];
                    })
                }
                catch{
                    var breach_metrics = [];
                }
               
                // create radio button and label
                var new_div = document.createElement("div");
                //new_div.className = "text-center";
                var new_label = document.createElement("label");
                new_label.className = "radio form-check-label"; //
                new_label.innerHTML = machine_data.lcms_metrics[i].display_name.replace("_", " ");
                var new_input = document.createElement("input");
                new_input.setAttribute("type", "radio");
                new_input.setAttribute("name", "radioOptions");
                new_input.className = "radio-box";

        
                // add breach marker
                if(breach_metrics.includes(machine_data.lcms_metrics[i].display_name)){
                   var new_marker = document.createElement("span");
                   new_marker.style.padding = 0;
                   new_marker.style.position = "absolute";
                   new_marker.style.right = 0;
                   new_marker.style.top = 0;
                   new_marker.style.opacity = 0;
                   //new_marker.style.fontSize = "1.5em";
                   new_marker.className = "fas fa-exclamation-triangle text-danger new_icon";
                   new_label.append(new_marker);
                }

                new_label.append(new_input);
                new_div.append(new_label);

                collapse_div1.append(new_div);
            };

            metric_menu_inner.append(collapse_div1);

            // Pressure metrics for thermo machines
            if(machine_data.machine_details.machine_type == "thermo"){

                // DIV for Collapse Menu
                var collapse_div2 = document.createElement("div");
                collapse_div2.id = "radios2";
                collapse_div2.className = "collapse collapseDiv";
                collapse_div2.setAttribute("data-parent", "#metric_menu_inner");

                // Pressure Metric title
                var new_title = document.createElement("button");
                new_title.style.fontSize = "2vh";
                new_title.style.letterSpacing = "0.4vh";
                new_title.style.fontWeight = 700;
                new_title.style.color = "var(--white)";
                new_title.style.marginBottom = "1em";
                new_title.style.marginTop = "1em";
                new_title.style.padding = "0em";
                new_title.style.backgroundColor = "var(--dark)";
                new_title.className = "menuBorder text-center btn btn-block";
                new_title.setAttribute("data-toggle", "collapse");
                new_title.setAttribute("data-target", "radios2");
                new_title.setAttribute("type", "button");
                new_title.innerHTML = "PRESSURE METRICS";

                // add drop down caret
                var new_caret = document.createElement("span");
                new_caret.style.padding = 0;
                new_caret.style.position = "absolute";
                new_caret.style.right = "1em";
                //new_caret.style.top = 0;
                //new_caret.style.fontSize = "1.5em";
                new_caret.className = "fas fa-caret-down";
                new_title.append(new_caret);

                metric_menu_inner.append(new_title);

                for(metric in machine_data.pressure_metrics){
                    // create radio button and label
                    var new_div = document.createElement("div");
                    //new_div.className = "text-center";
                    var new_label = document.createElement("label");
                    new_label.className = "radio form-check-label";//
                    new_label.innerHTML = machine_data.pressure_metrics[metric].display_name;
                    var new_input = document.createElement("input");
                    new_input.setAttribute("type", "radio");
                    new_input.setAttribute("name", "radioOptions");
                    new_input.className = "radio-box pressure";

                    new_label.append(new_input);
                    new_div.append(new_label);
                    collapse_div2.append(new_div);
                }

                // add ALL metrics (NOT USED)
                //var new_div = document.createElement("div");
                //var new_label = document.createElement("label");
                //new_label.className = "radio form-check-label";
                //new_label.innerHTML = "All Pressure Metrics";
                //var new_input = document.createElement("input");
                //new_input.setAttribute("type", "radio");
                //new_input.setAttribute("name", "radioOptions");
                //new_input.className = "radio-box pressure";

                //new_label.append(new_input);
                //new_div.append(new_label);
                //collapse_div2.append(new_div);

                metric_menu_inner.append(collapse_div2);
            }
            
            metric_menu_div.append(metric_menu_inner);

            // check the display metric radio button
            var radios = document.getElementsByName("radioOptions");
            for(let i =0; i<radios.length; i++){
                // match name to display_name from DB (watch this), could use obj
                // come from summary page without (), test all metrics with proteomics
                var menu_metric = radios[i].labels[0].innerText.replace(")", "").replace("(", "").toUpperCase(); 
                // disable normalised if box
                if(chart_type == "box"){
                    if(menu_metric == "AREA NORMALISED" || menu_metric == "HEIGHT NORMALISED"){
                        radios[i].disabled = true;
                    }
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                } // disable heat
                else if(chart_type == "heat"){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                    else if(menu_metric == "RETENTION TIME" || menu_metric == "FULL WIDTH HALF MAXIMUM"){
                        radios[i].disabled = true;
                    }
                }
                else if(chart_type == "stream"){
                    if(radios[i].classList.contains("pressure")){
                        radios[i].disabled = true;
                    }
                }

                // check display metric
                //console.log(display_metric);
                //console.log(menu_metric);
                if(menu_metric == display_metric.replace(")", "").replace("(", "").toUpperCase()){
                    radios[i].checked = true;
                }
            }

            // handle collapse menu (show all first)
            document.getElementById("radios1").className = "collapse show collapseDiv";
            if(machine_data.machine_details.machine_type == "thermo"){
                document.getElementById("radios2").className = "collapse show collapseDiv";
            }
            
            // then collapse by menu state (next time React!)
            for(let header in menu_state){
                if(!menu_state[header]){
                    if(header == "lcms"){
                        document.getElementById("radios1").classList.remove("show");
                    }
                    else if(header == "pressure"){
                        if(machine_data.machine_details.machine_type == "thermo"){
                        document.getElementById("radios2").classList.remove("show");
                        }
                    }
                }
            }

            
            // transition on load
            var t = d3.transition().duration(1500);
            if(transition){
                // transition any new icons
                d3.selectAll(".new_icon").transition(t).style("opacity", 1);
                d3.select("#metric_menu_inner").transition(t).style("opacity", 0.95);
            }
            else{
                document.getElementById("metric_menu_inner").style.opacity = 0.95;
                // transition any new icons
                d3.selectAll(".new_icon").transition(t).style("opacity", 1);
            }
        }

        function draw_box_plot(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            var component_indexes = getComponentIndexes();

            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Box Plot";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // get y-axis extents and data
            var y_max = -Infinity;
            var y_min = Infinity;
            var IQR = -Infinity;
            var all_boxes = [];
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){

                    var new_obj = {};
                    new_obj["mean"] = machine_data.components[i].stats[display_metric].mean;
                    new_obj["std"] = machine_data.components[i].stats[display_metric].std;
                    new_obj["min"] = machine_data.components[i].stats[display_metric].min;
                    new_obj["25_percent"] = machine_data.components[i].stats[display_metric]["25_percent"];
                    new_obj["50_percent"] = machine_data.components[i].stats[display_metric]["50_percent"];
                    new_obj["75_percent"] = machine_data.components[i].stats[display_metric]["75_percent"];
                    new_obj["max"] = machine_data.components[i].stats[display_metric].max;
                    new_obj["mode"] = machine_data.components[i].component_mode;
                    new_obj["index"] = parseInt(i);
                    new_obj["colour"] = machine_data.components[i].colour;
                    new_obj["name"] = machine_data.components[i].component_name;
                    new_obj["current"] = machine_data.components[i].lcms_metrics[display_metric].values[run_index];
                    new_obj["missing"] = machine_data.components[i].lcms_metrics[display_metric].missing;
                    // y range
                    if(new_obj["25_percent"] < y_min){
                        y_min = new_obj["25_percent"];
                    }
                    if(new_obj["75_percent"] > y_max){
                        y_max = new_obj["75_percent"];
                    }
                    // IQR
                    if((new_obj["75_percent"] - new_obj["25_percent"]) > IQR){
                        IQR = new_obj["75_percent"] - new_obj["25_percent"]; 
                    }
                    all_boxes.push(new_obj); 
                }
            }

            // set the dimensions and margins of the plot
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight+2*v_height_unit, 
                          left: 4*v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            boxChartWidth = plot_width - margin.left - margin.right; // global for transition
            
            // boxwidth
            var box_padding = v_width_unit;
            if(component_indexes.length > 3){
                 box_width = (width - (box_padding*(component_indexes.length)+ box_padding))/component_indexes.length;
            }
            else{
                box_width = width/4;
            }
            box_area_height = plot_height - margin.top - margin.bottom;

            /*
            // sort by median
            all_boxes = all_boxes.sort(function(a, b) {
               return a["50_percent"] > b["50_percent"] ? -1 : 1;
            });
        
            // sort polarity (pos first)
            all_boxes = all_boxes.sort(function(a, b){
                return a["mode"] < b["mode"]? -1 : 1;}
                ) ;
            */

            // sort by current
            all_boxes = all_boxes.sort(function(a, b) {
               return a["current"] > b["current"] ? -1 : 1;
            });

            // names for x scale
            var names = all_boxes.map(function(obj){
                return obj.name;
            });

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFillUpper = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradupper')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillUpper.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            gradFillUpper.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            var gradFillLower = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradlower')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillLower.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            gradFillLower.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            // circle gradient fills
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("cursor", "crosshair")
                .attr("id", "backBox")
                .attr("width", width)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0)
                .on("dblclick", function(){
                    moveBoxes(true);
                })
            // x scale
            xScale_box = d3.scaleBand()
                .range([0, width])
                .domain(names)
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // x-axis 
            //var x_axis = d3.axisBottom().scale(xScale_box).tickValues([]).tickSizeOuter(0);

            // x-axis-call
            //var x_axis_call = svg.append("g")
            //.attr("transform", "translate(0," + (box_area_height-1) + ")") // -1 else hides axis
            //.attr("class", "axis-chart")
            //.call(x_axis);// x scale

            // y-scale
            // set at outlier limit
            //var IQR = y_max - y_min;
            y_min = y_min - IQR;
            y_max = y_max + IQR;
            // no less than zero for time metrics
            if(display_metric != "Mass Error (ppm)" && display_metric != "Mass Error (mDa)"){
                if(y_min < 0){
                    y_min = 0;
                }
            }

            // cap 
            if(display_metric == "Mass Error (ppm)"){
                if(component_indexes.length > 3){
                    y_min = - 6;
                    y_max = 6;
                }
            }
            else if(display_metric == "Tailing" || display_metric == "Asymmetry"){
                if(component_indexes.length > 3){
                        y_min = 0;
                        y_max = 4;
                }
            }
            
            // yscale and domains
            if(yScale_box == null){
                yScale_box = d3.scaleLinear()
                    .domain([y_min , y_max])
                    .range([box_area_height, 0]);
            }
            var yScale_box_reset = yScale_box.domain();

            // y-axis
            var y_axis = d3.axisLeft().scale(yScale_box)
            .tickSize(v_height_unit).tickSizeOuter(0);
            
            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale_box).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', function(){
                if(theme == "dark"){return "gridlines axis-grid-dark";}
                return "gridlines axis-grid-light";
            })
            .call(yAxisGrid);

            // add threshold markers
            var thresholds = getThresholds();
            if(Object.keys(thresholds).length > 0){
                // lower thresh
                if(thresholds.threshold_low != ""){
                    svg.append("line")
                    .attr("id", "thresh_low")
                    .attr("x1", 0)
                    .attr("y1", yScale_box(thresholds.threshold_low))
                    .attr("x2", width)
                    .attr("y2", yScale_box(thresholds.threshold_low))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_low = 0;
                }

                // upper thresh
                if(thresholds.threshold_high != ""){
                    svg.append("line")
                    .attr("id", "thresh_high")
                    .attr("x1", 0)
                    .attr("y1", yScale_box(thresholds.threshold_high))
                    .attr("x2", width)
                    .attr("y2", yScale_box(thresholds.threshold_high))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_high = box_area_height;
                }

                // rect overlay (top)
                svg.append("g")
                .append("rect")
                .attr("class", "topoverlay")
                .attr("width", width)
                .attr("height", function(){
                    var check_height = yScale_box(thresholds.threshold_high);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",0)
                .style("opacity",0.5)
                .attr("fill", function(){
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                    //return 'url(#gradupper)';
                });
                

                // rect overlay (bottom)
                if(thresholds.threshold_low != 0){
                    svg.append("g")
                    .append("rect")
                    .attr("class", "bottomoverlay")
                    .attr("width", width)
                    .attr("height", function(){
                        var check_height = box_area_height - yScale_box(thresholds.threshold_low);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;

                    })
                    .attr("x",0)
                    .attr("y",yScale_box(thresholds.threshold_low))
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradlower)';
                    });
                }
            }

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label boxText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (box_area_height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(y_labels[display_metric].toUpperCase());

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric boxText")
            .attr("y", -width- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            // optimal line
            var optimals = ["Mass Error (ppm)", "Mass Error (mDa)", "Tailing", "Asymmetry"];
            if(optimals.includes(display_metric)){
                if(display_metric == "Mass Error (ppm)" || display_metric == "Mass Error (mDa)"){
                    var marker = 0;
                }
                else{
                    var marker = 1;
                }
                svg
                .append("line")
                .attr("id", "optimal_marker")
                .attr("x1", 0)
                .attr("y1", yScale_box(marker))
                .attr("x2", width)
                .attr("y2", yScale_box(marker))
                .attr("stroke", function(){
                    if(theme == 'dark'){return "aliceblue";}
                    return "var(--dark)";
                })
                .attr("stroke-width", 2*base_line_width)
                .attr("opacity", 1); 
            }

            // add the boxes
            svg
            .selectAll("boxes")
            .data(all_boxes)
            .enter()
            .append("rect")
                .attr("x", function(d){return(xScale_box(d.name)- box_width/2)})
                .attr("y", function(d){return(yScale_box(d["75_percent"]))})
                .attr("height", function(d){return(yScale_box(d["25_percent"])-yScale_box(d["75_percent"]))})
                .attr("width", box_width)
                .attr("stroke", function(d){return(d.colour)})
                .attr("stroke-width", lineWidth)
                .attr("filter", "url(#specular)")
                .style("fill", function(d){
                    return 'url(#circleGradLight'+d.index+')';//d.colour
                })
                .style("fill-opacity", 0.5)
                .style("opacity", 0.8)
                .attr("id", function(d, i){return "rect"+d.index})
                .attr("class", "box")
                .attr("cursor", "pointer")
                .on("mouseover", function(event, d){
                    // tooltip
                    var tooltip = d3.select("#tooltip");

                    // focus/reset text
                    if(d.index != boxExpand){
                        var click_text = "Click to Focus";
                    }
                    else{
                        var click_text = "Click to Reset";
                    }

                    var tooltipHTML = "<strong>" + d.name + "</strong><br>" +
                                    "<strong>Q1 </strong>" + d["25_percent"].toFixed(3) + "<br>" +
                                    "<strong>Q3 </strong>" + d["75_percent"].toFixed(3) + "<br>" +
                                    "<strong>Median </strong>" + d["50_percent"].toFixed(3) + "<br>" +
                                    "<strong>Mean </strong>" + d["mean"].toFixed(3) + "<br>" + click_text;
                                        
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+30) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                    // highlight
                    highlightBox(d.index, 0.1);
                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                    resetHighlight();
                })
                .on("click", function(event, d){
                    
                    // expand
                    if(d.index != boxExpand){
                        // get new extents
                        var newMinY = d["25_percent"];
                        var newMaxY = d["75_percent"];
                        var current = d.current;
                        if(current > newMaxY){newMaxY = current;}
                        if(current < newMinY){newMinY = current;}

                        // offset
                        var boxRange = newMaxY - newMinY;
                        newMaxY = newMaxY + boxRange/4;
                        newMinY = newMinY - boxRange/4;

                        // change and store domain
                        yScale_box.domain([newMinY, newMaxY]);
                        boxExpand = d.index;

                        // highlight
                        //highlightBox(d.index, 0.3);
                    }
                    else{
                        // contract
                        yScale_box.domain(yScale_box_reset);
                        boxExpand = -1;
                        //resetHighlight();
                    }
                    resetHighlight();

                    y_axis_call.transition().duration(1000).call(y_axis);
                    moveBoxes(false);

                });

            // medians
            svg
            .selectAll("medianLines")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
            .attr("y2", function(d){return(yScale_box(d["50_percent"]))})
            .attr("stroke", function(d){return(d.colour)})
            .attr("stroke-width", lineWidth)
            .attr("class", function(d){return "boxline boxline" + d.index});

             // means
             svg
            .selectAll("meanLines")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(d.name)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["mean"]))})
            .attr("y2", function(d){return(yScale_box(d["mean"]))})
            .attr("stroke", function(d){return(d.colour)})
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 0) // blocekd atm
            .attr("class", function(d){return "boxline boxline" + d.index})
            .style("stroke-dasharray", ("0.5vh, 0.5vh"));

            // extenders
            svg
            .selectAll("extenders")
            .data(all_boxes)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(d.name))})
            .attr("x2", function(d){return(xScale_box(d.name))})
            .attr("y1", function(d){
                var y1;
                if(d.current >= d["75_percent"]){
                    y1 = yScale_box(d.current);
                }
                else if(d.current <= d["25_percent"]){
                    y1 = yScale_box(d["25_percent"]);
                }
                else{
                    y1 =  yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y1 < 0){
                    return 0;
                }
                */
                return y1;
                
            })
            .attr("y2", function(d){
                var y2;
                if(d.current >= d["75_percent"]){
                    y2 = yScale_box(d["75_percent"]);
                }
                else if(d.current <= d["25_percent"]){
                    y2 = yScale_box(d.current);
                }
                else{
                    y2 = yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y2 > box_area_height){
                    return box_area_height;
                }
                */
                return y2;
                
            })
            .attr("stroke", function(d){return d.colour})
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", lineWidth)
            .attr("class", function(d){return "extender extender" + d.index});

            // current run
            svg
            .selectAll("currentRun")
            .data(all_boxes)
            .enter()
            .append("circle")
            .attr("cx", d => xScale_box(d.name))
            .attr("cy", function(d){
                    return yScale_box(d.current)
                })
            .attr("r", currentRadius)
            .attr("x", function(d, i) {return xScale_box(d.name)})
            .attr("y", function(d){
                    return yScale_box(d.current)
                })
            .attr("stroke", function(d, i) {return d.colour})
            .attr("stroke-width", lineWidth/2)
            .attr("stroke-opacity", 0.5)
            .attr("cursor", "pointer")
            .attr("filter", "url(#specular)")
            .attr("class","point")
            .attr("id",  function(d, i) {return "circle" + d.index})
            .attr("fill", function(d,j){
                var miss = d.missing;
                if(miss.includes(run_index)){
                    return "var(--dark)";
                }
                else{
                    return d.colour;// 'url(#circleGradLight'+d.index+')' ;   
                }
            })
            .on("mouseover", function(event, d){ // tooltip on hover

                var tooltip = d3.select("#tooltip");
                var miss = d.missing;
                if(miss.includes(run_index)){
                    var tooltipHTML = "<strong>" + d.name.replace("_", " ") + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        "NO VALUE" + "</strong>";
                } else{
                    var tooltipHTML = "<strong>" +  d.name.replace("_", " ")  + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        Number.parseFloat(d.current).toFixed(3) + "</strong>";
                }

                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX + 30) + 'px');
                tooltip.style('top', (event.pageY + 30) + 'px');
                tooltip.style("font-size", "0.8vw");
                tooltip.style("visibility", "visible");

                // highlight
                highlightBox(d.index, 0.1);

            })
            .on("mouseout", function(){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                resetHighlight();
                
            })
            .on("click", function(event, d){
                comp_index = d.index;
                draw_chromatogram(true);
            })

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .call(y_axis)
            .attr("id", "yAxisLine")
            .style('font-size', '1.8vh');

            function highlightBox(dIndex, opac){
                d3.selectAll(".box").style("opacity", opac);
                d3.select("#rect"+dIndex).style("opacity", 1);
                //d3.select("#rect"+boxExpand).style("opacity", 1);

                d3.selectAll(".point").style("opacity", opac);
                d3.select("#circle"+dIndex).style("opacity", 1);
                //d3.select("#circle"+boxExpand).style("opacity", 1);

                d3.selectAll(".boxline").style("opacity", opac);
                d3.selectAll(".boxline"+dIndex).style("opacity", 1);
                //d3.selectAll(".boxline"+boxExpand).style("opacity", 1);
                
                d3.selectAll(".extender").style("opacity", opac);
                d3.selectAll(".extender"+dIndex).style("opacity", 1);
                //d3.selectAll(".extender"+boxExpand).style("opacity", 1);
            }

            function resetHighlight(){
                d3.selectAll(".box").style("opacity", 0.8);
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".boxline").style("opacity", 1);
                d3.selectAll(".extender").style("opacity", 1); 
            }
            
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".box").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".boxline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".extender").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".boxText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            
        }

        function streamChartFilterUpdate(){
            // allow for circles (on full view, even for stream)
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
                xScale_chart.domain([minX, maxX]);
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
                xScale_chart.domain([maxX, minX]);
            }

            // get new ymax (total view only)
            var component_indexes = getComponentIndexes();
            var y_max = -Infinity;
            for(let j = 0; j < x_values_chart.length; j++){
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                        else{
                            break;
                        }
                    }
                }
            }

            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // update y scale
            if(!streamExpand){
                yScale_stream.domain([y_max, 0]);
            }

            // y-axis
            d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

            // x-axis
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);

            // streams
            d3.selectAll(".streams")
            .transition().duration(1000)
            .attr("d", area);

            // marker
            d3.select("#marker")
            .transition()
            .duration(1000)
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("x2", xScale_chart(x_values_chart[run_index]));
        }

        function lineChartFilterUpdate(){

            // allow for circles (on full view)
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
                xScale_chart.domain([minX, maxX]);
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
                xScale_chart.domain([maxX, minX]);
            }


            if(metric_type == "pressure"){
                /*pressure data update*/
                // y values and missing indexes
                for(let i in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[i].display_name == display_metric){
                        var y_values = machine_data.pressure_metrics[i].values;
                        var missing = machine_data.pressure_metrics[i].missing;
                        break;
                    }
                };

                // set y scale domain
                var maxY = d3.max(y_values.slice(0, filter));
                var minY = d3.min(y_values.slice(0, filter));
                var offsetY = (2*currentRadius/pressureHeight)*(maxY-minY);
                yScale_pressure.domain([minY - offsetY, maxY + offsetY]);
            }

            if(metric_type == "pressure"){
                // getarray for stats (based on filter)
                var statsData = [];
                for(let i = filter-1; i>=0; i--){
                    // stats data
                    if(!(missing.includes(i))){
                        statsData.push(y_values[i]);
                    }
                }

                // calculate stats
                statsArr = [{"name": "Mean", "value": calcAverage(statsData)}, 
                                {"name": "Median", "value": calcQuartile(statsData, 50)}, 
                                {"name": "Q1", "value": calcQuartile(statsData, 25)},
                                {"name": "Q3", "value": calcQuartile(statsData, 75)}];
                
                // sort to handle display offsets
                statsArr = statsArr.sort(function(a,b){ return parseFloat(a.value) - parseFloat(b.value);});
            }

            // change domain and re-draw
            if(metric_type == "lcms"){
                reDrawChart();
            }else{
                reDrawPressureChart();
            }

        }

        function setTimeScale(){
            /* FIND DOMAIN FROM CURRENT SCALE */
            var rightDomain = xScale_chart.domain()[1];
            var leftDomain = xScale_chart.domain()[0];

            // get index for time values
            var timeMaxIndex = Math.floor(leftDomain) - 1;
            var timeMinIndex = Math.ceil(rightDomain) - 1;
    
            // catch same or flipped
            if(timeMaxIndex <= timeMinIndex){
                if(timeMaxIndex - 1 < filter){
                    timeMinIndex += 1;
                }
                else{
                    timeMinIndex = 0;
                    timeMaxIndex = filter - 1;
                }
            }

            // catch negative min
            if(timeMinIndex < 0){timeMinIndex = 0;}

            // catch too big max
            if(timeMaxIndex >= filter){timeMaxIndex = machine_data.run_data.length - 1;}

            /*** update scales, axis and x values ***/
            /** Warning upside down time logic **/
            x_values_chart = x_values_time;
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            var maxX = new Date(+x_values_chart[timeMinIndex] + offsetX); // + needed as hint else it will concatenate
            var minX = new Date(x_values_chart[timeMaxIndex] - offsetX); 
            
            // scale
            xScale_time.domain([minX, maxX]);
            xScale_chart = xScale_time;

            // axis
            x_axis_time.scale(xScale_time);
            x_axis = x_axis_time;

            // x-axis transition
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);
        }

        function setRunScale(){
            // greater is more recent
            // domain[0] is oldest (left of chart)
            // domain[1] is newest (right of chart)

            /* FIND DOMAIN FROM CURRENT SCALE */
            var rightDomain = xScale_chart.domain()[1];
            var leftDomain = xScale_chart.domain()[0];

            var runsMaxIndex = 0;
            var runsMinIndex = x_values_time.length - 1;

            // find runs max index (newest)
            // first one less than right domain
            for(let i = 0;  i < x_values_time.length; i++){
                if(x_values_time[i] < rightDomain){
                    runsMaxIndex = i;
                    break;
                }
            }
            // find runs min index (oldest)
            // first one greater than left domain in reverse
            for(let i = x_values_time.length-1;  i >= 0; i--){
                if(x_values_time[i] > leftDomain){
                    runsMinIndex = i;
                    break;
                }
            }

            // catch same or flipped (upside down logic and in run scale!!)
            if(runsMaxIndex >= runsMinIndex){
                runsMaxIndex = 0;
                runsMinIndex = x_values_time.length - 1;
            }

            /*** update scales, axis and x values ***/
            x_values_chart = x_values_runs;
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));

            // scale
            xScale_runs.domain([runsMinIndex+1+offsetX, runsMaxIndex+1-offsetX]);
            xScale_chart = xScale_runs;

            // axis
            x_axis_runs.scale(xScale_runs);
            x_axis = x_axis_runs;

            // x-axis transition
            d3.select("#xAxisLine").transition().duration(1000).call(x_axis);
        }

        function updateChangeScalePressure(){

            // get pressure data
            // y values 
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var y_values = machine_data.pressure_metrics[i].values;
                    break;
                }
            };

            // ADD points in loop so can raise
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                // swap data and transition
                d3.selectAll(".circle"+i)
                    .data(data)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_pressure(d.y));
            }

            /* get line, change data and re-draw */
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_pressure(d.y)});

            // convert to d3 friendly format
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }
                    
            d3.selectAll(".chartline")
                .datum(data)
                .transition()
                .duration(1000)
                .attr("d", line);
                

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_pressure_line(false);
            }, 1000);
        }

        function  updateChangeScale(){

            /* get all circles, change data and re-draw */
            var component_indexes = getComponentIndexes();
            for(let j = x_values_chart.length-1; j>=0; j--){
                var data = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                        // convert to d3 friendly format
                        
                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j, 'comp': i};
                        data.push(new_row);
                    }
                }

                // order for display
                data = data.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});
                //console.log(data);

                // swap data and transition
                d3.selectAll(".circle"+j)
                    .data(data)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_chart(d.y));
            }

            /* get all lines, change data and re-draw */
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_chart(d.y)});

            // move line (per component)
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j < x_values_chart.length; j++){

                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }
                    
                    d3.selectAll(".chartline"+i)
                        .datum(data)
                        .transition()
                        .duration(1000)
                        .attr("d", line);
                }
            }

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_line_chart(false);
            }, 1000);
            
        }

        function update_stream_graph(selectOne){
            //** called to transition component change **//
            // transition removed, see metab code

            // loop for d3 stacked data
            var component_indexes = getComponentIndexes();
            var d3_data = [];
            var y_max = -Infinity;
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                let total = 0;
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                        total += new_value;
                    }

                    // get total and store max (in filter range)
                    if(total > y_max){
                        if(j<filter){
                            y_max = total;
                        }
                    }
                }
                d3_data.push(new_row);
            }

            // update y scale
            if(!streamExpand){
                yScale_stream.domain([y_max, 0]);
            }

            // handle single component in expand (reset to no offset)
            if(streamExpand && component_indexes.length == 1){
                // reset y domain and axis
                yScale_stream = yScale_stream_total;
                y_axis_stream = y_axis_stream_total;

                // change stack
                offsetType = d3.stackOffsetNone;

                streamExpand = false;
            }

            // y-axis
            d3.select("#yAxisLine").transition().duration(1000).call(y_axis_stream);

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            if(selectOne){
                d3.selectAll(".streams").style("opacity", 0);
            }

            if(streamExpand && component_indexes.length == 1){
                d3.selectAll(".streams").style("opacity", 0);
            }

            // streams
            /*
            d3.selectAll(".streams")
            .data(stack)
            .transition().duration(1000)
            .style("fill", function(d) {
                    return  'url(#circleGradLight' + d.key +')'; //colourByKey[d.key];
                })
            .style("stroke", function(d) {return colourByKey[d.key];})
            .style("opacity", 1)
            .attr("d", area);
            */

            // re-draw to reset
            setTimeout(function(){
                draw_stream_graph(false);
            }, 1000);

        }

        function updateChangeScaleStream(){

            // loop for d3 stacked data
            var d3_data = [];
            var component_indexes = getComponentIndexes();
            for(let j = 0; j < x_values_chart.length; j++){
                let new_row = {'x': x_values_chart[j], 'index': j};
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_value = Math.abs(machine_data.components[i]["lcms_metrics"][display_metric].values[j]);
                        new_row[machine_data.components[i].component_name] = new_value;
                    }
                }
                d3_data.push(new_row);
            }

            // create stacked areas
            var stackedData = d3.stack()
            .offset(offsetType)
            .order(d3.stackOrderNone)
            .keys(stackKeys);

            var stack = stackedData(d3_data);
            var area = d3.area().curve(d3.curveBasis) //d3.curveBasis
                    .x(function(d) { return xScale_chart(d.data.x);})
                    .y0(function(d) { return yScale_stream(d[0]);})
                    .y1(function(d) { return yScale_stream(d[1]);});

            // streams
            d3.selectAll(".streams")
            .data(stack)
            .transition().duration(1000)
            .attr("d", area);

            // move vertical marker
            d3.select("#marker")
                .transition()
                .duration(1000)
                .attr("x1", xScale_chart(x_values_chart[run_index]))
                .attr("x2", xScale_chart(x_values_chart[run_index]));

            // re-draw to reset
            setTimeout(function(){
                draw_stream_graph(false);
            }, 1000);

        }

        function getComponentIndexes(){
            // get indexes of checked components
            var component_indexes = [];

            d3.selectAll(".negative").each(function(d,i){
                if(checked_components[d.component_name]){
                    component_indexes.push(d.c_index+"");
                }
            });

            d3.selectAll(".positive").each(function(d,i){
                if(checked_components[d.component_name]){
                    component_indexes.push(d.c_index+"");
                }
            });
            return component_indexes;
        }

        function update_parallel_graph(){
            
            // update paths

            // get indexes of checked components
            var component_indexes = getComponentIndexes();
            var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                                "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                                "Full Width Half Maximum"];

            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var pathData = {};
                    for(let j in metrics){
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        pathData[metrics[j]]= new_value;
                    }

                    pathData["cIndex"] = i;
                    pathData["colour"] = machine_data.components[i].colour;
                    pathData["name"] = machine_data.components[i].component_name;

                    d3.selectAll(".lines"+i)
                    .datum(pathData)
                    .transition().duration(1000)
                    .attr("d", path);
                }
            }

            // update circles
            for(let j in metrics){
                var circleData = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_circle = {};
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        new_circle["x"]= metrics[j];
                        new_circle["y"] = new_value;
                        new_circle["colour"] = machine_data.components[i].colour;
                        new_circle["name"] = machine_data.components[i].component_name;
                        new_circle["comp"] = i;
                        circleData.push(new_circle);
                    }
                    
                    // order
                    circleData = circleData.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});

                    // swap data and transition
                    d3.selectAll(".point"+j)
                    .data(circleData)
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_par(d.x))
                    .attr("cy", d => yScales[d.x](d.y))
                    .attr("fill", function(d,i){
                        var miss = machine_data.components[d.comp].lcms_metrics[d.x].missing;
                        if(miss.includes(run_index)){
                            return "var(--dark)";
                        }else{
                            return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                        } 
                    })
                }
            }
        }

        // curved line function for parallel chart(from d3 gallery example)
        function path(d) {
                // get all metrics (hard code for order)
                var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                                "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                                "Full Width Half Maximum"];
                return d3.line().curve(d3.curveMonotoneX)(metrics.map(function(p) { return [xScale_par(p), yScales[p](d[p])]; }));
        }

        function draw_parallel_graph(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the graph
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, right: v_width_unit, 
                bottom: chart_bottom.offsetHeight + 2*v_height_unit, left: v_width_unit};
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.opacity = 1;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clipPar") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clipPar)")
                .attr("id", "all_lines");

            // get all metrics (hard code for order)
            var metrics = ["Retention Time", "Mass Error (ppm)", "Mass Error (mDa)",
                            "Area (normalised)", "Height (normalised)", "Tailing", "Asymmetry",
                            "Full Width Half Maximum"];

            // data structure for expand/contract
            var axesExpand = {"Retention Time":false, "Mass Error (ppm)":false, "Mass Error (mDa)":false,
                            "Area (normalised)":false, "Height (normalised)":false, "Tailing":false, "Asymmetry":false,
                            "Full Width Half Maximum":false};
           

            // get indexes of checked components
            var component_indexes = getComponentIndexes();

            // set scales function
            function setScales(){
                let Scales = {};
                for(let j in metrics){
                    var newScale = d3.scaleLinear()
                            .range([height-currentRadius, currentRadius]);
                            
                    if(metrics[j] == "Mass Error (ppm)"){
                        newScale.domain([-4, 4]);
                    }
                    else if(metrics[j] == "Mass Error (mDa)"){
                        newScale.domain([-3, 3]);
                    }
                    else if(metrics[j]== "Tailing"){
                        newScale.domain([0, 2]);
                    }
                    else if(metrics[j] == "Asymmetry"){
                        newScale.domain([0, 2]);
                    }
                    else if(metrics[j] == "Retention Time"){
                        newScale.domain([0, 30]); // get from processing
                    }
                    else if(metrics[j] == "Full Width Half Maximum"){
                        newScale.domain([0, 30]);
                    }
                    else if(metrics[j] == "Area (normalised)"){
                        newScale.domain([-3, 3]);
                    }
                    else if(metrics[j] == "Height (normalised)"){
                        newScale.domain([-3, 3]);
                    }
                    Scales[metrics[j]] = newScale;
                }
                return Scales;
            }

            // get scale domain for reset
            function getDomain(metricName){
                if(metricName == "Mass Error (ppm)"){
                        return [-4, 4];
                }
                else if(metricName == "Mass Error (mDa)"){
                    return [-3, 3];
                }
                else if(metricName== "Tailing"){
                    return [0, 2];
                }
                else if(metricName == "Asymmetry"){
                    return [0, 2];
                }
                else if(metricName == "Retention Time"){
                    return [0, 30];
                }
                else if(metricName == "Full Width Half Maximum"){
                    return [0, 30];
                }
                else if(metricName == "Area (normalised)"){
                    return [-3, 3];
                }
                else if(metricName == "Height (normalised)"){
                    return [-3, 3];
                }
            }
            
            if(Object.keys(yScales).length == 0){
                yScales = setScales();
            }

            // update range if controls changed
            var newRange = height - currentRadius;
            for(let i in yScales){
                yScales[i].range([newRange, currentRadius]);
            }

            // find the best position for each Y axis
            if(xScale_par == null){
                xScale_par = d3.scalePoint()
                    .range([0, width])
                    .padding(1)
                    .domain(metrics);
            }

            var midDist = (xScale_par("Asymmetry") - xScale_par("Tailing"))/2;

            // draw the axes
            all_lines.selectAll("myAxis")
            .data(metrics).enter()
            .append("g")
            .attr("transform", function(d) { return "translate(" + xScale_par(d) + ")"; })
            .each(function(d) { d3.select(this).call(d3.axisLeft().tickSize(2*currentRadius).ticks(5).scale(yScales[d])); })
            .attr("class", "parAxes")
            .style("opacity", 0.7)
            .style('font-size', '1.8vh');

            // get and draw path data
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var pathData = {};
                    for(let j in metrics){
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        pathData[metrics[j]]= new_value;
                    }
                    
                    pathData["cIndex"] = i;
                    pathData["colour"] = machine_data.components[i].colour;
                    pathData["name"] = machine_data.components[i].component_name;
                    
                    // draw the line
                    all_lines.append("path")
                    .datum(pathData)
                    .style("fill", function(d){
                        return "none";
                    })
                    .attr("d", path)
                    .attr("class", "lines lines"+i)
                    .style("stroke", d => d.colour)
                    .style("stroke-width", lineWidth)
                    .style("stroke-opacity", 0.5)
                    .on("mouseover", function(event, d){
                        var yRT = machine_data.components[d.cIndex]["lcms_metrics"]["Retention Time"].values[run_index];

                        // add comp name
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", xScale_par("Retention Time") - 4.2*currentRadius)
                        .attr("y", yScales["Retention Time"](yRT) + currentRadius)
                        .attr("text-anchor", "end")
                        .style("font-size", "1vw")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        //.style("text-shadow", "0.1vh 0.1vh gray")
                        .text(d.name);

                        // highlight
                        d3.selectAll(".lines").style("opacity", function(e){
                            if(e.cIndex == d.cIndex){return 1;}
                            return 0.1;
                        });
                        d3.selectAll(".point").style("opacity", function(e){
                            if(e.comp == d.cIndex){return 1;}
                            return 0.1;
                        });
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".lines").style("opacity", 1);
                        d3.selectAll(".point").style("opacity", 1);
                        d3.selectAll(".hover-text").remove();
                    });

                }
            }

            // get and draw circles (metrics first loop for order)
            for(let j in metrics){
                var circleData = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var new_circle = {};
                        var new_value = machine_data.components[i]["lcms_metrics"][metrics[j]].values[run_index];
                        new_circle["x"]= metrics[j];
                        new_circle["y"] = new_value;
                        new_circle["colour"] = machine_data.components[i].colour;
                        new_circle["name"] = machine_data.components[i].component_name;
                        new_circle["comp"] = i;
                        circleData.push(new_circle);
                    }
                    
                }

                // order and draw
                circleData = circleData.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});
                
                // points
                all_lines.append("g")
                .selectAll("circle")
                .data(circleData)
                .join("circle")
                .attr("cx", d => xScale_par(d.x))
                .attr("cy", d => yScales[d.x](d.y))
                .attr("r", currentRadius)
                .attr("class", "point point"+j)
                .attr("filter", "url(#specular)")
                .attr("stroke", d => d.colour)
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", 0.5)
                .attr("cursor", "pointer")
                .attr("fill", function(d,i){
                    var miss = machine_data.components[d.comp].lcms_metrics[d.x].missing;
                    if(miss.includes(run_index)){
                        return "var(--dark)";
                    }else{
                        return d.colour; //'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                .on("mouseover", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    if(!axesExpand[d.x]){
                        var tool_text = "Click to Expand Axis";
                    }else{
                        var tool_text = "Click to Reset Axis";
                    }
                    tooltip.html(tool_text);
                    tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                    tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                    tooltip.style("visibility", "visible");

                })
                .on("mouseout", function(event){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");
                })
                .on("click", function(event, d){
        
                    // get values at metric
                    var yValues = [];
                    var metricCircles = d3.selectAll(".point").filter(function(e){
                        if(e.x == d.x){
                            yValues.push(e.y);
                            return e.y;
                        }
                    });

                    if(!axesExpand[d.x]){
                        // change y scale domain (expand)
                        var offsetY = (4*currentRadius/height)*(d3.max(yValues)-d3.min(yValues));
                        yScales[d.x].domain([d3.min(yValues) -offsetY, d3.max(yValues) + offsetY]);
                        axesExpand[d.x] =true;
                    }
                    else{ // contract
                        yScales[d.x].domain(getDomain(d.x));
                        axesExpand[d.x] = false;
                    }

                    // redraw circles
                    d3.selectAll(".point").transition().duration(1000)
                    .attr("cy", d => yScales[d.x](d.y));

                    // redraw lines
                    d3.selectAll(".lines").transition().duration(1000)
                    .attr("d", path);

                    // axis
                    d3.selectAll(".parAxes")
                    .each(function(d) { d3.select(this).transition().duration(1000)
                        .call(d3.axisLeft().tickSize(2*currentRadius).ticks(5).scale(yScales[d])); });
                });
            }

            // add metric names (dont set x and y to rotate, put in translate)
            svg.selectAll("metricnames")
            .data(metrics).enter()
            .append("text")
            .style("text-anchor", "middle")
            //.style("cursor", "pointer")
            .on("click", function(event, d){
                /* removed, need to add logic for button disabled to include
                // change background and update state
                var buttons = document.getElementsByName("chart-buttons");
                for(let i =0; i<buttons.length; i++){
                    if(buttons[i].id == "line"){
                        buttons[i].style.backgroundColor = "white";
                        buttons[i].style.color = "var(--dark)";
                        buttons[i].style.borderColor = "var(--dark)";
                    }else{
                        buttons[i].style.backgroundColor = "var(--dark)";
                        buttons[i].style.color = "white";
                        buttons[i].style.borderColor = "var(--info)";
                    }
                }

                // set stae and draw
                display_metric = d;
                chart_type = "line";
                metric_type = "lcms";
                draw_line_chart(true);

                // chart buttons logic
                if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                    document.getElementById("box").disabled = true;
                }
                else{
                    document.getElementById("box").disabled = false;
                }

                // chart buttons logic
                if(display_metric == "Retention Time" || display_metric == "Full Width Half Maximum"){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("stream").disabled = false;
                }
                else{
                    document.getElementById("heat").disabled = false;
                    document.getElementById("density").disabled = false;
                    document.getElementById("stream").disabled = false;
                }

                // enable all radios and check
                var radios = document.getElementsByName("radioOptions");
                for(let i = 0; i<radios.length; i++){
                    var radio_name = radios[i].labels[0].innerText;
                    radios[i].disabled = false;
                    if(radio_name == display_metric){
                        radios[i].checked = true;
                    }
                }
                */
            })
            .attr("class", "label-metric lineText")
            .attr("transform", function(d) {
                return "translate(" + xScale_par(d) + " " + height/2 + ") rotate(90)";
            })
            .attr("dy", -midDist/2)
            .text(function(d) { return d.toUpperCase(); })
            .attr("fill", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            }).raise();

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = "ALL LC-MS METRICS";

            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".lines").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".parAxes").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }

        }

        function draw_line_chart(transition){ 
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // function vars
            var currentMaxY;
            var currentMinY;

            // set the dimensions and margins of the plot
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            plot_area.style.opacity = 1;
            
            // get indexes of checked components
            var component_indexes = getComponentIndexes();
    
            // 0 components overlay
            if(component_indexes.length == 0){
                plot_area.style.backgroundColor = "var(--dark)";
                plot_area.style.opacity = 0;
                var new_icon = document.createElement("span");
                new_icon.className = "fas fa-long-arrow-alt-left"
                new_icon.style.fontSize = "3em";
                new_icon.style.position = "absolute";
                new_icon.style.color = "var(--white)";
                new_icon.style.left = "45%";
                new_icon.style.top = "30%";
                var new_display = document.createElement("p");
                new_display.className = "text-center";
                new_display.innerHTML = "Select at Least One Component to View a Line Chart";
                new_display.style.position = "absolute";
                new_display.style.left = "50%";
                new_display.style.top = "50%";
                new_display.style.transform = "translate(-50%, -50%)";
                new_display.style.color = "white";
                plot_area.append(new_icon);
                new_display.style.opacity = 1;
                plot_area.append(new_display);
                var t = d3.transition().duration(1500);
                d3.select("#plot_chart").transition(t).style("opacity", 0.5);
                return;
            }
            else{ 
                plot_area.style.backgroundColor = "inherit";
            }

            // get y-axis extents (or cap)
            var y_max = -Infinity;
            var y_min = Infinity;
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var new_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    var new_min = d3.min(new_values);
                    var new_max = d3.max(new_values);
                    if(new_max > y_max){
                        y_max = new_max;
                    }
                    if(new_min < y_min){
                        y_min = new_min;
                    }
                }
            }

            //cap
            if(display_metric == "Mass Error (ppm)"){
                if(component_indexes.length > 4){
                    y_min = - 5;
                    y_max = 5;
                }
            }
            else if(display_metric == "Tailing" || display_metric == "Asymmetry"){
                if(component_indexes.length > 4){
                    y_min = 0;
                    y_max = 3;
                }
            }
            else if(display_metric == "Full Width Half Maximum"){
                if(component_indexes.length > 4){
                    y_min = 0;
                    y_max = 30;
                }
            }

            

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // gradient fill
            var gradFillUpper = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradupper')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')


            gradFillUpper.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            gradFillUpper.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            var gradFillLower = svg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'gradlower')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%')

            gradFillLower.append('stop')
            .attr('offset', '0%')
            .style('stop-color', 'rgba(0,0,0, 0.01)')
            .style('stop-opacity', 1);

            gradFillLower.append('stop')
            .attr('offset', '100%')
            .style('stop-color', 'rgba(0,0,0, 0.5)')
            .style('stop-opacity', 1);

            // circle gradient fills
            for(let i in component_indexes){
                
                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradDark' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', 'var(--dark)')
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', 'circleGradLight' + component_indexes[i])
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%')

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '50%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

                var gradFill = svg
                .append('defs')
                .append('radialGradient')
                .attr('id', 'circleGradLightRad' + component_indexes[i])
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');

                gradFill.append('stop')
                .attr('offset', '0%')
                .style('stop-color', 'whitesmoke')
                .style('stop-opacity', 1);

                gradFill.append('stop')
                .attr('offset', '100%')
                .style('stop-color', machine_data.components[parseInt(component_indexes[i])].colour)
                .style('stop-opacity', 1);

            }

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // radius and line-width scale for zoom (NOT USED)
            var minR = base_radius;
            var maxR = 3*base_radius;
            var minL = base_line_width;
            var maxL = 3*base_line_width;
            var lowX = machine_data.run_data[machine_data.run_data.length-1].date_time;
            var hiX = machine_data.run_data[0].date_time;
            var maxX = hiX - lowX;
            var radiusScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxR, minR]);
            var lineScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxL, minL]);

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // offsets and extents (allow for circles) 
            var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            // store/use yScale/xScale
            for(let i in machine_data.lcms_metrics){
                if(machine_data.lcms_metrics[i].display_name == display_metric){
                    // store and set yScale
                    if(machine_data.lcms_metrics[i].yScale == null){
                        yScale_chart = d3.scaleLinear()
                        .domain([y_min - offsetY, y_max + offsetY])
                        .range([height, 0]);
                        machine_data.lcms_metrics[i].yScale = yScale_chart;
                    }
                    else{
                        yScale_chart = machine_data.lcms_metrics[i].yScale;
                    }

                    // set radius
                    if(machine_data.lcms_metrics[i].radius !== null){
                        //radius = machine_data.lcms_metrics[i].radius;
                        radius = base_radius;
                    }
                    else{
                        radius = base_radius;
                    }
                    // set lineWidth
                    if(machine_data.lcms_metrics[i].lineWidth !== null){
                        //lineWidth = machine_data.lcms_metrics[i].lineWidth;
                        lineWidth = base_line_width;
                    }
                    else{
                        lineWidth = base_line_width;
                    }
                    break;
                }
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }
                
            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale_chart)
            .tickSize(v_height_unit).tickSizeOuter(0);
        

            // ylabel left (units)
            svg.append("text")
            .attr("class", "label lineText")
            .attr("y", 0 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(y_labels[display_metric].toUpperCase());

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric lineText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.lcms_metrics){
                        if(machine_data.lcms_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.lcms_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(display_metric.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = display_metric.toUpperCase();

            
            /*ZOOM*/
            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip3") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // brushing
            var brush = d3.brush()                   
                .extent([[0,0], [lineChartWidth,height]]) 
                .on("end", updateZoom);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clip3)")
                .attr("id", "all_lines");
            
            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_chart(d.y)});
            
            // add threshold markers
            var thresholds = getThresholds();
            var overlay = false;
            if(Object.keys(thresholds).length > 0){
                overlay = true;
                // lower thresh
                if(thresholds.threshold_low != ""){
                    all_lines.append("line")
                    .attr("id", "thresh_low")
                    .attr("x1", xScale_chart(d3.min(x_values_chart)))
                    .attr("y1", yScale_chart(thresholds.threshold_low))
                    .attr("x2", xScale_chart(d3.max(x_values_chart)))
                    .attr("y2", yScale_chart(thresholds.threshold_low))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                }
                else{
                    thresholds.threshold_low = 0;
                }

                // upper thresh
                if(thresholds.threshold_high != ""){
                    all_lines.append("line")
                    .attr("id", "thresh_high")
                    .attr("x1", xScale_chart(d3.min(x_values_chart)))
                    .attr("y1", yScale_chart(thresholds.threshold_high))
                    .attr("x2", xScale_chart(d3.max(x_values_chart)))
                    .attr("y2", yScale_chart(thresholds.threshold_high))
                    .attr("stroke", "white")
                    .attr("stroke-width", lineWidth);
                    
                }
                else{
                    thresholds.threshold_high = height;
                }
            
                // rect overlay (top)
                all_lines.append("g")
                .append("rect")
                .attr("class", "topoverlay")
                .attr("width", lineChartWidth)
                .attr("height", function(){
                    var check_height = yScale_chart(thresholds.threshold_high);
                    if(check_height < 0){
                        return 0;
                    }
                    return check_height;
                })
                .attr("x",0)
                .attr("y",0)
                .style("opacity",0.5)
                .attr("fill", function(){
                    if(theme == "dark"){return "var(--dark)";}
                    return "var(--dark)";
                    //return 'url(#gradupper)';
                });

                // rect overlay (bottom)
                if(thresholds.threshold_low != 0){
                    all_lines.append("g")
                    .append("rect")
                    .attr("class", "bottomoverlay")
                    .attr("width", lineChartWidth)
                    .attr("height", function(){
                        var check_height = height - yScale_chart(thresholds.threshold_low);
                        if(check_height < 0){
                            return 0;
                        }
                        return check_height;

                    })
                    .attr("x",0)
                    .attr("y",yScale_chart(thresholds.threshold_low))
                    .style("opacity",0.5)
                    .attr("fill", function(){
                        if(theme == "dark"){return "var(--dark)";}
                        return "var(--dark)";
                        //return 'url(#gradlower)';
                    });
                    
                }
            }

            // Add the brushing (first for line point hover events to work)
            // https://github.com/d3/d3/issues/1604
            all_lines
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // add vertical marker
           all_lines.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 1)
            .attr("cursor", "pointer")
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .on("mouseover", function(event){ // highlight on hover
                d3.selectAll(".point").style("opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 0.05;
                });
                d3.selectAll(".chartline").style("opacity", 0.1);

                // add tooltip
                var tooltip = d3.select("#tooltip");
                tooltip.html("Click to Focus" +  "<br>" + "(Dbl Click Chart <br> to Reset)");
                tooltip.style('left', (event.pageX + 10) + 'px');
                tooltip.style('top', (event.pageY + 10) + 'px');
                tooltip.style("visibility", "visible");
                
            })
            .on("mouseout", function(event){ 
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".chartline").style("opacity", 1);

                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                // hide tooltip (else sticky)
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                if(component_indexes.length > 1){
                    offsetY = (8*currentRadius/height)*(currentMaxY-currentMinY);
                    yScale_chart.domain([currentMinY - offsetY, currentMaxY + offsetY]);
                    reDrawChart();
                }
            });

            // add line (per component)
            for(let i in machine_data.components){
                if(component_indexes.includes(i)){
                    var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                    // convert to d3 friendly format
                    var data = [];
                    for(let j = 0; j < x_values_chart.length; j++){

                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j};
                        data.push(new_row);
                    }

                    // line
                    all_lines.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("class", "chartline chartline"+i) // used to redraw for zoom
                    .attr("stroke", machine_data.components[i].colour) 
                    .attr("stroke-width", lineWidth)
                    .attr("stroke-opacity", 0.3)
                    .attr("cursor", "pointer")
                    .on("mouseover", function(event, d){ // highlight on hover

                        var miss = machine_data.components[i].lcms_metrics[display_metric].missing;

                        // text location boundaries
                        var x = event.layerX;
                        var y = event.layerY;
                        var anchor = "middle"; 
                        if(x >= lineChartWidth -100){
                            x = lineChartWidth - 200;
                            anchor = "start";
                        };
                        if(x <= 150){
                            x = x + 150;
                        }
                        if(y >= height -100){
                            y = height - 100;
                        }

                        // highlight
                        d3.selectAll(".chartline").style("opacity", 0.1);
                        d3.select(this).style("opacity", 1);
                        d3.select(this).style("stroke-opacity", 0.5);
                        d3.selectAll(".point").style("opacity", 0.05);
                        d3.selectAll(".point"+i).style("opacity", 1);

                        // add text
                        svg.append("text")
                        .attr("class", "hover-text")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", "1em")
                        .attr("font-size", "1em")
                        .attr("fill", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .attr("stroke", function(){
                            if(theme == "dark"){return "white";}
                            return "var(--dark)";
                        })
                        .style("text-anchor", anchor)
                        //.style("text-shadow", "0.1vh 0.1vh gray")
                        .text(machine_data.components[i].component_name.replace("_", " "));

                        // add tooltip
                        var tooltip = d3.select("#tooltip");
                        tooltip.html("Click to Focus" +  "<br>" + "(Dbl Click Chart <br> to Reset)");
                        tooltip.style('left', (event.pageX + 10) + 'px');
                        tooltip.style('top', (event.pageY + 10) + 'px');
                        tooltip.style("visibility", "visible");
                        
                    })
                    .on("mouseout", function(event, d){
                        d3.selectAll(".chartline").style("opacity", 1);
                        d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                        d3.selectAll(".point").style("opacity", 1);
                        d3.select(".hover-text").remove();

                        var tooltip = d3.select("#tooltip");
                        tooltip.style("visibility", "hidden");
                    })
                    .on("click", function(event, d){
                        // hide tooltip (else sticky)
                        var tooltip = d3.select("#tooltip");
                        tooltip.style("visibility", "hidden");
                        // redraw on own yscale
                        var compData = d.slice(0, filter);
                        var newMaxY = d3.max(compData, d =>d.y);
                        var newMinY = d3.min(compData, d => d.y);

                        offsetY = (8*currentRadius/height)*(newMaxY-newMinY);
                        yScale_chart.domain([newMinY - offsetY, newMaxY + offsetY]);
                        reDrawChart();
                        
                    })
                    .attr("d", line);
                }
            }

            // add points per date (so can be raised and ordered)
            for(let j = x_values_chart.length-1; j>=0; j--){
                var data = [];
                for(let i in machine_data.components){
                    if(component_indexes.includes(i)){
                        var y_values = machine_data.components[i]["lcms_metrics"][display_metric].values;
                        // convert to d3 friendly format
                        
                        let new_row = {'x': x_values_chart[j], 'y': y_values[j], 'index': j, 'comp': i};
                        data.push(new_row);
                    }
                }

                // order for display
                data = data.sort(function(a,b){ return parseFloat(a.y) - parseFloat(b.y);});

                // store curent extents
                if(j == run_index){
                    currentMaxY = d3.max(data, d=>d.y);
                    currentMinY = d3.min(data, d=>d.y);
                }

                // points
                all_lines.append("g").attr("id", "g"+j)
                .selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => xScale_chart(d.x))
                .attr("cy", d => yScale_chart(d.y))
                .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
                })
                .attr("filter", function(d){
                    if(d.index == run_index){
                    return "url(#specular)";
                    }
                })
                .attr("stroke", d => machine_data.components[d.comp].colour)
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", function(d, i){
                    if(run_index==d.index){
                        return 0.5;
                    }
                    return 0.5;
                })
                .attr("class",d => "point point" + d.comp + " circle"+d.index) // circle for scale change
                .attr("cursor", "pointer")
                .attr("fill-opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 1;
                })
                .attr("fill", function(d,k){
                    var miss = machine_data.components[d.comp].lcms_metrics[display_metric].missing;
                    if(miss.includes(d.index)){
                        return "var(--dark)";
                    }else{
                        if(run_index == d.index){
                            return machine_data.components[d.comp].colour;//'url(#circleGradLight'+d.comp+')'; //machine_data.components[d.comp].colour;
                        }
                        if(theme == "dark") {
                            return 'url(#circleGradLight'+d.comp+')';
                        }
                        return 'url(#circleGradLight'+d.comp+')'; 
                    } 
                })
                .on("mouseover", function(event, d){
                    // // machine_data.run_data[d.index].date_time
                    var tooltip = d3.select("#tooltip");
                    var miss = machine_data.components[d.comp].lcms_metrics[display_metric].missing;
                    if(miss.includes(d.index)){
                        var tooltipHTML = "<strong>" + machine_data.components[d.comp].component_name.replace("_", " ") + 
                                        "</strong><br>" + machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            "NO VALUE" + "</strong>";
                    } else{
                        var tooltipHTML = "<strong>" + machine_data.components[d.comp].component_name.replace("_", " ") + 
                                        "</strong><br>" + machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            Number.parseFloat(d.y).toFixed(3) + "</strong>";
                    }
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");

                    // highlight
                    d3.selectAll(".chartline").style("opacity", 0.1);
                    d3.selectAll(".point").style("opacity", function(f, i){
                        if(f.index == d.index){
                            return 1;
                        }
                        return 0.05;
                    });

                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                    d3.selectAll(".chartline").style("opacity", 1);
                    d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                    d3.selectAll(".point").style("opacity", 1);
                })
                .on("click", function(event, d){
                    // hide tooltip (else sticky)
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");

                    if(run_index == d.index){
                        comp_index = d.comp;
                        draw_chromatogram(true);
                        return;
                    }

                    // update run index
                    run_index = d.index;
                    
                    // move and redraw
                    updateMarker();
                    
                    draw_pressure_profile(true);
                    //update_pressure_profile();
                    setTimeout(function(){
                        draw_line_chart(false);
                    }, 1000)
                    
                    // top controls
                    controlUpdate("chart");
                }).raise(); 
            }
            
            // raise current run
            d3.select("#g"+run_index).raise();

            // right 'axis'
            svg
            .append("line")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .attr('stroke', function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            }) // needs stroke .. stroke v color?
            .style('font-size', '1.8vh')
            .attr("id", "rightAxis")
            .style("opacity", 0) //hiding atm
            .attr("x1", lineChartWidth)
            .attr("y1", 0)
            .attr("x2", lineChartWidth)
            .attr("y2", height);

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            //.style('fill-opacity', 0.5)
            .call(x_axis);
            

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis);
                
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".chartline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".lineText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statsMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            
            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateZoom(event) {
                zoom = true;
                
                // What are the selected boundaries?
                extent = event.selection;
                
                // If no selection just return
                if(!extent){
                    return;
                }else{
                    var x1 = xScale_chart.invert(extent[0][0]);
                    var x2 = xScale_chart.invert(extent[1][0]);
                    //radius = radiusScale(x2-x1);
                    //lineWidth = lineScale(x2-x1);
                    radius = base_radius;
                    lineWidth = base_line_width;
                   
                    xScale_chart.domain([xScale_chart.invert(extent[0][0]), xScale_chart.invert(extent[1][0])]);
                    yScale_chart.domain([yScale_chart.invert(extent[1][1]), yScale_chart.invert(extent[0][1])]);
                    all_lines.select(".brush").call(brush.move, null); // This removes the grey brush area 
                }
                
                reDrawChart();
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                // reset scales
                zoom = false;
                radius = base_radius;
                lineWidth = base_line_width;
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }
                yScale_chart.domain([y_min - offsetY, y_max + offsetY]);
                reDrawChart();
            });

            // used by update functions
            reDrawChart = function (){

                // axis and grid
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);

                // chart
                all_lines
                    .selectAll('.chartline')
                    .transition()
                    .duration(1000)
                    .attr("d", line);
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll('circle')
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_chart(d.y));
                    //.attr("stroke-width", lineWidth)
                    //.attr("r", radius);
                all_lines
                    .select("#marker")
                    .transition()
                    .duration(1000)
                    .attr("x1", xScale_chart(x_values_chart[run_index]))
                    .attr("x2", xScale_chart(x_values_chart[run_index]));
                    //.style("stroke-dasharray", ("3vh, 3vh, 3vh"))
                    //.attr("stroke-width", lineWidth);
                if(overlay){
                    all_lines
                        .select(".topoverlay")
                        .transition()
                        .duration(1000)
                        .attr("width", lineChartWidth)
                        .attr("height", function(){
                            var check_height = yScale_chart(thresholds.threshold_high);
                            if(check_height < 0){
                                return 0;
                            }
                            return check_height;
                        })
                        .attr("x",0)
                        .attr("y",0);
                    all_lines
                        .select(".bottomoverlay")
                        .transition()
                        .duration(1000)
                        .attr("width", lineChartWidth)
                        .attr("height", function(){
                            var check_height = height - yScale_chart(thresholds.threshold_low);
                            if(check_height < 0){
                                return 0;
                            }
                            return check_height;
                        })
                        .attr("x",0)
                        .attr("y",yScale_chart(thresholds.threshold_low));
                    all_lines
                        .select("#thresh_low")
                        .transition()
                        .duration(1000)
                        .attr("x1", xScale_chart(d3.min(x_values_chart)))
                        .attr("y1", yScale_chart(thresholds.threshold_low))
                        .attr("x2", xScale_chart(d3.max(x_values_chart)))
                        .attr("y2", yScale_chart(thresholds.threshold_low));
                        //.attr("stroke-width", lineWidth - 1);
                    all_lines
                        .select("#thresh_high")
                        .transition()
                        .duration(1000)
                        .attr("x1", xScale_chart(d3.min(x_values_chart)))
                        .attr("y1", yScale_chart(thresholds.threshold_high))
                        .attr("x2", xScale_chart(d3.max(x_values_chart)))
                        .attr("y2", yScale_chart(thresholds.threshold_high));
                        //.attr("stroke-width", lineWidth -1);
                }

                // store yScale/xScale
                for(let i in machine_data.lcms_metrics){
                    if(machine_data.lcms_metrics[i].display_name == display_metric){
                        machine_data.lcms_metrics[i].yScale = yScale_chart;  
                        //machine_data.lcms_metrics[i].xScale = xScale_chart;
                        machine_data.lcms_metrics[i].radius = radius;
                        machine_data.lcms_metrics[i].lineWidth = lineWidth;  
                        break;
                    }
                } 

            }
            
        }

        function draw_pressure_line(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot (NOTE: same as draw_line for x-axis and scale)
            var margin = {top: chart_top.offsetHeight + 4*v_height_unit, 
                          right: 4*v_width_unit, 
                          bottom: chart_bottom.offsetHeight + v_height_unit, 
                          left: 4*v_width_unit};

            lineChartWidth = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;
            pressureHeight = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";

            /*** X VALUES ***/
            var run_values = machine_data.run_data;
            x_values_time = [];
            x_values_runs = [];
            for(let run in run_values){
                x_values_time.push(run_values[run].date_time);
                x_values_runs.push(parseInt(run) + 1);
            }

            if(scaleType == "runs"){
                x_values_chart = x_values_runs;
            }
            else{
                x_values_chart = x_values_time;
            }

            // y values and missing indexes
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var y_values = machine_data.pressure_metrics[i].values;
                    var missing = machine_data.pressure_metrics[i].missing;
                    var stats = machine_data.pressure_metrics[i].stats;
                    break;
                }
            };

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // background
            svg.
            append("rect")
                .attr("id", "backLine")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("class", function(){
                    if(theme == "dark"){return "darkTheme";}
                    return "lightTheme";
                })
                .attr("x",0)
                .attr("y",0);

            // radius and line-width scale for zoom (NOT USED)
            var minR = base_radius;
            var maxR = 3*base_radius;
            var minL = base_line_width;
            var maxL = 3*base_line_width;
            var lowX = machine_data.run_data[machine_data.run_data.length-1].date_time;
            var hiX = machine_data.run_data[0].date_time;
            var maxX = hiX - lowX;
            let radiusScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxR, minR]);
            let lineScale = d3.scaleLinear()
                .domain([0, maxX])
                .range([maxL, minL]);

            var y_min = d3.min(y_values.slice(0, filter));
            var y_max = d3.max(y_values.slice(0, filter));

            // offsets and extents (allow for circles) 
            var offsetY = (2*currentRadius/height)*(y_max-y_min);
            var offsetX = (2*currentRadius/lineChartWidth)*(d3.max(x_values_chart.slice(0, filter))-d3.min(x_values_chart.slice(0, filter)));
            if(scaleType == "time"){
                var minX = new Date(d3.min(x_values_chart.slice(0, filter)) - offsetX);
                var maxX = new Date(+d3.max(x_values_chart.slice(0, filter)) + offsetX); // + needed as hint else it will concatenate
            }
            else{
                var minX = d3.min(x_values_chart.slice(0, filter)) - offsetX;
                var maxX = d3.max(x_values_chart.slice(0, filter)) + offsetX;
            }

            // store/use yScale/xScale
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    // store and set yScale
                    if(machine_data.pressure_metrics[i].yScale == null){
                        yScale_pressure = d3.scaleLinear()
                        .domain([y_min - offsetY, y_max + offsetY])
                        .range([height, 0]);
                        machine_data.pressure_metrics[i].yScale = yScale_pressure;
                    }
                    else{
                        yScale_pressure = machine_data.pressure_metrics[i].yScale;
                    }
                    
                    // set radius (NOT STORING RESIZE NOW)
                    if(machine_data.pressure_metrics[i].radius !== null){
                        //radius = machine_data.pressure_metrics[i].radius;
                        radius = base_radius;
                    }
                    else{
                        radius = base_radius;
                    }
                    // set lineWidth
                    if(machine_data.pressure_metrics[i].lineWidth !== null){
                        //lineWidth = machine_data.pressure_metrics[i].lineWidth;
                        lineWidth = base_line_width;
                    }
                    else{
                        lineWidth = base_line_width;
                    }
                    break;
                }
            }

            /*** SCALES ***/
            // time scale
            if(xScale_time == null){
                xScale_time = d3.scaleTime()
                            .domain([minX, maxX])
                            .range([0, lineChartWidth]);
            }
            
            // runs scale
            if(xScale_runs == null){
                xScale_runs = d3.scaleLinear()
                        .domain([maxX, minX])
                        .range([0, lineChartWidth]);
            }

            // set x scale
            if(xScale_chart == null){
                if(scaleType == "runs"){
                    xScale_chart = xScale_runs;
                }
                else{
                    xScale_chart = xScale_time;
                }
            }

            /*** X AXIS ***/
            // time x-axis 
            x_axis_time = d3.axisTop().scale(xScale_time)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);

            // runs x-axis 
            x_axis_runs = d3.axisTop().scale(xScale_runs)
                .tickSize(v_height_unit).ticks(5).tickSizeOuter(0);
                

            if(scaleType == "runs"){
                x_axis = x_axis_runs;
            }
            else{
                x_axis = x_axis_time;
            }
                
            // y-axis
            var y_axis = d3.axisLeft().ticks(5).scale(yScale_pressure)
            .tickSize(v_height_unit).tickSizeOuter(0);

            // ylabel
            var labelText = "BARS";
            if(display_metric == "Retention Time at Maximum Pressure"){
                labelText = "MINUTES";
            }

            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label pressureText")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .text(labelText);

            // expand/contract icons
            if(controls){
                var linkRef = "#expandIcon";
                var linkTip = "Hide Controls";
            }
            else{
                var linkRef = "#contractIcon";
                var linkTip = "Show Controls";
            }
            
            // add icon
            svg
            .append("use")
            .attr("id", "chartIcon")
            .attr("xlink:href", linkRef)
            .attr("x", "92%")
            .attr("y", "-2%")
            .attr("width", 2*v_width_unit)
            .attr("height", 2*v_width_unit)
            .style("fill", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("cursor","pointer")
            .on("mouseover", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.html(linkTip);
                tooltip.style('left', (event.pageX - 10*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 5*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .on("click", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
                changeControls();
            });

            // handle too long name
            var metricDisplay = display_metric;
            if(metricDisplay == "Retention Time at Maximum Pressure"){
                metricDisplay = "RT at Max. Pressure";
            }

            // ylabel right (display metric)
            svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("class", "label-metric pressureText")
            .attr("y", -lineChartWidth- margin.right/2)
            .attr("x",(height / 2))
            .attr("dy", "1em")
            .style("cursor", "help")
            .style("text-anchor", "middle")
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .on("mouseover", function(event){
                // set header tooltip
                var toolInfo;
                for(let i in machine_data.pressure_metrics){
                        if(machine_data.pressure_metrics[i].display_name == display_metric){
                            toolInfo = machine_data.pressure_metrics[i].metric_info;
                            break;
                        }
                }
                var tooltip = d3.select("#tooltip");
                tooltip.html(toolInfo);
                tooltip.style('left', (event.pageX - 55*v_height_unit) + 'px');
                tooltip.style('top', (event.pageY - 25*v_height_unit) + 'px');
                tooltip.style("visibility", "visible");

            })
            .on("mouseout", function(event){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })
            .attr("visibility", function(){
                if(controls){return "hidden";}
                return "visible";
            }) 
            .text(metricDisplay.toUpperCase());

            // update header
            var chart_header = document.getElementById("chartHeader");
            chart_header.innerHTML = metricDisplay.toUpperCase();

            /*ZOOM*/
            /*https://www.d3-graph-gallery.com/graph/line_brushZoom.html*/

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip4") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", lineChartWidth)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);

            // brushing
            var brush = d3.brush()                   
                .extent([[0,0], [lineChartWidth,height]])
                .on("end", updateZoom);
            
            // add each line 
            var all_lines = svg.append('g')
                .attr("clip-path", "url(#clip4)")
                .attr("id", "all_lines");
            
            // curved line
            line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale_chart(d.x)})
                                        .y(function(d, i) {return yScale_pressure(d.y)});

            // add brushing first (for events)
            all_lines
            .append("g")
                .attr("class", "brush")
                .call(brush);

            // add vertical marker
           all_lines.append("line")
            .attr("id", "marker")
            .attr("x1", xScale_chart(x_values_chart[run_index]))
            .attr("y1", 0)
            .attr("x2", xScale_chart(x_values_chart[run_index]))
            .attr("y2", height)
            .attr("stroke", function(){
                if(theme == "dark"){return "white"}
                return "var(--dark)";
            })
            .style("stroke-dasharray", ("1vh, 1vh, 1vh"))
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity" ,1)
            .on("mouseover", function(event, d){
                d3.selectAll(".point").style("opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 0.05;
                });
                d3.selectAll(".chartline").style("opacity", 0.1);
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".point").style("opacity", 1);
                d3.selectAll(".chartline").style("opacity", 1);
            });

            // convert to d3 friendly format
            var data = [];
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                // data
                data.push(new_row);
            }

            // getarray for stats (based on filter)
            var statsData = [];
            for(let i = filter-1; i>=0; i--){
                // stats data
                if(!(missing.includes(i))){
                    statsData.push(y_values[i]);
                }
            }

            // calculate stats
            statsArr = [{"name": "Mean", "value": calcAverage(statsData)}, 
                            {"name": "Median", "value": calcQuartile(statsData, 50)}, 
                            {"name": "Q1", "value": calcQuartile(statsData, 25)},
                            {"name": "Q3", "value": calcQuartile(statsData, 75)}];
            
            // sort to handle display offsets
            statsArr = statsArr.sort(function(a,b){ return parseFloat(a.value) - parseFloat(b.value);});

            // draw stats markers
            all_lines
            .selectAll("statsline")
            .data(statsArr)
            .enter()
            .append('line')
            .attr("class", "statsMarker")
            .attr("x1", 0)
            .attr("y1", function(d, i) {
                return yScale_pressure(d.value);
            })
            .attr("x2", 2*v_width_unit)
            .attr("y2", function(d, i) {
                return yScale_pressure(d.value);
            })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)"
            })
            .attr("stroke-opacity", 1)
            .attr("stroke-width", '0.4vh');

            // add stat name
            all_lines
            .selectAll("text")
            .data(statsArr)
            .enter()
            .append('text')
            .attr('class', 'statText')
            //.attr("filter", "url(#specular)")
            .attr("x", 2*v_width_unit)
            .attr("y", d => yScale_pressure(d.value))
            .attr("dy", function(d, i){
                if(i < 2){return 2*v_height_unit}
                return -v_height_unit;
            })
            .attr("dx", function(d, i){
                if(i % 2 == 0){return v_height_unit}
                return -2*v_height_unit;
            })
            .attr("opacity", 1)
            .attr("fill", function(){
                    if(theme == "dark"){return "white";}
                    return "var(--dark)";
                })
            .attr("stroke", function(){
                if(theme == "dark"){return "white";}
                return "var(--dark)";
            })
            .attr("text-anchor", "start")
            .style("letter-spacing", "0.3vh")
            .text(d => d.name.toUpperCase())
            .attr("font-size", "2.5vh")
            .on("mouseover", function(event, d){
                // highlight
                d3.selectAll(".statText").style("opacity", 0.05);
                d3.select(this).style("opacity",1);
                d3.selectAll(".statsMarker").style("stroke-opacity", function(e,i){
                    if(d.name == e.name){return 1;}
                    return 0.05;
                });
                d3.selectAll(".chartline").style("stroke-opacity", 0);
                

                // tooltip
                var tooltip = d3.select("#tooltip");
                var tooltipHTML = "<strong>" + d.name + "</strong></br>" + d.value.toFixed(2);
                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX+10) + 'px');
                tooltip.style('top', (event.pageY+10) + 'px');
                tooltip.style("visibility", "visible");
            })
            .on("mouseout", function(event, d){
                d3.selectAll(".statText").style("opacity", 1);
                d3.selectAll(".statsMarker").style("stroke-opacity", 1);
                d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                d3.selectAll(".point").style("stroke-opacity", function(e, i){
                    if(run_index == e.index){
                        return 0.5;
                    }
                    return 0.5;
                });
                var tooltip = d3.select("#tooltip");
                tooltip.style('left', '0px');
                tooltip.style('top', '0px');
                d3.select("#tooltip").style("visibility", "hidden");
            })

            // line
            all_lines.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("class", "chartline") // used to redraw for zoom
            .attr("stroke", "lightskyblue")
            .attr("stroke-width", lineWidth)
            .attr("stroke-opacity", 0.3)
            .attr("d", line)
            .on("mouseover", function(event, d){
                // highlight
                //d3.select(this).style("stroke-opacity", 1);
                //d3.selectAll(".point").style("stroke-opacity", 1);
                d3.selectAll(".statText").style("opacity", 0.05);
                d3.selectAll(".statsMarker").style("stroke-opacity", 0.05);

            })
            .on("mouseout", function(event, d){
                d3.selectAll(".chartline").style("stroke-opacity", 0.3);
                d3.selectAll(".point").style("stroke-opacity", function(e, i){
                    if(run_index == e.index){
                        return 0.5;
                    }
                    return 0.5;
                });
                d3.selectAll(".statText").style("opacity", 1);
                d3.selectAll(".statsMarker").style("stroke-opacity", 1);
            })

            // ADD points in loop so can raise
            for(let i = machine_data.run_data.length-1; i>=0; i--){
                var data = [];
                let new_row = {'x': x_values_chart[i], 'y': y_values[i], 'index':i};
                data.push(new_row);

                // points
                all_lines.append("g").attr("id", "g"+i)
                .selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => xScale_chart(d.x))
                .attr("cy", d => yScale_pressure(d.y))
                .attr("r", function(d, i){
                    if(d.index == run_index){
                        return currentRadius;
                    }
                    return radius;
                })
                .attr("x", function(d, i) {return xScale_chart(d.x)})
                .attr("y", function(d, i) {return yScale_pressure(d.y)})
                .attr("stroke", "lightskyblue")
                .attr("stroke-width", lineWidth/2)
                .attr("stroke-opacity", function(d, i){
                    if(d.index == run_index){
                        return 0.5;
                    }
                    else{
                        return 0.5;
                    }
                })
                .attr("class","point circle"+i)
                .attr("fill-opacity", function(d, i){
                    if(d.index == run_index){
                        return 1;
                    }
                    return 1;
                })
                .attr("filter", "url(#specular)")
                .attr("fill", function(d,j){
                    if(missing.includes(j)){
                        return "var(--dark)";
                    }else{
                        return  "url(#chromFill)";
                    } 
                })
                .on("mouseover", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    if(missing.includes(d.index)){
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            "NO VALUE" + "</strong>";
                    } else{
                        var tooltipHTML = machine_data.run_data[d.index].date_time.toDateString() + "<br>" +
                                            get_time(machine_data.run_data[d.index].date_time) +  "<br><strong>" +
                                            Number.parseFloat(d.y).toFixed(3) + "</strong>";
                    }
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+10) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");

                    // highlight
                    //d3.select(".chartline").style("stroke-opacity", 1);
                    //d3.selectAll(".point").style("stroke-opacity", 1);
                })
                .on("mouseout", function(){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style("visibility", "hidden");
                });
            }

            // raise current run
            d3.select("#g"+run_index).raise();

            // x-axis call (store for zoom)
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + '0' + ")")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "xAxisLine")
            .call(x_axis);

            // y-axis calls
            var y_axis_call = svg.append("g")
            .attr('class', function(){
                    if(theme == "dark"){return "Axis axis-dark";}
                    return "Axis axis-light";
                })
            .style('font-size', '1.8vh')
            .attr("id", "yAxisLine")
            .call(y_axis);
            

            // transition by chart elements
            
            if(transition){
                d3.selectAll(".point").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".chartline").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.select("#yAxisLine").style("opacity", 0)
                .transition().duration(500).style("opacity", 0.7);

                d3.selectAll(".pressureText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statsMarker").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

                d3.selectAll(".statText").style("opacity", 0)
                .transition().duration(500).style("opacity", 1);

            }
            

            reDrawPressureChart = function(){
                // Update axis and line/point position etc
                x_axis_call.transition().duration(1000).call(x_axis);
                y_axis_call.transition().duration(1000).call(y_axis);
        
                all_lines
                    .selectAll('.chartline')
                    .transition()
                    .duration(1000)
                    .attr("d", line);
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll('circle')
                    .transition()
                    .duration(1000)
                    .attr("cx", d => xScale_chart(d.x))
                    .attr("cy", d => yScale_pressure(d.y));
                    //.attr("stroke-width", lineWidth)
                    //.attr("r", radius);
                all_lines
                    .select("#marker")
                    .transition()
                    .duration(1000)
                    .attr("x1", xScale_chart(x_values_chart[run_index]))
                    .attr("x2", xScale_chart(x_values_chart[run_index]));
                    //.attr("stroke-width", lineWidth);
                all_lines
                    .selectAll(".statsMarker")
                    .data(statsArr)
                    .transition()
                    .duration(1000)
                    .attr("y1", function(d, i) {
                        return yScale_pressure(d.value);
                    })
                    .attr("y2", function(d, i) {
                        return yScale_pressure(d.value);
                    });
                all_lines   
                    .selectAll(".statText")
                    .data(statsArr)
                    .transition()
                    .duration(1000)
                    .attr("y", d => yScale_pressure(d.value))
                    .attr("dy", function(d, i){
                        if(i < 2){return 2*v_height_unit}
                        return -v_height_unit;
                    })
                    .attr("dx", function(d, i){
                        if(i % 2 == 0){return v_height_unit}
                        return -2*v_height_unit;
                    });

                // store yScale/xScale
                for(let i in machine_data.pressure_metrics){
                    if(machine_data.pressure_metrics[i].display_name == display_metric){
                        machine_data.pressure_metrics[i].yScale = yScale_pressure;  
                        //machine_data.pressure_metrics[i].xScale = xScale_chart;
                        machine_data.pressure_metrics[i].radius = radius;
                        machine_data.pressure_metrics[i].lineWidth = lineWidth;  
                        break;
                    }
                }
            }

            // Function that updates the chart for given boundaries
            // d3 passes the event to the function in v6 (not in v4)
            function updateZoom(event) {
                // What are the selected boundaries?
                extent = event.selection;

                // If no selection just return
                if(!extent){
                    return;
                }else{
                    var x1 = xScale_chart.invert(extent[0][0]);
                    var x2 = xScale_chart.invert(extent[1][0]);
                    radius = radiusScale(x2-x1);
                    lineWidth = lineScale(x2-x1);

                    xScale_chart.domain([xScale_chart.invert(extent[0][0]), xScale_chart.invert(extent[1][0])])
                    yScale_pressure.domain([yScale_pressure.invert(extent[1][1]), yScale_pressure.invert(extent[0][1])])
                    all_lines.select(".brush").call(brush.move, null) // This remove the grey brush area 
                }
                reDrawPressureChart();
                
            }

            // If user double click, reinitialize the chart
            svg.on("dblclick",function(){
                radius = base_radius;
                lineWidth = base_line_width;
                if(scaleType == "runs"){
                    xScale_chart.domain([maxX, minX]);
                }
                else{
                    xScale_chart.domain([minX, maxX]);
                }
                yScale_pressure.domain([y_min - offsetY, y_max + offsetY]);
            
                reDrawPressureChart();
            });
        }

        function radioUpdate(event){

            // handle icon clicks
            var el = event.target;
            if(el.tagName == "SPAN"){
                el = event.target.parentElement;
            }
            
            // manually collapse from button (bootstrap method not working)
            if(el.getAttribute("type") == "button"){
                
                
                if(el.nextSibling.classList.contains("show")){
                    el.nextSibling.classList.remove("show");
                }
                else{
                    el.nextSibling.classList.add("show");
                }

                // track state so can manage when redrawb from date controls
                if(el.innerText == "PRESSURE METRICS"){
                    metric_show_display = "pressure";
                }else{
                    metric_show_display = "lcms";
                }
                menu_state[metric_show_display] = !menu_state[metric_show_display];
                
            }

            // update display metric
            if(event.target.getAttribute("type") == "radio"){ // only respond to input

                // update menu type (only if input selected)
                if(event.target.classList.contains("pressure")){
                    metric_type = "pressure";
                }else{
                    metric_type = "lcms";
                }

                // disable/enable box plots for normalised
                display_metric = event.target.labels[0].innerText;
                if(display_metric == "Area (normalised)" || display_metric == "Height (normalised)"){
                    document.getElementById("box").disabled = true;
                    document.getElementById("box").style.boxShadow = "";
                    document.getElementById("box").classList = "btn";
                }
                else{
                    document.getElementById("box").disabled = false;
                    document.getElementById("box").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("box").classList = "btn btn-custom";
                }

                // disable heat maps and box and density for pressure
                if(event.target.classList.contains("pressure")){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("heat").style.boxShadow = "";
                    document.getElementById("heat").classList = "btn";
                    document.getElementById("box").disabled = true;
                    document.getElementById("box").style.boxShadow = "";
                    document.getElementById("box").classList = "btn";
                    document.getElementById("density").disabled = true;
                    document.getElementById("density").style.boxShadow = "";
                    document.getElementById("density").classList = "btn";
                    document.getElementById("stream").disabled = true;
                    document.getElementById("stream").style.boxShadow = "";
                    document.getElementById("stream").classList = "btn";
                    document.getElementById("parallel").disabled = true;
                    document.getElementById("parallel").style.boxShadow = "";
                    document.getElementById("parallel").classList = "btn";
                }
                else if(display_metric == "Retention Time" || display_metric == "Full Width Half Maximum"){
                    document.getElementById("heat").disabled = true;
                    document.getElementById("heat").style.boxShadow = "";
                    document.getElementById("heat").classList = "btn";
                    document.getElementById("stream").disabled = false;
                    document.getElementById("stream").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("stream").classList = "btn btn-custom";
                    document.getElementById("density").disabled = false;
                    document.getElementById("density").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("density").classList = "btn btn-custom";
                    document.getElementById("parallel").disabled = false;
                    document.getElementById("parallel").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("parallel").classList = "btn btn-custom";

                }
                else{
                    document.getElementById("heat").disabled = false;
                    document.getElementById("heat").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("heat").classList = "btn btn-custom";
                    document.getElementById("density").disabled = false;
                    document.getElementById("density").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("density").classList = "btn btn-custom";
                    document.getElementById("stream").disabled = false;
                    document.getElementById("stream").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("stream").classList = "btn btn-custom";
                    document.getElementById("parallel").disabled = false;
                    document.getElementById("parallel").style.boxShadow = "gray 0.2em 0.2em 0.4em";
                    document.getElementById("parallel").classList = "btn btn-custom";
                }

                // set/reset controls
                var chart_bottom = document.getElementById("chart_bottom");
                var chart_top = document.getElementById("chart_top");
                if(controls){
                    // add bottom controls
                    chart_top.style.display = "block";
                    chart_bottom.style.display = "block";
                }
                else{
                    // remove top and bottom controls
                    chart_top.style.display = "none";
                    chart_bottom.style.display = "none";
                }

                // re draw current chart
                if(chart_type == "line"){
                    if(event.target.classList.contains("pressure")){
                        metric_type = "pressure";
                        draw_pressure_line(true);
                    }else{
                        metric_type = "lcms";
                        draw_line_chart(true);
                    }
                }
                else if(chart_type == "box"){
                    yScale_box = null; 
                    draw_box_plot(true);
                    
                }
                else if(chart_type == "heat"){
                    draw_heat_map(false);
                }
                else if(chart_type == "stream"){
                    draw_stream_graph(true);
                }
                create_components_menu(false);
            }
        }

        function draw_pressure_density(transition){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var chart_top = document.getElementById("chart_top");
            //var chart_header_div = document.getElementById("chart_header_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            plot_area.style.backgroundColor = "inherit";
            
            if(transition){
                plot_area.style.opacity = 0;
                //chart_header.innerHTML = display_metric;
            }

            // x values and missing indexes
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var x_values = machine_data.pressure_metrics[i].values;
                    var missing = machine_data.pressure_metrics[i].missing;
                    break;
                }
            };
            
            // set the dimensions and margins of the plot 
            var margin = {top: chart_top.offsetHeight + v_height_unit, 
                          right: 2*v_width_unit, 
                          bottom: chart_bottom.offsetHeight+6*v_height_unit, 
                          left: 4*v_width_unit};

            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // remove missing
            x_values = x_values.filter(function(value, i){
                        if(!missing.includes(i) && i<filter){
                            return value;
                        }
                    })

            // get x extents 
            var x_max = d3.max(x_values);
            var x_min = d3.min(x_values);
            var offset = 5;

            // x scale
            var xScale = d3.scaleLinear()
                .domain([x_min - offset, x_max + offset])
                .range([0, width]);

        
            // data points effects degree of smoothing
            var data_points = Math.ceil(x_values.length/2);

            // get kernel estimate data
            var h = silvermans(x_values);
            var kde = kernelDensityEstimator(kernelEpanechnikov(h), xScale.ticks(data_points));
            var density =  kde(x_values);
            
            // y extents
            var y_max = d3.max(density, function(d) {return d[1]});
            
            // y scale
            var yScale = d3.scaleLinear()
                    .domain([0 , y_max])
                    .range([height, 0]);
            
            // y-axis
            var y_axis = d3.axisLeft().scale(yScale)
            .tickSize(v_height_unit).tickSizeOuter(0);
            
            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr("class", "axis-chart")
                .call(y_axis)
                .style('font-size', '1.6vh');

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("DENSITY");

            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // curved line
            var line = d3.line().curve(d3.curveMonotoneX)
                                    .x(function(d, i) {return xScale(d[0])})
                                        .y(function(d, i) {return yScale(d[1])});

            // area under curve
            var area = d3.area().curve(d3.curveMonotoneX)
                        .x(function(d) {return xScale(d[0]);})
                        .y0(height)
                        .y1(function(d) { return yScale(d[1]);});

            // x-axis
            var x_axis = d3.axisBottom().scale(xScale)
            .tickSize(v_height_unit).tickSizeOuter(0);
            
            // x-axis calls
            var x_axis_call = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "axis-chart")
                .call(x_axis)
                .style('font-size', '1.6vh');

            
            // x-label
            var labelText = "BARS";
            if(display_metric == "Retention Time at Maximum Pressure"){
                labelText = "MINUTES";
            }

            svg.append("text")
            .attr("class", "label")
            .attr("y", height +(margin.bottom/2))
            .attr("x",width/2)
            .style("text-anchor", "middle")
            .text(labelText);

            // grid x 
            var xAxisGrid = d3.axisBottom().scale(xScale)
            .tickSize(-height).tickFormat('').tickSizeOuter(0);

            // grid call x
            var x_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisGrid);

            // plot the density distribution (area)
            svg.append("path")
                    .datum(density)
                    .attr("class", "densearea")
                    .attr("fill", "var(--teal)")
                    .attr("fill-opacity", 0.1)
                    .attr("stroke-width", "0")
                    .attr("pointer-events", "none")
                    .attr("d", area);
                
            // plot the density distribution (lines)
            svg.append("path")
                .datum(density)
                .attr("fill", "none")
                .attr("stroke", "var(--teal)")
                .attr("stroke-width", lineWidth)
                .on("mouseover", function(event, d){ // highlight on hover

                    // text location boundaries
                    var x = event.layerX;
                    var y = event.layerY;
                    var anchor = "middle"; 
                    if(x >= width - 100){
                        x = width - 200;
                        anchor = "start";
                    };
                    if(x <= 150){
                        x = x + 150;
                    }
                    if(y >= height -100){
                        y = height - 100;
                    }

                    // highlight
                    d3.selectAll(".densearea").style("fill-opacity", 0.5);
                    
                    // add text
                    svg.append("text")
                    .attr("class", "hover-text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", "1em")
                    .attr("font-size", "1em")
                    .style("text-anchor", anchor)
                    .text(display_metric);
                })
                .on("mouseout", function(){
                    d3.selectAll(".densearea").style("fill-opacity", 0.1);
                    d3.select(".hover-text").remove();
                })
                .attr("d", line);

            if(transition){
                d3.select("#plot_chart").transition().duration(500).style("opacity", 1);
            }
        }

        function draw_pressure_box(transition){
            /*NOTUSED*/
            // get width and height of plot area
            var plot_area = document.getElementById("plot_chart");
            //var chart_header = document.getElementById("chart_header");
            var chart_bottom = document.getElementById("chart_bottom");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }
            
            if(transition){
                plot_area.style.opacity = 0;
                //chart_header.innerHTML = display_metric;
            }

            // x values
            var run_values = machine_data.run_data
            var x_values = [];
            for(let run in run_values){
                x_values.push(run_values[run].date_time);
            }

            // y values and missing indexes
            var data= [];
            for(let i in machine_data.pressure_metrics){
                if(machine_data.pressure_metrics[i].display_name == display_metric){
                    var new_obj = machine_data.pressure_metrics[i].stats;
                    new_obj["missing"] = machine_data.pressure_metrics[i].missing;
                    new_obj["current"] = machine_data.pressure_metrics[i].values[run_index];
                    data.push(new_obj);
                    break;
                }
            };

            // set the dimensions and margins of the plot
            var margin = {top: 10, right: 10, bottom: 20, left: 50};
            var width = plot_width - margin.left - margin.right;
            box_area_height = plot_height - margin.top - margin.bottom;
            
            // boxwidth
            var box_padding = 10;
            var box_width = width/4;

            // append the svg object to the plot area
            var svg = d3.select("#plot_chart")
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // x scale
            xScale_box = d3.scaleBand()
                .range([0, width])
                .domain([display_metric])
                .paddingInner(1)  // between
                .paddingOuter(0.5); // before and after

            // x-axis 
            var x_axis = d3.axisBottom().scale(xScale_box).tickValues([]).tickSizeOuter(0);

            // x-axis-call
            var x_axis_call = svg.append("g")
            .attr("transform", "translate(0," + box_area_height + ")")
            .attr("class", "axis-chart")
            .call(x_axis);

            // y-scale
            // set at outlier limit
            var IQR = data[0]["75_percent"] - data[0]["25_percent"];
            yScale_box = d3.scaleLinear()
                .domain([data[0]["25_percent"] - IQR , data[0]["75_percent"] + IQR])
                .range([box_area_height, 0]);
            
            // y-axis
            var y_axis = d3.axisLeft().scale(yScale_box)
            .tickSize(v_height_unit).tickSizeOuter(0);

            // y-axis calls
            var y_axis_call = svg.append("g")
                .attr("class", "axis-chart")
                .call(y_axis);
            
            // grid y
            var yAxisGrid = d3.axisLeft().scale(yScale_box).
            tickSize(-width).tickFormat('').tickSizeOuter(0);

            // grid y call
            var y_axis_grid_call = svg.append("g")
            .attr('class', 'axis-grid')
            .call(yAxisGrid);

            // ylabel
            svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("class", "label")
            .attr("y", 5 - margin.left)
            .attr("x",0 - (box_area_height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("BARS");

            // add the box
            svg
            .selectAll("boxes")
            .data(data)
            .enter()
            .append("rect")
                .attr("x", function(d){return(xScale_box(display_metric)- box_width/2)})
                .attr("y", function(d){return(yScale_box(d["75_percent"]))})
                .attr("height", function(d){return(yScale_box(d["25_percent"])-yScale_box(d["75_percent"]))})
                .attr("width", box_width)
                .attr("stroke", "var(--info)")
                .attr("stroke-width", "2px")
                .style("fill", "var(--info)")
                .style("fill-opacity", 0.5)
                .on("mouseover", function(event, d){
                    // tooltip
                    var tooltip = d3.select("#tooltip");
                    var tooltipHTML = "<strong>" + display_metric + "</strong><br>" +
                                    "<strong>Q1 </strong>" + d["25_percent"].toFixed(3) + "<br>" +
                                    "<strong>Q3 </strong>" + d["75_percent"].toFixed(3) + "<br>" +
                                    "<strong>Median </strong>" + d["50_percent"].toFixed(3) + "<br>" +
                                    "<strong>Mean </strong>" + d["mean"].toFixed(3);
                                        
                    tooltip.html(tooltipHTML);
                    tooltip.style('left', (event.pageX+30) + 'px');
                    tooltip.style('top', (event.pageY+10) + 'px');
                    tooltip.style("visibility", "visible");
                })
                .on("mouseout", function(event, d){
                    var tooltip = d3.select("#tooltip");
                    tooltip.style('left', '0px');
                    tooltip.style('top', '0px');
                    tooltip.style("visibility", "hidden");
                });

            // median
            svg
            .selectAll("medianLines")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(display_metric)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["50_percent"]))})
            .attr("y2", function(d){return(yScale_box(d["50_percent"]))})
            .attr("stroke", "white");

             // mean
             svg
            .selectAll("meanLines")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric)-box_width/2) })
            .attr("x2", function(d){return(xScale_box(display_metric)+box_width/2) })
            .attr("y1", function(d){return(yScale_box(d["mean"]))})
            .attr("y2", function(d){return(yScale_box(d["mean"]))})
            .attr("stroke", "white")
            .style("stroke-dasharray", ("3, 3"));

            // current run
            svg
            .selectAll("currentRun")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", d => xScale_box(display_metric))
            .attr("cy", function(d){
                    // cap so does not go off chart
                    if(yScale_box(d.current) > box_area_height){
                        return box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    
                    return yScale_box(d.current)
                })
            .attr("r", currentRadius)
            .attr("x", function(d, i) {return xScale_box(display_metric)})
            .attr("y", function(d){
                    // cap so does not go off chart
                    /*
                    if(yScale_box(d.current) > box_area_height){
                        return  box_area_height;
                    }
                    if(yScale_box(d.current)<0){
                        return 0;
                    }
                    */
                    return yScale_box(d.current)
                })
            .attr("stroke", "var(--info)")
            .attr("stroke-width", 2)
            .attr("class","point")
            .attr("fill", function(d,j){
                var miss = d.missing;
                if(miss.includes(run_index)){
                    return "var(--dark)";
                }
                else if(yScale_box(d.current) > box_area_height){
                        return  "var(--info)";
                    }
                else if(yScale_box(d.current)<0){
                    return "var(--info)";
                }
                else{
                    return "whitesmoke";
                }
            })
            .on("mouseover", function(event, d){ // tooltip on hover
                var tooltip = d3.select("#tooltip");
                var miss = d.missing;
                if(miss.includes(run_index)){
                    var tooltipHTML = "<strong>" + display_metric.replace("_", " ") + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        "NO VALUE" + "</strong>";
                } else{
                    var tooltipHTML = "<strong>" +  display_metric.replace("_", " ")  + 
                                    "</strong><br>" + machine_data.run_data[run_index].date_time.toDateString() + "<br>" +
                                        get_time(machine_data.run_data[run_index].date_time) +  "<br><strong>" +
                                        Number.parseFloat(d.current).toFixed(3) + "</strong>";
                }
                tooltip.html(tooltipHTML);
                tooltip.style('left', (event.pageX+30) + 'px');
                tooltip.style('top', (event.pageY+10) + 'px');
                tooltip.style("visibility", "visible");
            })
            .on("mouseout", function(){
                var tooltip = d3.select("#tooltip");
                tooltip.style("visibility", "hidden");
            })

            // extender
            svg
            .selectAll("extenders")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function(d){return(xScale_box(display_metric))})
            .attr("x2", function(d){return(xScale_box(display_metric))})
            .attr("y1", function(d){
                var y1;
                if(d.current >= d["75_percent"]){
                    y1 = yScale_box(d.current);
                }
                else if(d.current <= d["25_percent"]){
                    y1 = yScale_box(d["25_percent"]);
                }
                else{
                    y1 =  yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y1 < 0){
                    return 0;
                }
                return y1;
                */
            })
            .attr("y2", function(d){
                var y2;
                if(d.current >= d["75_percent"]){
                    y2 = yScale_box(d["75_percent"]);
                }
                else if(d.current <= d["25_percent"]){
                    y2 = yScale_box(d.current);
                }
                else{
                    y2 = yScale_box(d.current);
                }
                /*
                // cap so does not go off chart
                if(y2 > box_area_height){
                    return box_area_height;
                }
                return y2;
                */
            })
            .attr("stroke", "var(--info)")
            .attr("stroke-width", 2)
            .attr("class", "extender");

            if(transition){
                d3.select("#plot_chart").transition().duration(500).style("opacity", 1);
            }
        }

        function getThresholds(){
            var thresholds = {};
            var threshold_metrics = ["Mass Error (ppm)"]; // only displayable thresholds at the moment
            if(!threshold_metrics.includes(display_metric)){
                return thresholds;
            }

            // get threshold markers
            for(let i in machine_data["lcms_metrics"]){
                if(machine_data["lcms_metrics"][i].display_name == display_metric){
                   thresholds = machine_data["lcms_metrics"][i]["thresholds"];
                }
            };
            return thresholds;
        }

    </script>
</head>